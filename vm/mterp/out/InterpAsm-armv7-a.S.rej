diff a/vm/mterp/out/InterpAsm-armv7-a.S b/vm/mterp/out/InterpAsm-armv7-a.S	(rejected hunks)
@@ -181,8 +181,17 @@ unspecified registers or condition codes.
 /*
  * Get/set the 32-bit value from a Dalvik register.
  */
+#ifdef WITH_TAINT_TRACKING
+#define SET_TAINT_FP(_reg)		add		_reg, rFP, #4
+#define SET_TAINT_CLEAR(_reg)	mov		_reg, #0
+#define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #3]
+#define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #3]
+#define GET_VREG_TAINT(_reg, _vreg, _rFP)	ldr	_reg, [_rFP, _vreg, lsl #3]
+#define SET_VREG_TAINT(_reg, _vreg, _rFP)	str _reg, [_rFP, _vreg, lsl #3]
+#else
 #define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #2]
 #define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #2]
+#endif /*WITH_TAINT_TRACKING*/
 
 #if defined(WITH_JIT)
 #define GET_JIT_ENABLED(_reg)       ldr     _reg,[rGLUE,#offGlue_jitEnabled]
@@ -240,7 +254,7 @@ unspecified registers or condition codes.
 .endm
 
 
-/* File: armv5te/entry.S */
+/* File: armv5te_taint/entry.S */
 /*
  * Copyright (C) 2008 The Android Open Source Project
  *
@@ -460,59 +490,72 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE: /* 0x04 */
-/* File: armv6t2/OP_MOVE_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_WIDE.S */
     /* move-wide vA, vB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r2, rINST, #8, #4           @ r2<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[B]
+    and     r2, r2, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[A]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[B]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[A]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_FROM16: /* 0x05 */
-/* File: armv5te/OP_MOVE_WIDE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_FROM16.S */
     /* move-wide/from16 vAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 1)                        @ r3<- BBBB
     mov     r2, rINST, lsr #8           @ r2<- AA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_16: /* 0x06 */
-/* File: armv5te/OP_MOVE_WIDE_16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_16.S */
     /* move-wide/16 vAAAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 2)                        @ r3<- BBBB
     FETCH(r2, 1)                        @ r2<- AAAA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AAAA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AAAA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AAAA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AAAA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT: /* 0x07 */
-/* File: armv5te/OP_MOVE_OBJECT.S */
-/* File: armv5te/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
@@ -571,29 +629,43 @@ dalvik_inst:
     ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_WIDE: /* 0x0b */
-/* File: armv5te/OP_MOVE_RESULT_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_WIDE.S */
     /* move-result-wide vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
     ldmia   r3, {r0-r1}                 @ r0/r1<- retval.j
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+	ldr r3, [rGLUE, #offGlue_rtaint]
+	str	r0, [r2, #0]
+	str r3, [r2, #4]
+	str r1, [r2, #8]
+	str r3, [r2, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_OBJECT: /* 0x0c */
-/* File: armv5te/OP_MOVE_RESULT_OBJECT.S */
-/* File: armv5te/OP_MOVE_RESULT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT.S */
     /* for: move-result, move-result-object */
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -624,14 +706,16 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_VOID: /* 0x0e */
-/* File: armv5te/OP_RETURN_VOID.S */
+/* File: armv5te_taint/OP_RETURN_VOID.S */
+	SET_TAINT_CLEAR(r1)
+	str		r1, [rGLUE, #offGlue_rtaint]
     b       common_returnFromMethod
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN: /* 0x0f */
-/* File: armv5te/OP_RETURN.S */
+/* File: armv5te_taint/OP_RETURN.S */
     /*
      * Return a 32-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
@@ -740,39 +863,53 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_16: /* 0x16 */
-/* File: armv5te/OP_CONST_WIDE_16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_16.S */
     /* const-wide/16 vAA, #+BBBB */
     FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    mov     r2, r0, asr #31             @ r1<- ssssssss
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_32: /* 0x17 */
-/* File: armv5te/OP_CONST_WIDE_32.S */
+/* File: armv5te_taint/OP_CONST_WIDE_32.S */
     /* const-wide/32 vAA, #+BBBBbbbb */
     FETCH(r0, 1)                        @ r0<- 0000bbbb (low)
     mov     r3, rINST, lsr #8           @ r3<- AA
     FETCH_S(r2, 2)                      @ r2<- ssssBBBB (high)
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     orr     r0, r0, r2, lsl #16         @ r0<- BBBBbbbb
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r9<- &fp[AA]
+    mov     r2, r0, asr #31             @ r2<- ssssssss
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE: /* 0x18 */
-/* File: armv5te/OP_CONST_WIDE.S */
+/* File: armv5te_taint/OP_CONST_WIDE.S */
     /* const-wide vAA, #+HHHHhhhhBBBBbbbb */
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (low middle)
@@ -780,34 +917,50 @@ dalvik_inst:
     orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb (low word)
     FETCH(r3, 4)                        @ r3<- HHHH (high)
     mov     r9, rINST, lsr #8           @ r9<- AA
-    orr     r1, r2, r3, lsl #16         @ r1<- HHHHhhhh (high word)
+// begin WITH_TAINT_TRACKING
+    orr     r2, r2, r3, lsl #16         @ r2<- HHHHhhhh (high word)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_HIGH16: /* 0x19 */
-/* File: armv5te/OP_CONST_WIDE_HIGH16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_HIGH16.S */
     /* const-wide/high16 vAA, #+BBBB000000000000 */
     FETCH(r1, 1)                        @ r1<- 0000BBBB (zero-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
     mov     r0, #0                      @ r0<- 00000000
-    mov     r1, r1, lsl #16             @ r1<- BBBB0000
+// begin WITH_TAINT_TRACKING
+    mov     r2, r1, lsl #16             @ r1<- BBBB0000
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_STRING: /* 0x1a */
-/* File: armv5te/OP_CONST_STRING.S */
+/* File: armv5te_taint/OP_CONST_STRING.S */
     /* const/string vAA, String@BBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
@@ -2283,9 +2509,15 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     GET_VREG(r1, r2)                    @ r1<- vBB (array object)
     GET_VREG(r0, r3)                    @ r0<- vCC (requested index)
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_1
+// end WITH_TAINT_TRACKING
     cmp     r1, #0                      @ null array object?
     GET_VREG(r9, r9)                    @ r9<- vAA
     beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_2
+// end WITH_TAINT_TRACKING
     ldr     r3, [r1, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r10, r1, r0, lsl #2         @ r10<- arrayObj + index*width
     cmp     r0, r3                      @ compare unsigned index, length
@@ -2669,8 +2920,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT: /* 0x5b */
-/* File: armv5te/OP_IPUT_OBJECT.S */
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2829,6 +3080,11 @@ dalvik_inst:
 .LOP_SGET_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2848,20 +3104,14 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
     cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SGET_WIDE_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_finish:
-    mov     r1, rINST, lsr #8           @ r1<- AA
-    ldrd    r2, [r0, #offStaticField_value] @ r2/r3<- field value (aligned)
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[AA]
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    stmia   r1, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    b		.LOP_SGET_WIDE_finish
+
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_OBJECT: /* 0x62 */
-/* File: armv5te/OP_SGET_OBJECT.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_OBJECT.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2877,6 +3127,11 @@ dalvik_inst:
 .LOP_SGET_OBJECT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2903,6 +3158,11 @@ dalvik_inst:
 .LOP_SGET_BOOLEAN_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2929,6 +3189,11 @@ dalvik_inst:
 .LOP_SGET_BYTE_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2955,6 +3220,11 @@ dalvik_inst:
 .LOP_SGET_CHAR_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2981,6 +3251,11 @@ dalvik_inst:
 .LOP_SGET_SHORT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -3009,12 +3284,17 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_WIDE: /* 0x68 */
-/* File: armv5te/OP_SPUT_WIDE.S */
+/* File: armv5te_taint/OP_SPUT_WIDE.S */
     /*
      * 64-bit SPUT handler.
      */
@@ -3024,21 +3304,31 @@ dalvik_inst:
     ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
     mov     r9, rINST, lsr #8           @ r9<- AA
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SPUT_WIDE_resolve         @ yes, do resolve
 .LOP_SPUT_WIDE_finish: @ field ptr in r0, AA in r9
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr r1, [r9, #4]
+	ldr r2, [r9, #0]
+	ldr r3, [r9, #8]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strd    r2, [r0, #offStaticField_value] @ field<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+    str		r1, [r0, #offStaticField_taint]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_OBJECT: /* 0x69 */
-/* File: armv5te/OP_SPUT_OBJECT.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_OBJECT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3057,14 +3347,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BOOLEAN: /* 0x6a */
-/* File: armv5te/OP_SPUT_BOOLEAN.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3083,14 +3378,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BYTE: /* 0x6b */
-/* File: armv5te/OP_SPUT_BYTE.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BYTE.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3109,14 +3409,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_CHAR: /* 0x6c */
-/* File: armv5te/OP_SPUT_CHAR.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_CHAR.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3135,14 +3440,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_SHORT: /* 0x6d */
-/* File: armv5te/OP_SPUT_SHORT.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_SHORT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3161,162 +3471,79 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL: /* 0x6e */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER: /* 0x6f */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_resolve         @ do resolve now
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT: /* 0x70 */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodNoRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC: /* 0x71 */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodNoRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodNoRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE: /* 0x72 */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodNoRange @ jump to common handler 
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_73: /* 0x73 */
-/* File: armv5te/OP_UNUSED_73.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_73.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -3324,166 +3551,68 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_RANGE: /* 0x75 */
-/* File: armv5te/OP_INVOKE_SUPER_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_RANGE_resolve         @ do resolve now
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
-/* File: armv5te/OP_INVOKE_DIRECT_RANGE.S */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_RANGE_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_RANGE_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC_RANGE: /* 0x77 */
-/* File: armv5te/OP_INVOKE_STATIC_RANGE.S */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
-/* File: armv5te/OP_INVOKE_INTERFACE_RANGE.S */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodRange @ jump to common handler 
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_79: /* 0x79 */
-/* File: armv5te/OP_UNUSED_79.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_79.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -3562,26 +3701,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     rsbs    r0, r0, #0                           @ optional op; may set condition codes
     rsc     r1, r1, #0                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NEG_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NOT_LONG: /* 0x7e */
-/* File: armv6t2/OP_NOT_LONG.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NOT_LONG.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3590,26 +3732,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mvn     r0, r0                           @ optional op; may set condition codes
     mvn     r1, r1                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NOT_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_FLOAT: /* 0x7f */
-/* File: armv6t2/OP_NEG_FLOAT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NEG_FLOAT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3644,26 +3794,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     add     r1, r1, #0x80000000                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NEG_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_LONG: /* 0x81 */
-/* File: armv6t2/OP_INT_TO_LONG.S */
-/* File: armv6t2/unopWider.S */
+/* File: armv5te_taint/OP_INT_TO_LONG.S */
+/* File: armv5te_taint/unopWider.S */
     /*
      * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0", where
@@ -3796,26 +3982,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_l2d                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_LONG_TO_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_INT: /* 0x87 */
-/* File: arm-vfp/OP_FLOAT_TO_INT.S */
-/* File: arm-vfp/funop.S */
+/* File: arm-vfp_taint/OP_FLOAT_TO_INT.S */
+/* File: arm-vfp_taint/funop.S */
     /*
      * Generic 32-bit unary floating-point operation.  Provide an "instr"
      * line that specifies an instruction that performs "s1 = op s0".
@@ -3928,27 +4143,30 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      d2l_doconv                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_DOUBLE_TO_LONG_finish
 
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_FLOAT: /* 0x8c */
-/* File: arm-vfp/OP_DOUBLE_TO_FLOAT.S */
-/* File: arm-vfp/funopNarrower.S */
+/* File: arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S */
+/* File: arm-vfp_taint/funopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary floating point operation.  Provide an
      * "instr" line that specifies an instruction that performs "s0 = op d0".
@@ -5808,28 +6154,33 @@ dalvik_inst:
      * again we stuff it into rINST.
      */
     /* mul-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     rINST, rFP, r9, lsl #2      @ rINST<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
-    mul     ip, r2, r1                  @  ip<- ZxW
+// begin WITH_TAINT_TRACKING
+	bl		mul_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
     umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
     mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
     mov     r0, rINST                   @ r0<- &fp[A] (free up rINST)
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_LONG_2ADDR: /* 0xbe */
-/* File: armv6t2/OP_DIV_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_DIV_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -7141,8 +7672,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E3: /* 0xe3 */
-/* File: armv5te/OP_UNUSED_E3.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E3.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7150,8 +7681,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E4: /* 0xe4 */
-/* File: armv5te/OP_UNUSED_E4.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E4.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7159,8 +7690,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E5: /* 0xe5 */
-/* File: armv5te/OP_UNUSED_E5.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E5.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7168,8 +7699,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E6: /* 0xe6 */
-/* File: armv5te/OP_UNUSED_E6.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E6.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7177,8 +7708,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E7: /* 0xe7 */
-/* File: armv5te/OP_UNUSED_E7.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E7.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7186,8 +7717,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E8: /* 0xe8 */
-/* File: armv5te/OP_UNUSED_E8.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E8.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7195,8 +7726,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E9: /* 0xe9 */
-/* File: armv5te/OP_UNUSED_E9.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E9.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7204,8 +7735,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EA: /* 0xea */
-/* File: armv5te/OP_UNUSED_EA.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EA.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7213,8 +7744,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EB: /* 0xeb */
-/* File: armv5te/OP_UNUSED_EB.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EB.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7222,8 +7753,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EC: /* 0xec */
-/* File: armv5te/OP_UNUSED_EC.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EC.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7277,8 +7808,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EF: /* 0xef */
-/* File: armv5te/OP_UNUSED_EF.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EF.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7306,59 +7837,92 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_QUICK: /* 0xf2 */
-/* File: armv6t2/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE_QUICK: /* 0xf3 */
-/* File: armv6t2/OP_IGET_WIDE_QUICK.S */
+/* File: armv5te_taint/OP_IGET_WIDE_QUICK.S */
     /* iget-wide-quick vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
+// begin WITH_TAINT_TRACKING
+	add		r10, r1, #8
     ldrd    r0, [r3, r1]                @ r0<- obj.field (64 bits, aligned)
+    ldr		r10, [r3, r10]
+    orr		r10, r9, r10
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT_QUICK: /* 0xf4 */
-/* File: armv5te/OP_IGET_OBJECT_QUICK.S */
-/* File: armv5te/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
     FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
     mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_OBJECT_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
     and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -7404,8 +7982,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
-/* File: armv5te/OP_IPUT_OBJECT_QUICK.S */
-/* File: armv5te/OP_IPUT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_QUICK.S */
     /* For: iput-quick, iput-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
@@ -7416,8 +7994,16 @@ dalvik_inst:
     beq     common_errNullObject        @ object was null
     and     r2, r2, #15
     GET_VREG(r0, r2)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -7426,118 +8012,56 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodNoRange @ continue on
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK: /* 0xfa */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodNoRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodRange @ continue on
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FC: /* 0xfc */
-/* File: armv5te/OP_UNUSED_FC.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FC.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7545,8 +8069,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FD: /* 0xfd */
-/* File: armv5te/OP_UNUSED_FD.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FD.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7554,8 +8078,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FE: /* 0xfe */
-/* File: armv5te/OP_UNUSED_FE.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FE.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7858,6 +8417,9 @@ dvmAsmSisterStart:
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
     str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -7937,6 +8504,9 @@ dvmAsmSisterStart:
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
     str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -7992,24 +8567,50 @@ dvmAsmSisterStart:
 /* continuation for OP_CMPL_FLOAT */
 .LOP_CMPL_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPG_FLOAT */
 .LOP_CMPG_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPL_DOUBLE */
 .LOP_CMPL_DOUBLE_finish:
+    fmstat                              @ export status flags
+    movgt   r0, #1                      @ (greater than) r1<- 1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPG_DOUBLE */
 .LOP_CMPG_DOUBLE_finish:
+    fmstat                              @ export status flags
+    mvnmi   r0, #0                      @ (less than) r1<- -1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8031,28 +8637,174 @@ dvmAsmSisterStart:
 .LOP_CMP_LONG_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+cmp_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+	ldr		r2, [r3, #0]
+	ldr		r3, [r3, #8]
+	bx		lr
+
+/* continuation for OP_AGET */
+
+.LOP_AGET_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
 
 /* continuation for OP_AGET_WIDE */
 
 .LOP_AGET_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+    ldrd    r0, [r0, #offArrayObject_contents]  @ r0/r1<- vBB[vCC]
+    mov		r2, r1
+    mov		r1, r10
+    mov		r3, r10
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LOP_AGET_WIDE_taint_prop:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r10, r3, r10)
+	orr		r10, r10, r2					@ r10<- r10 | r1
+	bx		lr
+
+/* continuation for OP_AGET_OBJECT */
+
+.LOP_AGET_OBJECT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_OBJECT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BOOLEAN */
+
+.LOP_AGET_BOOLEAN_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BOOLEAN_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BYTE */
+
+.LOP_AGET_BYTE_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BYTE_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_CHAR */
+
+.LOP_AGET_CHAR_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_CHAR_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_SHORT */
 
+.LOP_AGET_SHORT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_SHORT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_APUT */
+
+.LOP_APUT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
 
 /* continuation for OP_APUT_WIDE */
 
 .LOP_APUT_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr		r2, [r9, #0]
+	ldr		r3, [r9, #8]
+	ldr		r1, [r9, #4]				@ r1<- array taint
+	ldr     r9, [r10, #offArrayObject_taint]
+	orr		r1, r1, r9					@ r1<- r1 | r9
+	str		r1, [r10, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
     strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8077,6 +8832,63 @@ dvmAsmSisterStart:
     str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+aput_object_taint_prop_1:
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r2, r9, r3)
+	bx		lr
+
+aput_object_taint_prop_2:
+	ldr     r3, [r1, #offArrayObject_taint]
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	bx		lr
+
+/* continuation for OP_APUT_BOOLEAN */
+
+.LOP_APUT_BOOLEAN_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_BYTE */
+
+.LOP_APUT_BYTE_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_CHAR */
+
+.LOP_APUT_CHAR_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_SHORT */
+
+.LOP_APUT_SHORT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
 
 /* continuation for OP_IGET */
 
@@ -8091,12 +8903,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
+    mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_WIDE */
 
@@ -8109,14 +8937,32 @@ dvmAsmSisterStart:
     cmp     r9, #0                      @ check object for null
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
+    mov     r2, rINST, lsr #8           @ r2<- A+
     ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    and     r2, r2, #15                 @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #8
+	ldr		r3, [r9, r3]
+	orr		r10, r3, r10
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+iget_wide_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_OBJECT */
 
@@ -8131,13 +8977,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_OBJECT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_BOOLEAN */
 
@@ -8152,13 +9013,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BOOLEAN_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_BYTE */
 
@@ -8173,13 +9049,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BYTE_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_CHAR */
 
@@ -8194,13 +9085,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_CHAR_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_SHORT */
 
@@ -8215,13 +9121,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_SHORT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IPUT */
 
@@ -8232,14 +9153,23 @@ dvmAsmSisterStart:
      */
 .LOP_IPUT_finish:
     @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    ubfx    r1, rINST, #8, #4           @ r1<- A
+    and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8251,15 +9181,27 @@ dvmAsmSisterStart:
      *  r9 holds object
      */
 .LOP_IPUT_WIDE_finish:
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    mov     r2, rINST, lsr #8           @ r2<- A+
     cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r10, [r2, #4]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8277,10 +9219,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8298,10 +9248,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8319,10 +9277,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8340,10 +9306,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8361,10 +9335,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8593,147 +9591,83 @@ dvmAsmSisterStart:
     b       common_exceptionThrown      @ no, handle exception
 
 
-/* continuation for OP_INVOKE_VIRTUAL */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-
-/* continuation for OP_INVOKE_SUPER */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-.LOP_INVOKE_SUPER_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-
-/* continuation for OP_INVOKE_DIRECT */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+/* continuation for OP_NEG_LONG */
 
-/* continuation for OP_INVOKE_VIRTUAL_RANGE */
+.LOP_NEG_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_RANGE_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
+/* continuation for OP_NOT_LONG */
 
+.LOP_NOT_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-/* continuation for OP_INVOKE_SUPER_RANGE */
+/* continuation for OP_NEG_DOUBLE */
 
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_RANGE_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
+.LOP_NEG_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-.LOP_INVOKE_SUPER_RANGE_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_INT_TO_LONG */
 
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_RANGE_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
+.LOP_INT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
 
+/* continuation for OP_LONG_TO_DOUBLE */
 
-/* continuation for OP_INVOKE_DIRECT_RANGE */
+.LOP_LONG_TO_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_RANGE_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_FLOAT_TO_LONG */
 
+.LOP_FLOAT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
 
 /* continuation for OP_FLOAT_TO_LONG */
 /*
@@ -8774,6 +9708,19 @@ f2l_doconv:
 
 
 /* continuation for OP_DOUBLE_TO_LONG */
+
+.LOP_DOUBLE_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
+
+/* continuation for OP_DOUBLE_TO_LONG */
 /*
  * Convert the double in r0/r1 to a long in r0/r1.
  *
@@ -8824,64 +9771,973 @@ d2l_doconv:
     ldmfd   sp!, {r4, r5, pc}
 
 
+/* continuation for OP_ADD_INT */
+
+.LOP_ADD_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SUB_INT */
+
+.LOP_SUB_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_MUL_INT */
+
+.LOP_MUL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_DIV_INT */
+
+.LOP_DIV_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_REM_INT */
+
+.LOP_REM_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_AND_INT */
+
+.LOP_AND_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_OR_INT */
+
+.LOP_OR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_XOR_INT */
+
+.LOP_XOR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHL_INT */
+
+.LOP_SHL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHR_INT */
+
+.LOP_SHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_USHR_INT */
+
+.LOP_USHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_LONG */
+
+.LOP_ADD_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG */
+
+.LOP_SUB_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
 /* continuation for OP_MUL_LONG */
 
 .LOP_MUL_LONG_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+mul_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	bx		lr
+
+/* continuation for OP_DIV_LONG */
+
+.LOP_DIV_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG */
+
+.LOP_REM_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG */
+
+.LOP_AND_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG */
+
+.LOP_OR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG */
+
+.LOP_XOR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_SHL_LONG */
 
 .LOP_SHL_LONG_finish:
     mov     r0, r0, asl r2              @  r0<- r0 << r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
 
 /* continuation for OP_SHR_LONG */
 
 .LOP_SHR_LONG_finish:
     mov     r1, r1, asr r2              @  r1<- r1 >> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
 
 /* continuation for OP_USHR_LONG */
 
 .LOP_USHR_LONG_finish:
     mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+ushr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r0<- r0 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
+
+/* continuation for OP_ADD_FLOAT */
+
+.LOP_ADD_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_SUB_FLOAT */
+
+.LOP_SUB_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_MUL_FLOAT */
+
+.LOP_MUL_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_DIV_FLOAT */
+
+.LOP_DIV_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_REM_FLOAT */
+
+.LOP_REM_FLOAT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE */
+
+.LOP_ADD_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    faddd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE */
+
+.LOP_SUB_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_DOUBLE */
+
+.LOP_MUL_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuld   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_DOUBLE */
+
+.LOP_DIV_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE */
+
+.LOP_REM_DOUBLE_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_ADD_INT_2ADDR */
+
+.LOP_ADD_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SUB_INT_2ADDR */
+
+.LOP_SUB_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_MUL_INT_2ADDR */
+
+.LOP_MUL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_DIV_INT_2ADDR */
+
+.LOP_DIV_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_REM_INT_2ADDR */
+
+.LOP_REM_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_AND_INT_2ADDR */
+
+.LOP_AND_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_OR_INT_2ADDR */
+
+.LOP_OR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_XOR_INT_2ADDR */
+
+.LOP_XOR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHL_INT_2ADDR */
+
+.LOP_SHL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHR_INT_2ADDR */
+
+.LOP_SHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_USHR_INT_2ADDR */
+
+.LOP_USHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_LONG_2ADDR */
+
+.LOP_ADD_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG_2ADDR */
+
+.LOP_SUB_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_MUL_LONG_2ADDR */
+
+mul_long_2addr_taint_prop:
+    and     r9, r9, #15
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     rINST, rFP, r9, lsl #3      @ rINST<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r9, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
+    ldr		r0, [rINST, #0]
+    ldr		r10, [rINST, #4]
+    ldr		r1, [rINST, #8]
+	orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	mul     ip, r2, r1                  @  ip<- ZxW
+	bx		lr
+
+/* continuation for OP_DIV_LONG_2ADDR */
+
+.LOP_DIV_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG_2ADDR */
+
+.LOP_REM_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG_2ADDR */
+
+.LOP_AND_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG_2ADDR */
+
+.LOP_OR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG_2ADDR */
+
+.LOP_XOR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_SHL_LONG_2ADDR */
 
 .LOP_SHL_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
 
 /* continuation for OP_SHR_LONG_2ADDR */
 
 .LOP_SHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+// OP_SHR_LONG_2ADDR.S
+shr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
 
 /* continuation for OP_USHR_LONG_2ADDR */
 
 .LOP_USHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
+
+/* continuation for OP_ADD_FLOAT_2ADDR */
+
+.LOP_ADD_FLOAT_2ADDR_finish:
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_FLOAT_2ADDR */
+
+.LOP_SUB_FLOAT_2ADDR_finish:
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_FLOAT_2ADDR */
+
+.LOP_MUL_FLOAT_2ADDR_finish:
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_FLOAT_2ADDR */
+
+.LOP_DIV_FLOAT_2ADDR_finish:
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_FLOAT_2ADDR */
+
+.LOP_REM_FLOAT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE_2ADDR */
+
+.LOP_ADD_DOUBLE_2ADDR_finish:
+    faddd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE_2ADDR */
+
+.LOP_SUB_DOUBLE_2ADDR_finish:
+    fsubd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_DOUBLE_2ADDR */
+
+.LOP_MUL_DOUBLE_2ADDR_finish:
+    fmuld   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_DIV_DOUBLE_2ADDR */
+
+.LOP_DIV_DOUBLE_2ADDR_finish:
+    fdivd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE_2ADDR */
+
+.LOP_REM_DOUBLE_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_EXECUTE_INLINE */
 
@@ -8919,11 +10777,52 @@ d2l_doconv:
     .word   gDvmInlineOpsTable
 
 
+/* continuation for OP_IGET_QUICK */
+
+.LOP_IGET_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IGET_WIDE_QUICK */
+
+iget_wide_quick_taint_prop:
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+	bx		lr
+
+/* continuation for OP_IGET_OBJECT_QUICK */
+
+.LOP_IGET_OBJECT_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IPUT_WIDE_QUICK */
+
+iput_wide_quick_taint_prop:
+    add     r3, rFP, r0, lsl #3         @ r3<- &fp[A]
+    cmp     r2, #0                      @ check object for null
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r9, [r3, #4]
+	bx		lr
+
     .size   dvmAsmSisterStart, .-dvmAsmSisterStart
     .global dvmAsmSisterEnd
 dvmAsmSisterEnd:
 
-/* File: armv5te/footer.S */
+/* File: armv5te_taint/footer.S */
 
 /*
  * ===========================================================================
