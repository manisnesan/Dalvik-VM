diff --git a/Android.mk b/Android.mk
index 32d5e34..235d192 100644
--- a/Android.mk
+++ b/Android.mk
@@ -28,8 +28,12 @@ subdirs := $(addprefix $(LOCAL_PATH)/,$(addsuffix /Android.mk, \
 		tools \
 	))
 
-include $(subdirs)
+# Taint propagation with file propagation
+ifeq ($(WITH_TAINT_TRACKING),true)
+    subdirs += $(LOCAL_PATH)/libattr/Android.mk
+endif
 
+include $(subdirs)
 
 .PHONY: dex dex-debug
 ifeq ($(DONT_INSTALL_DEX_FILES),true)
diff --git a/README_TAINTDROID.txt b/README_TAINTDROID.txt
new file mode 100644
index 0000000..2eff1ca
--- /dev/null
+++ b/README_TAINTDROID.txt
@@ -0,0 +1,34 @@
+The TaintDroid additions are ...
+
+ Copyright (c) 2010 The Pennsylvania State University
+ Systems and Internet Infrastructure Security Laboratory
+
+they were implemented by:
+
+ William Enck <enck@cse.psu.edu>
+
+The ARM assembly ("fast interpreter") implementation of the TaintDroid
+propagation rules was implemented by:
+
+ Peter Gilbert <gilbert@cs.duke.edu>
+
+Unless otherwise noted, all code additions are ...
+
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+
+Note that libattr was obtained from:
+
+ ftp://oss.sgi.com/projects/xfs/cmd_tars/attr_2.4.43-1.tar.gz
+
+and is licensed under GPLv2.
+
diff --git a/dexopt/Android.mk b/dexopt/Android.mk
index 8e30a2c..014d059 100644
--- a/dexopt/Android.mk
+++ b/dexopt/Android.mk
@@ -33,6 +33,14 @@ LOCAL_SHARED_LIBRARIES := \
 		libssl \
 		libdvm
 
+# Turn on Taint Tracking
+ifeq ($(WITH_TAINT_TRACKING),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_TRACKING
+endif
+ifeq ($(WITH_TAINT_ODEX),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_ODEX
+endif
+
 LOCAL_MODULE := dexopt
 
 include $(BUILD_EXECUTABLE)
diff --git a/dexopt/OptMain.c b/dexopt/OptMain.c
index 953db0b..177151e 100644
--- a/dexopt/OptMain.c
+++ b/dexopt/OptMain.c
@@ -124,7 +124,11 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
      * Prep the VM and perform the optimization.
      */
     DexClassVerifyMode verifyMode = VERIFY_MODE_ALL;
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    DexOptimizerMode dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     DexOptimizerMode dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
     int dexoptFlags = 0;        /* bit flags, from enum DexoptFlags */
     if (dexoptFlagStr[0] != '\0') {
         const char* opc;
@@ -140,6 +144,10 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
             }
         }
 
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+	/* No choices */
+	dexOptMode = OPTIMIZE_MODE_NONE;
+#else
         opc = strstr(dexoptFlagStr, "o=");      /* optimization */
         if (opc != NULL) {
             switch (*(opc+2)) {
@@ -149,6 +157,7 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
             default:                                            break;
             }
         }
+#endif
 
         opc = strstr(dexoptFlagStr, "m=y");     /* register map */
         if (opc != NULL) {
@@ -400,6 +409,10 @@ static int fromDex(int argc, char* const argv[])
     } else {
         verifyMode = VERIFY_MODE_NONE;
     }
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    /* no choices */
+    dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     if ((flags & DEXOPT_OPT_ENABLED) != 0) {
         if ((flags & DEXOPT_OPT_ALL) != 0)
             dexOptMode = OPTIMIZE_MODE_ALL;
@@ -408,6 +421,7 @@ static int fromDex(int argc, char* const argv[])
     } else {
         dexOptMode = OPTIMIZE_MODE_NONE;
     }
+#endif
     if ((flags & DEXOPT_GEN_REGISTER_MAP) != 0) {
         dexoptFlags |= DEXOPT_GEN_REGISTER_MAPS;
     }
diff --git a/libattr/Android.mk b/libattr/Android.mk
new file mode 100644
index 0000000..2a05aed
--- /dev/null
+++ b/libattr/Android.mk
@@ -0,0 +1,46 @@
+# Copyright (c) 2010 The Pennsylvania State University
+# Systems and Internet Infrastructure Security Laboratory
+#
+# Authors: William Enck <enck@cse.psu.edu>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+
+#
+# Android.mk for libattr
+#
+# This makefile builds libattr to allow XATTR support required for
+# file propagation in the TaintDroid project
+#
+
+LOCAL_PATH:= $(call my-dir)
+
+#
+# Build for the target (device).
+#
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES := \
+	attr_copy_action.c \
+	attr_copy_check.c \
+	attr_copy_fd.c \
+	attr_copy_file.c \
+	libattr.c \
+	syscalls.c
+
+LOCAL_C_INCLUDES := $(LOCAL_PATH)/attr
+
+LOCAL_MODULE := libattr
+
+include $(BUILD_STATIC_LIBRARY)
diff --git a/libattr/Makefile b/libattr/Makefile
new file mode 100644
index 0000000..b09efb1
--- /dev/null
+++ b/libattr/Makefile
@@ -0,0 +1,36 @@
+#
+# Copyright (c) 2000-2002 Silicon Graphics, Inc.  All Rights Reserved.
+#
+
+TOPDIR = ..
+
+LTLDFLAGS += -Wl,--version-script,$(TOPDIR)/exports
+include $(TOPDIR)/include/builddefs
+
+LTLIBRARY = libattr.la
+LT_CURRENT = 2
+LT_REVISION = 0
+LT_AGE = 1
+
+CFILES = libattr.c attr_copy_fd.c attr_copy_file.c attr_copy_check.c attr_copy_action.c
+HFILES = libattr.h
+
+ifeq ($(PKG_PLATFORM),linux)
+CFILES += syscalls.c
+else
+LSRCFILES = syscalls.c
+endif
+
+LCFLAGS = -include libattr.h
+
+default: $(LTLIBRARY)
+
+include $(BUILDRULES)
+
+install:
+
+install-lib: default
+	$(INSTALL_LTLIB)
+
+install-dev: default
+	$(INSTALL_LTLIB_DEV)
diff --git a/libattr/README.txt b/libattr/README.txt
new file mode 100644
index 0000000..90a1cf8
--- /dev/null
+++ b/libattr/README.txt
@@ -0,0 +1,3 @@
+This is libattr from attr-2.4.43
+
+ftp://oss.sgi.com/projects/xfs/cmd_tars/attr_2.4.43-1.tar.gz
diff --git a/libattr/attr/attributes.h b/libattr/attr/attributes.h
new file mode 100644
index 0000000..006114b
--- /dev/null
+++ b/libattr/attr/attributes.h
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2001-2002,2004 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef __ATTRIBUTES_H__
+#define	__ATTRIBUTES_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/*
+ *	An almost-IRIX-compatible extended attributes API
+ *	(the IRIX attribute "list" operation is missing, added ATTR_SECURE).
+ */
+
+/*
+ * The maximum size (into the kernel or returned from the kernel) of an
+ * attribute value or the buffer used for an attr_list() call.  Larger
+ * sizes will result in an E2BIG return code.
+ */
+#define ATTR_MAX_VALUELEN	(64*1024)	/* max length of a value */
+
+
+/*
+ * Flags that can be used with any of the simple attribute calls.
+ * All desired flags should be bit-wise OR'ed together.
+ */
+#define ATTR_DONTFOLLOW	0x0001	/* do not follow symlinks for a pathname */
+#define ATTR_ROOT	0x0002	/* use root namespace attributes in op */
+#define ATTR_TRUST	0x0004	/* tell server we can be trusted to properly
+				   handle extended attributes */
+#define ATTR_SECURE	0x0008	/* use security namespace attributes in op */
+
+/*
+ * Additional flags that can be used with the set() attribute call.
+ * All desired flags (from both lists) should be bit-wise OR'ed together.
+ */
+#define ATTR_CREATE	0x0010	/* pure create: fail if attr already exists */
+#define ATTR_REPLACE	0x0020	/* pure set: fail if attr does not exist */
+
+/*
+ * Define how lists of attribute names are returned to the user from
+ * the attr_list() call.  A large, 32bit aligned, buffer is passed in
+ * along with its size.  We put an array of offsets at the top that each
+ * reference an attrlist_ent_t and pack the attrlist_ent_t's at the bottom.
+ */
+typedef struct attrlist {
+	int32_t		al_count;	/* number of entries in attrlist */
+	int32_t		al_more;	/* T/F: more attrs (do call again) */
+	int32_t		al_offset[1];	/* byte offsets of attrs [var-sized] */
+} attrlist_t;
+
+/*
+ * Show the interesting info about one attribute.  This is what the
+ * al_offset[i] entry points to.
+ */
+typedef struct attrlist_ent {	/* data from attr_list() */
+	u_int32_t	a_valuelen;	/* number bytes in value of attr */
+	char		a_name[1];	/* attr name (NULL terminated) */
+} attrlist_ent_t;
+
+/*
+ * Given a pointer to the (char*) buffer containing the attr_list() result,
+ * and an index, return a pointer to the indicated attribute in the buffer.
+ */
+#define	ATTR_ENTRY(buffer, index)		\
+	((attrlist_ent_t *)			\
+	 &((char *)buffer)[ ((attrlist_t *)(buffer))->al_offset[index] ])
+
+/*
+ * Implement a "cursor" for use in successive attr_list() calls.
+ * It provides a way to find the last attribute that was returned in the
+ * last attr_list() call so that we can get the next one without missing
+ * any.  This should be bzero()ed before use and whenever it is desired to
+ * start over from the beginning of the attribute list.  The only valid
+ * operation on a cursor is to bzero() it.
+ */
+typedef struct attrlist_cursor {
+	u_int32_t	opaque[4];	/* an opaque cookie */
+} attrlist_cursor_t;
+
+/*
+ * Multi-attribute operation vector.
+ */
+typedef struct attr_multiop {
+	int32_t	am_opcode;	/* operation to perform (ATTR_OP_GET, etc.) */
+	int32_t	am_error;	/* [out arg] result of this sub-op (an errno) */
+	char	*am_attrname;	/* attribute name to work with */
+	char	*am_attrvalue;	/* [in/out arg] attribute value (raw bytes) */
+	int32_t	am_length;	/* [in/out arg] length of value */
+	int32_t	am_flags;	/* flags (bit-wise OR of #defines above) */
+} attr_multiop_t;
+#define	ATTR_MAX_MULTIOPS	128	/* max number ops in an oplist array */
+
+/*
+ * Valid values of am_opcode.
+ */
+#define ATTR_OP_GET	1	/* return the indicated attr's value */
+#define ATTR_OP_SET	2	/* set/create the indicated attr/value pair */
+#define ATTR_OP_REMOVE	3	/* remove the indicated attr */
+
+/*
+ * Get the value of an attribute.
+ * Valuelength must be set to the maximum size of the value buffer, it will
+ * be set to the actual number of bytes used in the value buffer upon return.
+ * The return value is -1 on error (w/errno set appropriately), 0 on success.
+ */
+extern int attr_get (const char *__path, const char *__attrname,
+			char *__attrvalue, int *__valuelength, int __flags);
+extern int attr_getf (int __fd, const char *__attrname, char *__attrvalue,
+			int *__valuelength, int __flags);
+
+/*
+ * Set the value of an attribute, creating the attribute if necessary.
+ * The return value is -1 on error (w/errno set appropriately), 0 on success.
+ */
+extern int attr_set (const char *__path, const char *__attrname,
+			const char *__attrvalue, const int __valuelength,
+			int __flags);
+extern int attr_setf (int __fd, const char *__attrname,
+			const char *__attrvalue, const int __valuelength,
+			int __flags);
+
+/*
+ * Remove an attribute.
+ * The return value is -1 on error (w/errno set appropriately), 0 on success.
+ */
+extern int attr_remove (const char *__path, const char *__attrname,
+			int __flags);
+extern int attr_removef (int __fd, const char *__attrname, int __flags);
+
+/*
+ * List the names and sizes of the values of all the attributes of an object.
+ * "Cursor" must be allocated and zeroed before the first call, it is used
+ * to maintain context between system calls if all the attribute names won't
+ * fit into the buffer on the first system call.
+ * The return value is -1 on error (w/errno set appropriately), 0 on success.
+ */
+int attr_list(const char *__path, char *__buffer, const int __buffersize,
+		int __flags, attrlist_cursor_t *__cursor);
+int attr_listf(int __fd, char *__buffer, const int __buffersize,
+		int __flags, attrlist_cursor_t *__cursor);
+
+/*
+ * Operate on multiple attributes of the same object simultaneously.
+ *
+ * This call will save on system call overhead when many attributes are
+ * going to be operated on.
+ *
+ * The return value is -1 on error (w/errno set appropriately), 0 on success.
+ * Note that this call will not return -1 as a result of failure of any
+ * of the sub-operations, their return value is stored in each element
+ * of the operation array.  This call will return -1 for a failure of the
+ * call as a whole, eg: if the pathname doesn't exist, or the fd is bad.
+ *
+ * The semantics and allowable values for the fields in a attr_multiop_t
+ * are the same as the semantics and allowable values for the arguments to
+ * the corresponding "simple" attribute interface.  For example: the args
+ * to a ATTR_OP_GET are the same as the args to an attr_get() call.
+ */
+extern int attr_multi (const char *__path, attr_multiop_t *__oplist,
+			int __count, int __flags);
+extern int attr_multif (int __fd, attr_multiop_t *__oplist,
+			int __count, int __flags);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif	/* __ATTRIBUTES_H__ */
diff --git a/libattr/attr/error_context.h b/libattr/attr/error_context.h
new file mode 100644
index 0000000..f3c54e9
--- /dev/null
+++ b/libattr/attr/error_context.h
@@ -0,0 +1,36 @@
+#ifndef __ERROR_CONTEXT_T
+#define __ERROR_CONTEXT_T
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct error_context {
+	/* Process an error message */
+	void (*error) (struct error_context *, const char *, ...);
+
+	/* Quote a file name for including in an error message */
+	const char *(*quote) (struct error_context *, const char *);
+
+	/* Free a quoted name */
+	void (*quote_free) (struct error_context *, const char *);
+};
+
+#ifdef ERROR_CONTEXT_MACROS
+# define error(ctx, args...) do { \
+	if ((ctx) && (ctx)->error) \
+		(ctx)->error((ctx), args); \
+	} while(0)
+# define quote(ctx, name) \
+	( ((ctx) && (ctx)->quote) ? (ctx)->quote((ctx), (name)) : (name) )
+# define quote_free(ctx, name) do { \
+	if ((ctx) && (ctx)->quote_free) \
+		(ctx)->quote_free((ctx), (name)); \
+	} while(0)
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __ERROR_CONTEXT_T */
diff --git a/libattr/attr/libattr.h b/libattr/attr/libattr.h
new file mode 100644
index 0000000..904b846
--- /dev/null
+++ b/libattr/attr/libattr.h
@@ -0,0 +1,29 @@
+#ifndef __LIBATTR_H
+#define __LIBATTR_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+struct error_context;
+
+extern int attr_copy_file (const char *, const char *,
+			   int (*) (const char *, struct error_context *),
+			   struct error_context *);
+extern int attr_copy_fd (const char *, int, const char *, int,
+			 int (*) (const char *, struct error_context *),
+			 struct error_context *);
+
+/* Keep this function for backwards compatibility. */
+extern int attr_copy_check_permissions(const char *, struct error_context *);
+
+#define ATTR_ACTION_SKIP	1
+#define ATTR_ACTION_PERMISSIONS	2
+
+extern int attr_copy_action(const char *, struct error_context *);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
diff --git a/libattr/attr/xattr.h b/libattr/attr/xattr.h
new file mode 100644
index 0000000..05491e7
--- /dev/null
+++ b/libattr/attr/xattr.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2001-2002 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public License
+ * as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+#ifndef __XATTR_H__
+#define __XATTR_H__
+
+#include <features.h>
+
+#include <errno.h>
+#ifndef ENOATTR
+# define ENOATTR ENODATA        /* No such attribute */
+#endif
+
+#define XATTR_CREATE  0x1       /* set value, fail if attr already exists */
+#define XATTR_REPLACE 0x2       /* set value, fail if attr does not exist */
+
+
+__BEGIN_DECLS
+
+extern int setxattr (const char *__path, const char *__name,
+		      const void *__value, size_t __size, int __flags);
+extern int lsetxattr (const char *__path, const char *__name,
+		      const void *__value, size_t __size, int __flags);
+extern int fsetxattr (int __filedes, const char *__name,
+		      const void *__value, size_t __size, int __flags);
+
+extern ssize_t getxattr (const char *__path, const char *__name,
+				void *__value, size_t __size);
+extern ssize_t lgetxattr (const char *__path, const char *__name,
+				void *__value, size_t __size);
+extern ssize_t fgetxattr (int __filedes, const char *__name,
+				void *__value, size_t __size);
+
+extern ssize_t listxattr (const char *__path, char *__list,
+				size_t __size);
+extern ssize_t llistxattr (const char *__path, char *__list,
+				size_t __size);
+extern ssize_t flistxattr (int __filedes, char *__list,
+				size_t __size);
+
+extern int removexattr (const char *__path, const char *__name);
+extern int lremovexattr (const char *__path, const char *__name);
+extern int fremovexattr (int __filedes,   const char *__name);
+
+__END_DECLS
+
+#endif	/* __XATTR_H__ */
diff --git a/libattr/attr_copy_action.c b/libattr/attr_copy_action.c
new file mode 100644
index 0000000..296057a
--- /dev/null
+++ b/libattr/attr_copy_action.c
@@ -0,0 +1,163 @@
+/* Copyright (C) 2006 Andreas Gruenbacher <agruen@xxxxxxx>, SuSE Linux AG.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#include <alloca.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+#include <stdarg.h>
+#include <fnmatch.h>
+
+#include "attr/libattr.h"
+#define ERROR_CONTEXT_MACROS
+#include "error_context.h"
+
+#define ATTR_CONF "/etc/xattr.conf"
+
+struct attr_action {
+	struct attr_action *next;
+	char *pattern;
+	int action;
+};
+
+static struct attr_action *attr_actions;
+
+static void
+free_attr_actions(void)
+{
+	struct attr_action *tmp;
+
+	while (attr_actions) {
+		tmp = attr_actions->next;
+		free(attr_actions->pattern);
+		free(attr_actions);
+		attr_actions = tmp;
+	}
+}
+
+static int
+attr_parse_attr_conf(struct error_context *ctx)
+{
+	char *text, *t;
+	size_t size_guess = 4096, len;
+	FILE *file;
+	char *pattern = NULL;
+	struct attr_action *new;
+	int action;
+
+	if (attr_actions)
+		return 0;
+
+repeat:
+	text = malloc(size_guess + 1);
+	if (!text)
+		goto fail;
+
+	if ((file = fopen(ATTR_CONF, "r")) == NULL) {
+		if (errno == ENOENT)
+			return 0;
+		goto fail;
+	}
+	len = fread(text, 1, size_guess, file);
+	if (ferror(file))
+		goto fail;
+	if (!feof(file)) {
+		fclose(file);
+		file = NULL;
+		free(text);
+		size_guess *= 2;
+		goto repeat;
+	}
+	fclose(file);
+	file = NULL;
+
+	text[len] = 0;
+	t = text;
+	for (;;) {
+		t += strspn(t, " \t\n");
+		len = strcspn(t, " \t\n#");
+		if (t[len] == '#') {
+			if (len)
+				goto parse_error;
+			t += strcspn(t, "\n");
+			continue;
+		} else if (t[len] == 0)
+			break;
+		else if (t[len] == '\n')
+			goto parse_error;
+		pattern = strndup(t, len);
+		if (!pattern)
+			goto fail;
+		t += len;
+
+		t += strspn(t, " \t");
+		len = strcspn(t, " \t\n#");
+		if (len == 4 && !strncmp(t, "skip", 4))
+			action = ATTR_ACTION_SKIP;
+		else if (len == 11 && !strncmp(t, "permissions", 11))
+			action = ATTR_ACTION_PERMISSIONS;
+		else
+			goto parse_error;
+		t += len;
+		t += strspn(t, " \t");
+		if (*t != '#' && *t != '\n')
+			goto parse_error;
+
+		new = malloc(sizeof(struct attr_action));
+		if (!new)
+			goto parse_error;
+		new->next = attr_actions;
+		new->pattern = pattern;
+		new->action = action;
+		attr_actions = new;
+
+		t += strcspn(t, "\n");
+	}
+	return 0;
+
+parse_error:
+	errno = EINVAL;
+
+fail:
+	{
+		const char *q = quote (ctx, ATTR_CONF);
+		error (ctx, "%s", q);
+		quote_free (ctx, q);
+	}
+
+	free(pattern);
+	if (file)
+		fclose(file);
+	free(text);
+	free_attr_actions();
+	return -1;
+}
+
+int
+attr_copy_action(const char *name, struct error_context *ctx)
+{
+	struct attr_action *action = attr_actions;
+
+	if (!attr_parse_attr_conf(ctx)) {
+		for (action = attr_actions; action; action = action->next) {
+			if (!fnmatch(action->pattern, name, 0))
+				return action->action;
+		}
+	}
+	return 0;
+}
diff --git a/libattr/attr_copy_check.c b/libattr/attr_copy_check.c
new file mode 100644
index 0000000..e8a058e
--- /dev/null
+++ b/libattr/attr_copy_check.c
@@ -0,0 +1,29 @@
+/* Copy extended attributes between files - default check callback */
+
+/* Copyright (C) 2003 Andreas Gruenbacher <agruen@suse.de>, SuSE Linux AG.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#include <string.h>
+#include "error_context.h"
+#include "attr/libattr.h"
+
+int
+attr_copy_check_permissions(const char *name, struct error_context *ctx)
+{
+	return attr_copy_action(name, ctx) == 0;
+}
+
diff --git a/libattr/attr_copy_fd.c b/libattr/attr_copy_fd.c
new file mode 100644
index 0000000..67a7043
--- /dev/null
+++ b/libattr/attr_copy_fd.c
@@ -0,0 +1,178 @@
+/* Copy extended attributes between files. */
+ 
+/* Copyright (C) 2002 Andreas Gruenbacher <agruen@suse.de>, SuSE Linux AG.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#if defined (HAVE_CONFIG_H)
+#include "config.h"
+#endif
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#if defined(HAVE_ALLOCA_H)
+# include <alloca.h>
+#endif
+
+#if defined(HAVE_ATTR_XATTR_H)
+# include <attr/xattr.h>
+#endif
+
+#if defined(HAVE_ATTR_LIBATTR_H)
+# include "attr/libattr.h"
+#endif
+
+#define ERROR_CONTEXT_MACROS
+#include "error_context.h"
+
+#if !defined(ENOTSUP)
+# define ENOTSUP (-1)
+#endif
+
+#if defined(HAVE_ALLOCA)
+# define my_alloc(size) alloca (size)
+# define my_free(ptr) do { } while(0)
+#else
+# define my_alloc(size) malloc (size)
+# define my_free(ptr) free (ptr)
+#endif
+
+/* Copy extended attributes from src_path to dst_path. If the file
+   has an extended Access ACL (system.posix_acl_access) and that is
+   copied successfully, the file mode permission bits are copied as
+   a side effect. This may not always the case, so the file mode
+   and/or ownership must be copied separately. */
+int
+attr_copy_fd(const char *src_path, int src_fd,
+	     const char *dst_path, int dst_fd,
+	     int (*check) (const char *, struct error_context *),
+	     struct error_context *ctx)
+{
+#if defined(HAVE_FLISTXATTR) && defined(HAVE_FGETXATTR) && \
+    defined(HAVE_FSETXATTR)
+	int ret = 0;
+	ssize_t size;
+	char *names = NULL, *end_names, *name, *value = NULL;
+	unsigned int setxattr_ENOTSUP = 0;
+
+	/* ignore acls by default */
+	if (check == NULL)
+		check = attr_copy_check_permissions;
+
+	size = flistxattr (src_fd, NULL, 0);
+	if (size < 0) {
+		if (errno != ENOSYS && errno != ENOTSUP) {
+			const char *qpath = quote (ctx, src_path);
+			error (ctx, _("listing attributes of %s"), qpath);
+			quote_free (ctx, qpath);
+			ret = -1;
+		}
+		goto getout;
+	}
+	names = (char *) my_alloc (size+1);
+	if (names == NULL) {
+		error (ctx, "");
+		ret = -1;
+		goto getout;
+	}
+	size = flistxattr (src_fd, names, size);
+	if (size < 0) {
+		const char *qpath = quote (ctx, src_path);
+		error (ctx, _("listing attributes of %s"), qpath);
+		quote_free (ctx, qpath);
+		ret = -1;
+		goto getout;
+	} else {
+		names[size] = '\0';
+		end_names = names + size;
+	}
+
+	for (name = names; name != end_names; name = strchr(name, '\0') + 1) {
+		void *old_value;
+
+		/* check if this attribute shall be preserved */
+		if (!*name || !check(name, ctx))
+			continue;
+
+		size = fgetxattr (src_fd, name, NULL, 0);
+		if (size < 0) {
+			const char *qpath = quote (ctx, src_path);
+			const char *qname = quote (ctx, name);
+			error (ctx, _("getting attribute %s of %s"),
+			       qpath, qname);
+			quote_free (ctx, qname);
+			quote_free (ctx, qpath);
+			ret = -1;
+			continue;
+		}
+		value = (char *) realloc (old_value = value, size);
+		if (size != 0 && value == NULL) {
+			free(old_value);
+			error (ctx, "");
+			ret = -1;
+		}
+		size = fgetxattr (src_fd, name, value, size);
+		if (size < 0) {
+			const char *qpath = quote (ctx, src_path);
+			const char *qname = quote (ctx, name);
+			error (ctx, _("getting attribute %s of %s"),
+			       qname, qpath);
+			quote_free (ctx, qname);
+			quote_free (ctx, qpath);
+			ret = -1;
+			continue;
+		}
+		if (fsetxattr (dst_fd, name, value, size, 0) != 0) {
+			if (errno == ENOTSUP)
+				setxattr_ENOTSUP++;
+			else {
+				const char *qpath = quote (ctx, dst_path);
+
+				if (errno == ENOSYS) {
+					error (ctx, _("setting attributes for "
+					       "%s"), qpath);
+					ret = -1;
+					break;  /* no hope of getting any further */
+				} else {
+					const char *qname = quote (ctx, name);
+					error (ctx, _("setting attribute %s for %s"),
+					       qname, qpath);
+					quote_free (ctx, qname);
+					ret = -1;
+				}
+				quote_free (ctx, qpath);
+			}
+		}
+	}
+	if (setxattr_ENOTSUP) {
+		const char *qpath = quote (ctx, dst_path);
+		errno = ENOTSUP;
+		error (ctx, _("setting attributes for %s"), qpath);
+		ret = -1;
+		quote_free (ctx, qpath);
+	}
+getout:
+	free (value);
+	my_free (names);
+	return ret;
+#else
+	return 0;
+#endif
+}
+
diff --git a/libattr/attr_copy_file.c b/libattr/attr_copy_file.c
new file mode 100644
index 0000000..cd10b31
--- /dev/null
+++ b/libattr/attr_copy_file.c
@@ -0,0 +1,176 @@
+/* Copy extended attributes between files. */
+ 
+/* Copyright (C) 2002 Andreas Gruenbacher <agruen@suse.de>, SuSE Linux AG.
+
+  This program is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Lesser General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Lesser General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with this library; if not, write to the Free Software
+  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+*/
+
+#if defined (HAVE_CONFIG_H)
+#include "config.h"
+#endif
+
+#include <sys/types.h>
+#include <stdlib.h>
+#include <string.h>
+#include <errno.h>
+
+#if defined(HAVE_ALLOCA_H)
+# include <alloca.h>
+#endif
+
+#if defined(HAVE_ATTR_XATTR_H)
+# include <attr/xattr.h>
+#endif
+
+#if defined(HAVE_ATTR_LIBATTR_H)
+# include "attr/libattr.h"
+#endif
+
+#define ERROR_CONTEXT_MACROS
+#include "error_context.h"
+
+#if !defined(ENOTSUP)
+# define ENOTSUP (-1)
+#endif
+
+#if defined(HAVE_ALLOCA)
+# define my_alloc(size) alloca (size)
+# define my_free(ptr) do { } while(0)
+#else
+# define my_alloc(size) malloc (size)
+# define my_free(ptr) free (ptr)
+#endif
+
+/* Copy extended attributes from src_path to dst_path. If the file
+   has an extended Access ACL (system.posix_acl_access) and that is
+   copied successfully, the file mode permission bits are copied as
+   a side effect. This may not always the case, so the file mode
+   and/or ownership must be copied separately. */
+int
+attr_copy_file(const char *src_path, const char *dst_path,
+	       int (*check) (const char *, struct error_context *),
+	       struct error_context *ctx)
+{
+#if defined(HAVE_LISTXATTR) && defined(HAVE_GETXATTR) && defined(HAVE_SETXATTR)
+  	int ret = 0;
+	ssize_t size;
+	char *names = NULL, *end_names, *name, *value = NULL;
+	unsigned int setxattr_ENOTSUP = 0;
+
+	/* ignore acls by default */
+	if (check == NULL)
+		check = attr_copy_check_permissions;
+
+	size = llistxattr (src_path, NULL, 0);
+	if (size < 0) {
+		if (errno != ENOSYS && errno != ENOTSUP) {
+			const char *qpath = quote (ctx, src_path);
+			error (ctx, _("listing attributes of %s"), qpath);
+			quote_free (ctx, qpath);
+			ret = -1;
+		}
+		goto getout;
+	}
+	names = (char *) my_alloc (size+1);
+	if (names == NULL) {
+		error (ctx, "");
+		ret = -1;
+		goto getout;
+	}
+	size = llistxattr (src_path, names, size);
+	if (size < 0) {
+		const char *qpath = quote (ctx, src_path);
+		error (ctx, _("listing attributes of %s"), qpath);
+		quote_free (ctx, qpath);
+		ret = -1;
+		goto getout;
+	} else {
+		names[size] = '\0';
+		end_names = names + size;
+	}
+
+	for (name = names; name != end_names; name = strchr(name, '\0') + 1) {
+		void *old_value;
+
+		/* check if this attribute shall be preserved */
+		if (!*name || !check(name, ctx))
+			continue;
+
+		size = lgetxattr (src_path, name, NULL, 0);
+		if (size < 0) {
+			const char *qpath = quote (ctx, src_path);
+			const char *qname = quote (ctx, name);
+			error (ctx, _("getting attribute %s of %s"),
+			       qname, qpath);
+			quote_free (ctx, qname);
+			quote_free (ctx, qpath);
+			ret = -1;
+			continue;
+		}
+		value = (char *) realloc (old_value = value, size);
+		if (size != 0 && value == NULL) {
+			free(old_value);
+			error (ctx, "");
+			ret = -1;
+		}
+		size = lgetxattr (src_path, name, value, size);
+		if (size < 0) {
+			const char *qpath = quote (ctx, src_path);
+			const char *qname = quote (ctx, name);
+			error (ctx, _("getting attribute %s of %s"),
+			       qname, qpath);
+			quote_free (ctx, qname);
+			quote_free (ctx, qpath);
+			ret = -1;
+			continue;
+		}
+		if (lsetxattr (dst_path, name, value, size, 0) != 0) {
+			if (errno == ENOTSUP)
+				setxattr_ENOTSUP++;
+			else {
+				const char *qpath = quote (ctx, dst_path);
+				if (errno == ENOSYS) {
+					error (ctx, _("setting attributes for "
+					       "%s"), qpath);
+					ret = -1;
+					/* no hope of getting any further */
+					break;
+				} else {
+					const char *qname = quote (ctx, name);
+					error (ctx, _("setting attribute %s for "
+					       "%s"), qname, qpath);
+					quote_free (ctx, qname);
+					ret = -1;
+				}
+				quote_free (ctx, qpath);
+			}
+		}
+	}
+	if (setxattr_ENOTSUP) {
+		const char *qpath = quote (ctx, dst_path);
+		errno = ENOTSUP;
+		error (ctx, _("setting attributes for %s"), qpath);
+		ret = -1;
+		quote_free (ctx, qpath);
+	}
+getout:
+	free (value);
+	my_free (names);
+	return ret;
+#else
+	return 0;
+#endif
+}
+
diff --git a/libattr/libattr.c b/libattr/libattr.c
new file mode 100644
index 0000000..a77dd84
--- /dev/null
+++ b/libattr/libattr.c
@@ -0,0 +1,434 @@
+/*
+ * Copyright (c) 2001-2003,2005 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+#include <errno.h>
+#include <stdlib.h>
+#include <string.h>
+#include <unistd.h>
+#include <sys/types.h>
+
+#include <attr/xattr.h>
+#include <attr/attributes.h>
+
+#undef MAXNAMELEN
+#define MAXNAMELEN 256
+#undef MAXLISTLEN
+#define MAXLISTLEN 65536
+
+#undef roundup
+#define roundup(x,y) ((((x)+((y)-1))/(y))*(y))
+
+static const char *user_name = "user.";
+static const char *secure_name = "security.";
+static const char *trusted_name = "trusted.";
+static const char *xfsroot_name = "xfsroot.";
+
+/*
+ * Convert IRIX API components into Linux/XFS API components,
+ * and vice-versa.
+ */
+static int
+api_convert(char *name, const char *irixname, int irixflags, int compat)
+{
+	if (strlen(irixname) >= MAXNAMELEN) {
+		errno = EINVAL;
+		return -1;
+	}
+	if (irixflags & ATTR_ROOT) {
+		if (compat)
+			strcpy(name, xfsroot_name);
+		else
+			strcpy(name, trusted_name);
+	} else if (irixflags & ATTR_SECURE) {
+		strcpy(name, secure_name);
+	} else {
+		strcpy(name, user_name);
+	}
+	strcat(name, irixname);
+	return 0;
+}
+
+static int
+api_unconvert(char *name, const char *linuxname, int irixflags)
+{
+	int type, length;
+
+	length = strlen(user_name);
+	if (strncmp(linuxname, user_name, length) == 0) {
+		type = 0; /*ATTR_USER*/
+		goto found;
+	}
+	length = strlen(secure_name);
+	if (strncmp(linuxname, secure_name, length) == 0) {
+		type = ATTR_SECURE;
+		goto found;
+	}
+	length = strlen(trusted_name);
+	if (strncmp(linuxname, trusted_name, length) == 0) {
+		type = ATTR_ROOT;
+		goto found;
+	}
+	length = strlen(xfsroot_name);
+	if (strncmp(linuxname, xfsroot_name, length) == 0) {
+		type = ATTR_ROOT;
+		goto found;
+	}
+	return 1;
+
+found:
+	if ((irixflags & ATTR_SECURE) != 0 && (type != ATTR_SECURE))
+		return 1;
+	if ((irixflags & ATTR_ROOT) != 0 && (type != ATTR_ROOT))
+		return 1;
+	strcpy(name, linuxname + length);
+	return 0;
+}
+
+
+int
+attr_get(const char *path, const char *attrname, char *attrvalue,
+	 int *valuelength, int flags)
+{
+	int c, compat;
+	char name[MAXNAMELEN+16];
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		if (flags & ATTR_DONTFOLLOW)
+			c = lgetxattr(path, name, attrvalue, *valuelength);
+		else
+			c =  getxattr(path, name, attrvalue, *valuelength);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	if (c < 0)
+		return c;
+	*valuelength = c;
+	return 0;
+}
+
+int
+attr_getf(int fd, const char *attrname, char *attrvalue,
+	  int *valuelength, int flags)
+{
+	int c, compat;
+	char name[MAXNAMELEN+16];
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		c = fgetxattr(fd, name, attrvalue, *valuelength);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	if (c < 0)
+		return c;
+	*valuelength = c;
+	return 0;
+}
+
+int
+attr_set(const char *path, const char *attrname, const char *attrvalue,
+	 const int valuelength, int flags)
+{
+	int c, compat, lflags = 0;
+	char name[MAXNAMELEN+16];
+	void *buffer = (void *)attrvalue;
+
+	if (flags & ATTR_CREATE)
+		lflags = XATTR_CREATE;
+	else if (flags & ATTR_REPLACE)
+		lflags = XATTR_REPLACE;
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		if (flags & ATTR_DONTFOLLOW)
+			c = lsetxattr(path, name, buffer, valuelength, lflags);
+		else
+			c = setxattr(path, name, buffer, valuelength, lflags);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	return c;
+}
+
+int
+attr_setf(int fd, const char *attrname,
+	  const char *attrvalue, const int valuelength, int flags)
+{
+	int c, compat, lflags = 0;
+	char name[MAXNAMELEN+16];
+	void *buffer = (void *)attrvalue;
+
+	if (flags & ATTR_CREATE)
+		lflags = XATTR_CREATE;
+	else if (flags & ATTR_REPLACE)
+		lflags = XATTR_REPLACE;
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		c = fsetxattr(fd, name, buffer, valuelength, lflags);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	return c;
+}
+
+int
+attr_remove(const char *path, const char *attrname, int flags)
+{
+	int c, compat;
+	char name[MAXNAMELEN+16];
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		if (flags & ATTR_DONTFOLLOW)
+			c = lremovexattr(path, name);
+		else
+			c = removexattr(path, name);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	return c;
+}
+
+int
+attr_removef(int fd, const char *attrname, int flags)
+{
+	int c, compat;
+	char name[MAXNAMELEN+16];
+
+	for (compat = 0; compat < 2; compat++) {
+		if ((c = api_convert(name, attrname, flags, compat)) < 0)
+			return c;
+		c = fremovexattr(fd, name);
+		if (c < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		break;
+	}
+	return c;
+}
+
+
+/*
+ * Helper routine for attr_list functions.
+ */
+
+static int
+attr_list_pack(const char *name, const int valuelen,
+		char *buffer, const int buffersize,
+		int *start_offset, int *end_offset)
+{
+	attrlist_ent_t *aentp;
+	attrlist_t *alist = (attrlist_t *)buffer;
+	int size = roundup(strlen(name) + 1 + sizeof(aentp->a_valuelen), 8);
+
+	if ((*end_offset - size) < (*start_offset + sizeof(alist->al_count))) {
+		alist->al_more = 1;
+		return 1;
+	}
+
+	*end_offset -= size;
+	aentp = (attrlist_ent_t *)&buffer[ *end_offset ];
+	aentp->a_valuelen = valuelen;
+	strncpy(aentp->a_name, name, size - sizeof(aentp->a_valuelen));
+
+	*start_offset += sizeof(alist->al_offset);
+	alist->al_offset[alist->al_count] = *end_offset;
+	alist->al_count++;
+	return 0;
+}
+
+int
+attr_list(const char *path, char *buffer, const int buffersize, int flags,
+	  attrlist_cursor_t *cursor)
+{
+	const char *l;
+	int length, vlength, count = 0;
+	char lbuf[MAXLISTLEN];
+	char name[MAXNAMELEN+16];
+	int start_offset, end_offset;
+
+	if (buffersize < sizeof(attrlist_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	bzero(buffer, sizeof(attrlist_t));
+
+	if (flags & ATTR_DONTFOLLOW)
+		length = llistxattr(path, lbuf, sizeof(lbuf));
+	else
+		length = listxattr(path, lbuf, sizeof(lbuf));
+	if (length <= 0)
+		return length;
+
+	start_offset = sizeof(attrlist_t);
+	end_offset = buffersize & ~(8-1);	/* 8 byte align */
+
+	for (l = lbuf; l != lbuf + length; l = strchr(l, '\0') + 1) {
+		if (api_unconvert(name, l, flags))
+			continue;
+		if (flags & ATTR_DONTFOLLOW)
+			vlength = lgetxattr(path, l, NULL, 0);
+		else
+			vlength =  getxattr(path, l, NULL, 0);
+		if (vlength < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		if (count++ < cursor->opaque[0])
+			continue;
+		if (attr_list_pack(name, vlength, buffer, buffersize,
+				   &start_offset, &end_offset)) {
+			cursor->opaque[0] = count;
+			break;
+		}
+	}
+	return 0;
+}
+
+int
+attr_listf(int fd, char *buffer, const int buffersize, int flags,
+	   attrlist_cursor_t *cursor)
+{
+	const char *l;
+	int length, vlength, count = 0;
+	char lbuf[MAXLISTLEN];
+	char name[MAXNAMELEN+16];
+	int start_offset, end_offset;
+
+	if (buffersize < sizeof(attrlist_t)) {
+		errno = EINVAL;
+		return -1;
+	}
+	bzero(buffer, sizeof(attrlist_t));
+
+	length = flistxattr(fd, lbuf, sizeof(lbuf));
+	if (length < 0)
+		return length;
+
+	start_offset = sizeof(attrlist_t);
+	end_offset = buffersize & ~(8-1);	/* 8 byte align */
+
+	for (l = lbuf; l != lbuf + length; l = strchr(l, '\0') + 1) {
+		if (api_unconvert(name, l, flags))
+			continue;
+		vlength = fgetxattr(fd, l, NULL, 0);
+		if (vlength < 0 && (errno == ENOATTR || errno == ENOTSUP))
+			continue;
+		if (count++ < cursor->opaque[0])
+			continue;
+		if (attr_list_pack(name, vlength, buffer, buffersize,
+				   &start_offset, &end_offset)) {
+			cursor->opaque[0] = count;
+			break;
+		}
+	}
+	return 0;
+}
+
+
+/*
+ * Helper routines for the attr_multi functions.  In IRIX, the
+ * multi routines are a single syscall - in Linux, we break em
+ * apart in userspace and make individual syscalls for each.
+ */
+
+static int
+attr_single(const char *path, attr_multiop_t *op, int flags)
+{
+	int r = -1;
+
+	errno = -EINVAL;
+	flags |= op->am_flags;
+	if (op->am_opcode & ATTR_OP_GET)
+		r = attr_get(path, op->am_attrname, op->am_attrvalue,
+				&op->am_length, flags);
+	else if (op->am_opcode & ATTR_OP_SET)
+		r = attr_set(path, op->am_attrname, op->am_attrvalue,
+				op->am_length, flags);
+	else if (op->am_opcode & ATTR_OP_REMOVE)
+		r = attr_remove(path, op->am_attrname, flags);
+	return r;
+}
+
+static int
+attr_singlef(const int fd, attr_multiop_t *op, int flags)
+{
+	int r = -1;
+
+	errno = -EINVAL;
+	flags |= op->am_flags;
+	if (op->am_opcode & ATTR_OP_GET)
+		r = attr_getf(fd, op->am_attrname, op->am_attrvalue,
+				&op->am_length, flags);
+	else if (op->am_opcode & ATTR_OP_SET)
+		r = attr_setf(fd, op->am_attrname, op->am_attrvalue,
+				op->am_length, flags);
+	else if (op->am_opcode & ATTR_OP_REMOVE)
+		r = attr_removef(fd, op->am_attrname, flags);
+	return r;
+}
+
+/*
+ * Operate on multiple attributes of the same object simultaneously
+ *
+ * From the manpage: "attr_multi will fail if ... a bit other than
+ * ATTR_DONTFOLLOW was set in the flag argument." flags must be
+ * checked here as they are not passed into the kernel.
+ */
+int
+attr_multi(const char *path, attr_multiop_t *multiops, int count, int flags)
+{
+	int i, tmp, r = -1;
+
+	errno = EINVAL;
+	if ((flags & ATTR_DONTFOLLOW) != flags)
+		return r;
+
+	r = errno = 0;
+	for (i = 0; i < count; i++) {
+		tmp = attr_single(path, &multiops[i], flags);
+		if (tmp) r = tmp;
+	}
+	return r;
+}
+
+int
+attr_multif(int fd, attr_multiop_t *multiops, int count, int flags)
+{
+	int i, tmp, r = -1;
+
+	errno = EINVAL;
+	if ((flags & ATTR_DONTFOLLOW) != flags)
+		return r;
+
+	r = errno = 0;
+	for (i = 0; i < count; i++) {
+		tmp = attr_singlef(fd, &multiops[i], flags);
+		if (tmp) r = tmp;
+	}
+	return r;
+}
diff --git a/libattr/libattr.h b/libattr/libattr.h
new file mode 100644
index 0000000..8973b00
--- /dev/null
+++ b/libattr/libattr.h
@@ -0,0 +1,12 @@
+/* Features we provide ourself. */
+
+#define HAVE_ATTR_XATTR_H 1
+#define HAVE_ATTR_LIBATTR_H 1
+#define HAVE_CONFIG_H 1
+
+#define HAVE_FGETXATTR 1
+#define HAVE_FLISTXATTR 1
+#define HAVE_FSETXATTR 1
+#define HAVE_GETXATTR 1
+#define HAVE_LISTXATTR 1
+#define HAVE_SETXATTR 1
diff --git a/libattr/syscalls.c b/libattr/syscalls.c
new file mode 100644
index 0000000..6ab0ca3
--- /dev/null
+++ b/libattr/syscalls.c
@@ -0,0 +1,263 @@
+/*
+ * Copyright (c) 2001-2002 Silicon Graphics, Inc.
+ * All Rights Reserved.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it would be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write the Free Software Foundation,
+ * Inc.,  51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+ */
+
+/*
+ * The use of the syscall() function is an additional level of
+ * indirection.  This avoids the dependency on kernel sources.
+ */
+
+#include <errno.h>
+#include <unistd.h>
+
+#if defined (__i386__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		226
+# define __NR_lsetxattr		227
+# define __NR_fsetxattr		228
+# define __NR_getxattr		229
+# define __NR_lgetxattr		230
+# define __NR_fgetxattr		231
+# define __NR_listxattr		232
+# define __NR_llistxattr	233
+# define __NR_flistxattr	234
+# define __NR_removexattr	235
+# define __NR_lremovexattr	236
+# define __NR_fremovexattr	237
+#elif defined (__sparc__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		169
+# define __NR_lsetxattr		170
+# define __NR_fsetxattr		171
+# define __NR_getxattr		172
+# define __NR_lgetxattr		173
+# define __NR_fgetxattr		177
+# define __NR_listxattr		178
+# define __NR_llistxattr	179
+# define __NR_flistxattr	180
+# define __NR_removexattr	181
+# define __NR_lremovexattr	182
+# define __NR_fremovexattr	186
+#elif defined (__ia64__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		1217
+# define __NR_lsetxattr		1218
+# define __NR_fsetxattr		1219
+# define __NR_getxattr		1220
+# define __NR_lgetxattr		1221
+# define __NR_fgetxattr		1222
+# define __NR_listxattr		1223
+# define __NR_llistxattr	1224
+# define __NR_flistxattr	1225
+# define __NR_removexattr	1226
+# define __NR_lremovexattr	1227
+# define __NR_fremovexattr	1228
+#elif defined (__powerpc__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		209
+# define __NR_lsetxattr		210
+# define __NR_fsetxattr		211
+# define __NR_getxattr		212
+# define __NR_lgetxattr		213
+# define __NR_fgetxattr		214
+# define __NR_listxattr		215
+# define __NR_llistxattr	216
+# define __NR_flistxattr	217
+# define __NR_removexattr	218
+# define __NR_lremovexattr	219
+# define __NR_fremovexattr	220
+#elif defined (__x86_64__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		188
+# define __NR_lsetxattr		189
+# define __NR_fsetxattr		190
+# define __NR_getxattr		191
+# define __NR_lgetxattr		192
+# define __NR_fgetxattr		193
+# define __NR_listxattr		194
+# define __NR_llistxattr	195
+# define __NR_flistxattr	196
+# define __NR_removexattr	197
+# define __NR_lremovexattr	198
+# define __NR_fremovexattr	199
+#elif defined (__s390__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		224
+# define __NR_lsetxattr		225
+# define __NR_fsetxattr		226
+# define __NR_getxattr		227
+# define __NR_lgetxattr		228
+# define __NR_fgetxattr		229
+# define __NR_listxattr		230
+# define __NR_llistxattr	231
+# define __NR_flistxattr	232
+# define __NR_removexattr	233
+# define __NR_lremovexattr	234
+# define __NR_fremovexattr	235
+#elif defined (__arm__)
+# define HAVE_XATTR_SYSCALLS 1
+# if defined(__ARM_EABI__) || defined(__thumb__)
+#  define __NR_SYSCALL_BASE 0
+# else
+#  define __NR_SYSCALL_BASE 0x900000
+# endif
+# define __NR_setxattr		(__NR_SYSCALL_BASE+226)
+# define __NR_lsetxattr		(__NR_SYSCALL_BASE+227)
+# define __NR_fsetxattr		(__NR_SYSCALL_BASE+228)
+# define __NR_getxattr		(__NR_SYSCALL_BASE+229)
+# define __NR_lgetxattr		(__NR_SYSCALL_BASE+230)
+# define __NR_fgetxattr		(__NR_SYSCALL_BASE+231)
+# define __NR_listxattr		(__NR_SYSCALL_BASE+232)
+# define __NR_llistxattr	(__NR_SYSCALL_BASE+233)
+# define __NR_flistxattr	(__NR_SYSCALL_BASE+234)
+# define __NR_removexattr	(__NR_SYSCALL_BASE+235)
+# define __NR_lremovexattr	(__NR_SYSCALL_BASE+236)
+# define __NR_fremovexattr	(__NR_SYSCALL_BASE+237)
+#elif defined (__mips64__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_Linux 5000
+# define __NR_setxattr		(__NR_Linux + 217)
+# define __NR_lsetxattr		(__NR_Linux + 218)
+# define __NR_fsetxattr		(__NR_Linux + 219)
+# define __NR_getxattr		(__NR_Linux + 220)
+# define __NR_lgetxattr		(__NR_Linux + 221)
+# define __NR_fgetxattr		(__NR_Linux + 222)
+# define __NR_listxattr		(__NR_Linux + 223)
+# define __NR_llistxattr	(__NR_Linux + 224)
+# define __NR_flistxattr	(__NR_Linux + 225)
+# define __NR_removexattr	(__NR_Linux + 226)
+# define __NR_lremovexattr	(__NR_Linux + 227)
+# define __NR_fremovexattr	(__NR_Linux + 228)
+#elif defined (__mips__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_Linux 4000
+# define __NR_setxattr		(__NR_Linux + 224)
+# define __NR_lsetxattr		(__NR_Linux + 225)
+# define __NR_fsetxattr		(__NR_Linux + 226)
+# define __NR_getxattr		(__NR_Linux + 227)
+# define __NR_lgetxattr		(__NR_Linux + 228)
+# define __NR_fgetxattr		(__NR_Linux + 229)
+# define __NR_listxattr		(__NR_Linux + 230)
+# define __NR_llistxattr	(__NR_Linux + 231)
+# define __NR_flistxattr	(__NR_Linux + 232)
+# define __NR_removexattr	(__NR_Linux + 233)
+# define __NR_lremovexattr	(__NR_Linux + 234)
+# define __NR_fremovexattr	(__NR_Linux + 235)
+#elif defined (__alpha__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		382
+# define __NR_lsetxattr		383
+# define __NR_fsetxattr		384
+# define __NR_getxattr		385
+# define __NR_lgetxattr		386
+# define __NR_fgetxattr		387
+# define __NR_listxattr		388
+# define __NR_llistxattr	389
+# define __NR_flistxattr	390
+# define __NR_removexattr	391
+# define __NR_lremovexattr	392
+# define __NR_fremovexattr	393
+#elif defined (__mc68000__)
+# define HAVE_XATTR_SYSCALLS 1
+# define __NR_setxattr		223
+# define __NR_lsetxattr		224
+# define __NR_fsetxattr		225
+# define __NR_getxattr		226
+# define __NR_lgetxattr		227
+# define __NR_fgetxattr		228
+# define __NR_listxattr		229
+# define __NR_llistxattr	230
+# define __NR_flistxattr	231
+# define __NR_removexattr	232
+# define __NR_lremovexattr	233
+# define __NR_fremovexattr	234
+#else
+# warning "Extended attribute syscalls undefined for this architecture"
+# define HAVE_XATTR_SYSCALLS 0
+#endif
+
+#if HAVE_XATTR_SYSCALLS
+# define SYSCALL(args...)	syscall(args)
+#else
+# define SYSCALL(args...)	( errno = ENOSYS, -1 )
+#endif
+
+int setxattr (const char *path, const char *name,
+			void *value, size_t size, int flags)
+{
+	return SYSCALL(__NR_setxattr, path, name, value, size, flags);
+}
+
+int lsetxattr (const char *path, const char *name,
+			void *value, size_t size, int flags)
+{
+	return SYSCALL(__NR_lsetxattr, path, name, value, size, flags);
+}
+
+int fsetxattr (int filedes, const char *name,
+			void *value, size_t size, int flags)
+{
+	return SYSCALL(__NR_fsetxattr, filedes, name, value, size, flags);
+}
+
+ssize_t getxattr (const char *path, const char *name,
+				void *value, size_t size)
+{
+	return SYSCALL(__NR_getxattr, path, name, value, size);
+}
+
+ssize_t lgetxattr (const char *path, const char *name,
+				void *value, size_t size)
+{
+	return SYSCALL(__NR_lgetxattr, path, name, value, size);
+}
+
+ssize_t fgetxattr (int filedes, const char *name,
+				void *value, size_t size)
+{
+	return SYSCALL(__NR_fgetxattr, filedes, name, value, size);
+}
+
+ssize_t listxattr (const char *path, char *list, size_t size)
+{
+	return SYSCALL(__NR_listxattr, path, list, size);
+}
+
+ssize_t llistxattr (const char *path, char *list, size_t size)
+{
+	return SYSCALL(__NR_llistxattr, path, list, size);
+}
+
+ssize_t flistxattr (int filedes, char *list, size_t size)
+{
+	return SYSCALL(__NR_flistxattr, filedes, list, size);
+}
+
+int removexattr (const char *path, const char *name)
+{
+	return SYSCALL(__NR_removexattr, path, name);
+}
+
+int lremovexattr (const char *path, const char *name)
+{
+	return SYSCALL(__NR_lremovexattr, path, name);
+}
+
+int fremovexattr (int filedes, const char *name)
+{
+	return SYSCALL(__NR_fremovexattr, filedes, name);
+}
diff --git a/libcore/Android.mk b/libcore/Android.mk
index 7de73be..491f4da 100644
--- a/libcore/Android.mk
+++ b/libcore/Android.mk
@@ -154,6 +154,10 @@ $(foreach dir, \
 # Define the rules.
 LOCAL_SRC_FILES := $(core_src_files)
 LOCAL_MODULE := libjavacore
+# turn on taint tracking
+ifeq ($(WITH_TAINT_TRACKING),true)
+    LOCAL_CFLAGS += -DWITH_TAINT_TRACKING
+endif
 include $(BUILD_STATIC_LIBRARY)
 
 # Deal with keystores required for security. Note: The path to this file
diff --git a/libcore/dalvik/src/main/java/dalvik/system/Taint.java b/libcore/dalvik/src/main/java/dalvik/system/Taint.java
new file mode 100644
index 0000000..73afb13
--- /dev/null
+++ b/libcore/dalvik/src/main/java/dalvik/system/Taint.java
@@ -0,0 +1,438 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Author: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package dalvik.system;
+
+/**
+ * Provides a Taint interface for the Dalvik VM. This class is used for
+ * implementing Taint Source and Sink functionality.
+ * 
+ */
+public final class Taint {
+
+    public static final int TAINT_CLEAR		= 0x00000000;
+    public static final int TAINT_LOCATION	= 0x00000001;
+    public static final int TAINT_CONTACTS	= 0x00000002;
+    public static final int TAINT_MIC           = 0x00000004;
+    public static final int TAINT_PHONE_NUMBER  = 0x00000008;
+    public static final int TAINT_LOCATION_GPS  = 0x00000010;
+    public static final int TAINT_LOCATION_NET  = 0x00000020;
+    public static final int TAINT_LOCATION_LAST = 0x00000040;
+    public static final int TAINT_CAMERA        = 0x00000080;
+    public static final int TAINT_ACCELEROMETER = 0x00000100;
+    public static final int TAINT_SMS           = 0x00000200;
+    public static final int TAINT_IMEI          = 0x00000400;
+    public static final int TAINT_IMSI          = 0x00000800;
+    public static final int TAINT_ICCID         = 0x00001000;
+    public static final int TAINT_DEVICE_SN     = 0x00002000;
+    public static final int TAINT_ACCOUNT       = 0x00004000;
+    public static final int TAINT_HISTORY       = 0x00008000;
+
+    /**
+     * Updates the target String's taint tag.
+     *
+     * @param str
+     *	    the target string
+     * @param tag
+     *	    tag to update (bitwise or) onto the object
+     */
+    native public static void addTaintString(String str, int tag);
+    
+    /**
+     * Updates the target Object array's taint tag.
+     *
+     * @param array
+     *	    the target object array
+     * @param tag
+     *	    tag to update (bitwise or) onto the object array
+     */
+    native public static void addTaintObjectArray(Object[] array, int tag);
+
+    /**
+     * Updates the target boolean array's taint tag.
+     *
+     * @param array
+     *	    the target boolean array
+     * @param tag
+     *	    tag to update (bitwise or) onto the boolean array
+     */
+    native public static void addTaintBooleanArray(boolean[] array, int tag);
+
+    /**
+     * Updates the target char array's taint tag.
+     *
+     * @param array
+     *	    the target char array
+     * @param tag
+     *	    tag to update (bitwise or) onto the char array
+     */
+    native public static void addTaintCharArray(char[] array, int tag);
+
+    /**
+     * Updates the target byte array's taint tag.
+     *
+     * @param array
+     *	    the target byte array
+     * @param tag
+     *	    tag to update (bitwise or) onto the byte array
+     */
+    native public static void addTaintByteArray(byte[] array, int tag);
+
+    /**
+     * Updates the target int array's taint tag.
+     *
+     * @param array
+     *	    the target int array
+     * @param tag
+     *	    tag to update (bitwise or) onto the int array
+     */
+    native public static void addTaintIntArray(int[] array, int tag);
+    
+    /**
+     * Updates the target short array's taint tag.
+     *
+     * @param array
+     *	    the target short array
+     * @param tag
+     *	    tag to update (bitwise or) onto the int array
+     */
+    native public static void addTaintShortArray(short[] array, int tag);
+
+    /**
+     * Updates the target long array's taint tag.
+     *
+     * @param array
+     *	    the target long array
+     * @param tag
+     *	    tag to update (bitwise or) onto the long array
+     */
+    native public static void addTaintLongArray(long[] array, int tag);
+
+    /**
+     * Updates the target float array's taint tag.
+     *
+     * @param array
+     *	    the target float array
+     * @param tag
+     *	    tag to update (bitwise or) onto the float array
+     */
+    native public static void addTaintFloatArray(float[] array, int tag);
+
+    /**
+     * Updates the target double array's taint tag.
+     *
+     * @param array
+     *	    the target double array
+     * @param tag
+     *	    tag to update (bitwise or) onto the double array
+     */
+    native public static void addTaintDoubleArray(double[] array, int tag);
+    
+    /**
+     * Add taint to a primiative boolean value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static boolean addTaintBoolean(boolean val, int tag);
+    
+    /**
+     * Add taint to a primiative char value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static char addTaintChar(char val, int tag);
+    
+    /**
+     * Add taint to a primiative byte value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static byte addTaintByte(byte val, int tag);
+
+    /**
+     * Add taint to a primiative int value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static int addTaintInt(int val, int tag);
+
+    /**
+     * Add taint to a primiative long value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static long addTaintLong(long val, int tag);
+
+    /**
+     * Add taint to a primiative float value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static float addTaintFloat(float val, int tag);
+
+    /**
+     * Add taint to a primiative double value. Only the return value has the
+     * updated taint tag.
+     *
+     * @param val
+     *	    the input value
+     * @param tag
+     *	    tag to add (bitwise or) onto the input value
+     * @return val with the added taint tag
+     */
+    native public static double addTaintDouble(double val, int tag);
+
+    /**
+     * Get the current taint tag from a String.
+     *
+     * @param str
+     *	    the target String
+     * @return the taint tag
+     */
+    native public static int getTaintString(String str);
+
+    /**
+     * Get the current taint tag from an Object array.
+     *
+     * @param array 
+     *	    the target Object array
+     * @return the taint tag
+     */
+    native public static int getTaintObjectArray(Object[] array);
+
+    /**
+     * Get the current taint tag from a boolean array.
+     *
+     * @param array 
+     *	    the target boolean array
+     * @return the taint tag
+     */
+    native public static int getTaintBooleanArray(boolean[] array);
+
+    /**
+     * Get the current taint tag from a char array.
+     *
+     * @param array 
+     *	    the target char array
+     * @return the taint tag
+     */
+    native public static int getTaintCharArray(char[] array);
+
+    /**
+     * Get the current taint tag from a byte array.
+     *
+     * @param array 
+     *	    the target byte array
+     * @return the taint tag
+     */
+    native public static int getTaintByteArray(byte[] array);
+
+    /**
+     * Get the current taint tag from an int array.
+     *
+     * @param array 
+     *	    the target int array
+     * @return the taint tag
+     */
+    native public static int getTaintIntArray(int[] array);
+
+    /**
+     * Get the current taint tag from a short array.
+     *
+     * @param array 
+     *	    the target short array
+     * @return the taint tag
+     */
+    native public static int getTaintShortArray(short[] array);
+
+    /**
+     * Get the current taint tag from a long array.
+     *
+     * @param array 
+     *	    the target long array
+     * @return the taint tag
+     */
+    native public static int getTaintLongArray(long[] array);
+
+    /**
+     * Get the current taint tag from a float array.
+     *
+     * @param array 
+     *	    the target float array
+     * @return the taint tag
+     */
+    native public static int getTaintFloatArray(float[] array);
+
+    /**
+     * Get the current taint tag from a double array.
+     *
+     * @param array 
+     *	    the target double array
+     * @return the taint tag
+     */
+    native public static int getTaintDoubleArray(double[] array);
+
+    /**
+     * Get the current taint tag from a primiative boolean.
+     *
+     * @param val
+     *	    the target boolean
+     * @return the taint tag
+     */
+    native public static int getTaintBoolean(boolean val);
+
+    /**
+     * Get the current taint tag from a primiative char.
+     *
+     * @param val
+     *	    the target char 
+     * @return the taint tag
+     */
+    native public static int getTaintChar(char val);
+
+    /**
+     * Get the current taint tag from a primiative byte.
+     *
+     * @param val
+     *	    the target byte 
+     * @return the taint tag
+     */
+    native public static int getTaintByte(byte val);
+
+    /**
+     * Get the current taint tag from a primiative int.
+     *
+     * @param val
+     *	    the target int 
+     * @return the taint tag
+     */
+    native public static int getTaintInt(int val);
+
+    /**
+     * Get the current taint tag from a primiative long.
+     *
+     * @param val
+     *	    the target long 
+     * @return the taint tag
+     */
+    native public static int getTaintLong(long val);
+
+    /**
+     * Get the current taint tag from a primiative float.
+     *
+     * @param val
+     *	    the target float 
+     * @return the taint tag
+     */
+    native public static int getTaintFloat(float val);
+
+    /**
+     * Get the current taint tag from a primiative double.
+     *
+     * @param val
+     *	    the target double 
+     * @return the taint tag
+     */
+    native public static int getTaintDouble(double val);
+
+    /**
+     * Get the current taint tag from an Object reference.
+     *
+     * @param obj
+     *	    the target Object reference
+     * @return the taint tag
+     */
+    native public static int getTaintRef(Object obj);
+    
+    /**
+     * Get the taint tag from a file identified by a descriptor.
+     *
+     * @param fd
+     *	    the target file descriptor
+     * @return the taint tag
+     */
+    native public static int getTaintFile(int fd);
+
+    /**
+     * add a taint tag to a file identified by a descriptor
+     *
+     * @param fd
+     *	    the target file descriptor
+     * @param tag
+     *	    the tag to add (bitwise or) to the file
+     */
+    native public static void addTaintFile(int fd, int tag);
+
+    /**
+     * Logging utility accessible from places android.util.Log
+     * is not.
+     *
+     * @param msg
+     *	    the message to log
+     */
+    native public static void log(String msg);
+
+
+    /**
+     * Logging utiltity to obtain the file path for a file descriptor
+     *
+     * @param fd
+     *	    the file descriptor
+     */
+    native public static void logPathFromFd(int fd);
+
+    /**
+     * Logging utiltity to obtain the peer IP addr for a file descriptor
+     *
+     * @param fd
+     *	    the file descriptor
+     */
+    native public static void logPeerFromFd(int fd);
+}
+
diff --git a/libcore/luni/src/main/java/java/io/FileDescriptor.java b/libcore/luni/src/main/java/java/io/FileDescriptor.java
index 15eb983..1215658 100644
--- a/libcore/luni/src/main/java/java/io/FileDescriptor.java
+++ b/libcore/luni/src/main/java/java/io/FileDescriptor.java
@@ -106,4 +106,27 @@ public final class FileDescriptor {
     public boolean valid() {
         return descriptor != -1;
     }
+
+    // begin WITH_TAINT_TRACKING
+    /**
+     * hack for printing out IP address
+     * @hide
+     */
+    public boolean hasName = false;
+
+    /**
+     * hack for printing out IP address
+     * @hide
+     */
+    public String name = null;
+
+    /**
+     * hack for setting file taint
+     * @hide
+     */
+    public int getDescriptor()
+    {
+	return descriptor;
+    }
+    // end WITH_TAINT_TRACKING
 }
diff --git a/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java b/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java
index 08bdac6..a4c95b2 100644
--- a/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java
+++ b/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSFileSystem.java
@@ -26,6 +26,10 @@ import java.io.FileNotFoundException;
 import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 
+// begin WITH_TAINT_TRACKING
+import dalvik.system.Taint;
+// end WITH_TAINT_TRACKING
+
 /**
  * This is the portable implementation of the file system interface.
  *
@@ -128,6 +132,9 @@ class OSFileSystem implements IFileSystem {
         if (bytesRead < -1) {
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	Taint.log("OSFileSystem.readDirect("+fileDescriptor+") can't check taint!");
+	// end WITH_TAINT_TRACKING
         return bytesRead;
     }
 
@@ -141,6 +148,9 @@ class OSFileSystem implements IFileSystem {
         if (bytesWritten < 0) {
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	Taint.log("OSFileSystem.writeDirect("+fileDescriptor+") can't check taint!");
+	// end WITH_TAINT_TRACKING
         return bytesWritten;
     }
 
@@ -167,6 +177,15 @@ class OSFileSystem implements IFileSystem {
              */
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintFile(fileDescriptor);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(bytes);
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSFileSystem.read("+fileDescriptor+"): reading with tag " + tstr + " data["+dstr+"]");
+	    Taint.addTaintByteArray(bytes, tag);
+	}
+	// end WITH_TAINT_TRACKING
         return bytesRead;
     }
 
@@ -179,6 +198,16 @@ class OSFileSystem implements IFileSystem {
         if (bytesWritten < 0) {
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(bytes);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(bytes);
+	    Taint.logPathFromFd(fileDescriptor);
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSFileSystem.write("+fileDescriptor+"): writing with tag " + tstr + " data["+dstr+"]");
+	    Taint.addTaintFile(fileDescriptor, tag);
+	}
+	// end WITH_TAINT_TRACKING
         return bytesWritten;
     }
 
@@ -192,6 +221,9 @@ class OSFileSystem implements IFileSystem {
         if (bytesRead < -1) {
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	Taint.log("OSFileSystem.readv("+fileDescriptor+") can't check taint!");
+	// end WITH_TAINT_TRACKING
         return bytesRead;
     }
 
@@ -205,6 +237,9 @@ class OSFileSystem implements IFileSystem {
         if (bytesWritten < 0) {
             throw new IOException();
         }
+	// begin WITH_TAINT_TRACKING
+	Taint.log("OSFileSystem.writev("+fileDescriptor+") can't check taint!");
+	// end WITH_TAINT_TRACKING
         return bytesWritten;
     }
 
diff --git a/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java b/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java
index bd6a609..ad3fc14 100644
--- a/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java
+++ b/libcore/luni/src/main/java/org/apache/harmony/luni/platform/OSNetworkSystem.java
@@ -32,6 +32,10 @@ import java.net.SocketException;
 import java.net.SocketImpl;
 import java.net.UnknownHostException;
 import java.nio.channels.Channel;
+
+// BEGIN WITH_TAINT_TRACKING
+import dalvik.system.Taint;
+// END WITH_TAINT_TRACKING
 // BEGIN android-removed
 // import java.nio.channels.SelectableChannel;
 // END android-removed
@@ -111,6 +115,13 @@ final class OSNetworkSystem implements INetworkSystem {
 
     public int connect(FileDescriptor fd, int trafficClass,
             InetAddress inetAddress, int port) throws IOException{
+	// begin WITH_TAINT_TRACKING
+	String addr = inetAddress.getHostAddress();
+	if (addr != null) {
+	    fd.hasName = true;
+	    fd.name = addr;
+	}
+	// end WITH_TAINT_TRACKING
         return connectSocketImpl(fd, trafficClass, inetAddress, port);
     }
 
@@ -119,6 +130,13 @@ final class OSNetworkSystem implements INetworkSystem {
 
     public void connectDatagram(FileDescriptor fd, int port,
             int trafficClass, InetAddress inetAddress) throws SocketException {
+	// begin WITH_TAINT_TRACKING
+	String addr = inetAddress.getHostAddress();
+	if (addr != null) {
+	    fd.hasName = true;
+	    fd.name = addr;
+	}
+	// end WITH_TAINT_TRACKING
         connectDatagramImpl2(fd, port, trafficClass, inetAddress);
     }
 
@@ -128,6 +146,13 @@ final class OSNetworkSystem implements INetworkSystem {
     public void connectStreamWithTimeoutSocket(FileDescriptor aFD,
             int aport, int timeout, int trafficClass, InetAddress inetAddress)
             throws IOException {
+	// begin WITH_TAINT_TRACKING
+	String addr = inetAddress.getHostAddress();
+	if (addr != null) {
+	    aFD.hasName = true;
+	    aFD.name = addr;
+	}
+	// end WITH_TAINT_TRACKING
         connectStreamWithTimeoutSocketImpl(aFD, aport, timeout, trafficClass,
                 inetAddress);
     }
@@ -141,6 +166,13 @@ final class OSNetworkSystem implements INetworkSystem {
     public int connectWithTimeout(FileDescriptor fd, int timeout,
             int trafficClass, InetAddress inetAddress, int port, int step,
             byte[] context) throws IOException {
+	// begin WITH_TAINT_TRACKING
+	String addr = inetAddress.getHostAddress();
+	if (addr != null) {
+	    fd.hasName = true;
+	    fd.name = addr;
+	}
+	// end WITH_TAINT_TRACKING
         return connectWithTimeoutSocketImpl(fd, timeout, trafficClass,
                 inetAddress, port, step, context);
     }
@@ -495,6 +527,15 @@ final class OSNetworkSystem implements INetworkSystem {
      */
     public int sendStream(FileDescriptor fd, byte[] data, int offset, int count)
             throws IOException {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(data);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(data);
+	    String addr = (fd.hasName) ? fd.name : "unknown";
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.sendStream("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
+	}
+	// end WITH_TAINT_TRACKING
         return sendStreamImpl(fd, data, offset, count);
     }
 
@@ -620,6 +661,15 @@ final class OSNetworkSystem implements INetworkSystem {
      */
     public int sendConnectedDatagram(FileDescriptor fd, byte[] data,
             int offset, int length, boolean bindToDevice) throws IOException {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(data);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(data);
+	    String addr = (fd.hasName) ? fd.name : "unknown";
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.sendConnectedDatagram("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
+	}
+	// end WITH_TAINT_TRACKING
         return sendConnectedDatagramImpl(fd, data, offset, length, bindToDevice);
     }
 
@@ -630,6 +680,10 @@ final class OSNetworkSystem implements INetworkSystem {
     public int sendConnectedDatagramDirect(FileDescriptor fd,
             int address, int offset, int length, boolean bindToDevice)
             throws IOException {
+	// begin WITH_TAINT_TRACKING
+	String addr = (fd.hasName) ? fd.name : "unknown";
+	Taint.log("OSNetworkSystem.sendConnectedDatagramDirect("+addr+"), can't check taint!");
+	// end WITH_TAINT_TRACKING
         return sendConnectedDatagramDirectImpl(fd, address, offset, length, bindToDevice);
     }
     static native int sendConnectedDatagramDirectImpl(FileDescriptor fd,
@@ -665,6 +719,15 @@ final class OSNetworkSystem implements INetworkSystem {
     public int sendDatagram(FileDescriptor fd, byte[] data, int offset,
             int length, int port, boolean bindToDevice, int trafficClass,
             InetAddress inetAddress) throws IOException {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(data);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(data);
+	    String addr = (fd.hasName) ? fd.name : "unknown";
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.sendDatagram("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
+	}
+	// end WITH_TAINT_TRACKING
         return sendDatagramImpl(fd, data, offset, length, port, bindToDevice,
                 trafficClass, inetAddress);
     }
@@ -675,6 +738,15 @@ final class OSNetworkSystem implements INetworkSystem {
 
     public int sendDatagram2(FileDescriptor fd, byte[] data, int offset,
             int length, int port, InetAddress inetAddress) throws IOException {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(data);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(data);
+	    String addr = (fd.hasName) ? fd.name : "unknown";
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.sendDatagram2("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
+	}
+	// end WITH_TAINT_TRACKING
         return sendDatagramImpl2(fd, data, offset, length, port, inetAddress);
     }
 
@@ -685,6 +757,10 @@ final class OSNetworkSystem implements INetworkSystem {
     public int sendDatagramDirect(FileDescriptor fd, int address,
             int offset, int length, int port, boolean bindToDevice,
             int trafficClass, InetAddress inetAddress) throws IOException {
+	// begin WITH_TAINT_TRACKING
+	String addr = (fd.hasName) ? fd.name : "unknown";
+	Taint.log("OSNetworkSystem.sendDatagramDirect("+addr+"), can't check taint!");
+	// end WITH_TAINT_TRACKING
         return sendDatagramDirectImpl(fd, address, offset, length, port, bindToDevice,
                 trafficClass, inetAddress);
     }
@@ -694,6 +770,14 @@ final class OSNetworkSystem implements INetworkSystem {
             int trafficClass, InetAddress inetAddress) throws IOException;
 
     public void sendUrgentData(FileDescriptor fd, byte value) {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByte(value);
+	String addr = (fd.hasName) ? fd.name : "unknown";
+	if (tag != Taint.TAINT_CLEAR) {
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.sendUrgentData("+addr+") received data with tag " + tstr + " value=["+value+"]");
+	}
+	// end WITH_TAINT_TRACKING
         sendUrgentDataImpl(fd, value);
     }
 
@@ -801,6 +885,15 @@ final class OSNetworkSystem implements INetworkSystem {
      */
     public int write(FileDescriptor fd, byte[] data, int offset, int count)
             throws IOException {
+	// begin WITH_TAINT_TRACKING
+	int tag = Taint.getTaintByteArray(data);
+	if (tag != Taint.TAINT_CLEAR) {
+	    String dstr = new String(data);
+	    String addr = (fd.hasName) ? fd.name : "unknown";
+	    String tstr = "0x" + Integer.toHexString(tag);
+	    Taint.log("OSNetworkSystem.write("+addr+") received data with tag " + tstr + " data=["+dstr+"]");
+	}
+	// end WITH_TAINT_TRACKING
         return writeSocketImpl(fd, data, offset, count);
     }
 
@@ -824,6 +917,10 @@ final class OSNetworkSystem implements INetworkSystem {
      */
     public int writeDirect(FileDescriptor fd, int address, int offset, int count)
             throws IOException {
+	// begin WITH_TAINT_TRACKING
+	String addr = (fd.hasName) ? fd.name : "unknown";
+	Taint.log("OSNetworkSystem.writeDirect("+addr+"), can't check taint!");
+	// end WITH_TAINT_TRACKING
         return writeSocketDirectImpl(fd, address, offset, count);
     }
 
diff --git a/libcore/luni/src/main/java/org/apache/harmony/luni/util/NumberConverter.java b/libcore/luni/src/main/java/org/apache/harmony/luni/util/NumberConverter.java
index 18d6a5b..c0ee5ee 100644
--- a/libcore/luni/src/main/java/org/apache/harmony/luni/util/NumberConverter.java
+++ b/libcore/luni/src/main/java/org/apache/harmony/luni/util/NumberConverter.java
@@ -17,6 +17,9 @@
 
 package org.apache.harmony.luni.util;
 
+// ifdef WITH_TAINT_TRACKING
+import dalvik.system.Taint;
+// endif
 
 public final class NumberConverter {
 
@@ -60,6 +63,10 @@ public final class NumberConverter {
         long eMask = 0x7FF0000000000000L; // the mask to get the power bits
         long fMask = 0x000FFFFFFFFFFFFFL; // the mask to get the significand
         // bits
+	
+	// start WITH_TAINT_TRACKING
+	int tag = Taint.getTaintDouble(inputNumber);
+	// end WITH_TAINT_TRACKING
 
         long inputNumberBits = Double.doubleToLongBits(inputNumber);
         // the value of the sign... 0 is positive, ~0 is negative
@@ -75,11 +82,31 @@ public final class NumberConverter {
             return mantissaIsZero ? signString + "Infinity" : "NaN";
         if (e == 0) {
             if (mantissaIsZero)
-                return signString + "0.0";
+		// start WITH_TAINT_TRACKING
+	    {
+		if (tag != Taint.TAINT_CLEAR) {
+		    String ts = new String(signString + "0.0");
+		    Taint.addTaintString(ts, tag);
+		    return ts;
+		} else {
+		    return signString + "0.0";
+		}
+	    }
+		// end WITH_TAINT_TRACKING
             if (f == 1)
                 // special case to increase precision even though 2 *
                 // Double.MIN_VALUE is 1.0e-323
-                return signString + "4.9E-324";
+		// start WITH_TAINT_TRACKING
+	    {
+		if (tag != Taint.TAINT_CLEAR) {
+		    String ts = new String(signString + "4.9E-324");
+		    Taint.addTaintString(ts, tag);
+		    return ts;
+		} else {
+		    return signString + "4.9E-324";
+		}
+	    }
+		// end WITH_TAINT_TRACKING
             pow = 1 - p; // a denormalized number
             long ff = f;
             while ((ff & 0x0010000000000000L) == 0) {
@@ -101,9 +128,27 @@ public final class NumberConverter {
 
         if (inputNumber >= 1e7D || inputNumber <= -1e7D
                 || (inputNumber > -1e-3D && inputNumber < 1e-3D))
-            return signString + freeFormatExponential();
+	    // start WITH_TAINT_TRACKING
+	{
+	    if (tag != Taint.TAINT_CLEAR) {
+		String ts = new String(signString + freeFormatExponential());
+		Taint.addTaintString(ts, tag);
+		return ts;
+	    } else {
+		return signString + freeFormatExponential();
+	    }
+	}
+	    // end WITH_TAINT_TRACKING
         
-        return signString + freeFormat();
+	// start WITH_TAINT_TRACKING
+	if (tag != Taint.TAINT_CLEAR) {
+	    String ts = signString + freeFormat();
+	    Taint.addTaintString(ts, tag);
+	    return ts;
+	} else {
+	    return signString + freeFormat();
+	}
+	// end WITH_TAINT_TRACKING
     }
 
     public String convertF(float inputNumber) {
@@ -112,6 +157,10 @@ public final class NumberConverter {
         int eMask = 0x7F800000; // the mask to get the power bits
         int fMask = 0x007FFFFF; // the mask to get the significand bits
 
+	// start WITH_TAINT_TRACKING
+	int tag = Taint.getTaintDouble(inputNumber);
+	// end WITH_TAINT_TRACKING
+
         int inputNumberBits = Float.floatToIntBits(inputNumber);
         // the value of the sign... 0 is positive, ~0 is negative
         String signString = (inputNumberBits & signMask) == 0 ? "" : "-";
@@ -126,7 +175,17 @@ public final class NumberConverter {
             return mantissaIsZero ? signString + "Infinity" : "NaN";
         if (e == 0) {
             if (mantissaIsZero)
-                return signString + "0.0";
+		// start WITH_TAINT_TRACKING
+	    {
+		if (tag != Taint.TAINT_CLEAR) {
+		    String ts = new String(signString + "0.0");
+		    Taint.addTaintString(ts, tag);
+		    return ts;
+		} else {
+		    return signString + "0.0";
+		}
+	    }
+		// end WITH_TAINT_TRACKING
             pow = 1 - p; // a denormalized number
             if (f < 8) { // want more precision with smallest values
                 f = f << 2;
@@ -151,9 +210,27 @@ public final class NumberConverter {
                     numBits);
         if (inputNumber >= 1e7f || inputNumber <= -1e7f
                 || (inputNumber > -1e-3f && inputNumber < 1e-3f))
-            return signString + freeFormatExponential();
+	    // start WITH_TAINT_TRACKING
+	{
+	    if (tag != Taint.TAINT_CLEAR) {
+		String ts = new String(signString + freeFormatExponential());
+		Taint.addTaintString(ts, tag);
+		return ts;
+	    } else {
+		return signString + freeFormatExponential();
+	    }
+	}
+	    // end WITH_TAINT_TRACKING
         
-        return signString + freeFormat();
+	// start WITH_TAINT_TRACKING
+	if (tag != Taint.TAINT_CLEAR) {
+	    String ts = new String(signString + freeFormat());
+	    Taint.addTaintString(ts, tag);
+	    return ts;
+	} else {
+	    return signString + freeFormat();
+	}
+	// end WITH_TAINT_TRACKING
     }
 
     private String freeFormatExponential() {
diff --git a/libcore/luni/src/main/native/java_io_File.c b/libcore/luni/src/main/native/java_io_File.c
index bf89681..fbda566 100644
--- a/libcore/luni/src/main/native/java_io_File.c
+++ b/libcore/luni/src/main/native/java_io_File.c
@@ -586,7 +586,16 @@ static jboolean java_io_File_mkdirImpl(JNIEnv* env, jobject recv,
 
 // BEGIN android-changed
 // don't want default permissions to allow global access.
+#ifdef WITH_TAINT_TRACKING
+    // In case the SDcard is ext2, make sure it is 777
+    if (strncmp(pathCopy, "/sdcard/", 8) == 0) {
+	result = mkdir(pathCopy, S_IRWXU|S_IRWXG|S_IRWXO);
+    } else {
+	result = mkdir(pathCopy, S_IRWXU);
+    }
+#else
     result = mkdir(pathCopy, S_IRWXU);
+#endif
 // END android-changed
 
     if(-1 != result)
@@ -622,7 +631,16 @@ static jint java_io_File_newFileImpl(JNIEnv* env, jobject recv,
     /* Now create the file and close it */
 // BEGIN android-changed
 // don't want default permissions to allow global access.
+#ifdef WITH_TAINT_TRACKING
+    int fd;
+    if (strncmp(pathCopy, "/sdcard/", 8) == 0) {
+	fd = open(pathCopy, O_EXCL | O_CREAT, 0666);
+    } else {
+	fd = open(pathCopy, O_EXCL | O_CREAT, 0600);
+    }
+#else
     int fd = open(pathCopy, O_EXCL | O_CREAT, 0600);
+#endif
 // END android-changed
     if(fd == -1)
     {
diff --git a/libcore/luni/src/main/native/org_apache_harmony_luni_platform_OSFileSystem.cpp b/libcore/luni/src/main/native/org_apache_harmony_luni_platform_OSFileSystem.cpp
index 38f3d36..64e5b39 100644
--- a/libcore/luni/src/main/native/org_apache_harmony_luni_platform_OSFileSystem.cpp
+++ b/libcore/luni/src/main/native/org_apache_harmony_luni_platform_OSFileSystem.cpp
@@ -602,6 +602,13 @@ static jint harmony_io_openImpl(JNIEnv * env, jobject obj, jbyteArray path,
     pathCopy[length] = '\0';
     convertToPlatform (pathCopy);
 
+#ifdef WITH_TAINT_TRACKING
+    // Ensure /sdcard always acts like FAT, even if it is ext2
+    if (strncmp(pathCopy, "/sdcard/", 8) == 0) {
+	mode = 0777;
+    }
+#endif
+
     int cc;
     
     if(pathCopy == NULL) {
diff --git a/tools/tprop/Android.mk b/tools/tprop/Android.mk
new file mode 100644
index 0000000..1b29399
--- /dev/null
+++ b/tools/tprop/Android.mk
@@ -0,0 +1,31 @@
+# Copyright (c) 2010 The Pennsylvania State University
+# Systems and Internet Infrastructure Security Laboratory
+#
+# Authors: William Enck <enck@cse.psu.edu>
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+LOCAL_PATH := $(my-dir)
+
+ifeq ($(WITH_TAINT_TRACKING),true)
+    # Add ftaint only for "eng"
+    include $(CLEAR_VARS)
+    LOCAL_MODULE := ftaint
+    #LOCAL_MODULE_CLASS := EXECUTABLES
+    LOCAL_MODULE_TAGS := eng
+    LOCAL_SRC_FILES := ftaint.c
+    LOCAL_STATIC_LIBRARIES := libattr
+    LOCAL_C_INCLUDES := dalvik/libattr
+    include $(BUILD_EXECUTABLE)
+endif
+
diff --git a/tools/tprop/ftaint.c b/tools/tprop/ftaint.c
new file mode 100644
index 0000000..6a68292
--- /dev/null
+++ b/tools/tprop/ftaint.c
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include "attr/xattr.h"
+
+#define TAINT_XATTR_NAME "user.taint"
+
+#define USAGE "Usage: %s [g|s|a] <file> [<hex>]\n"
+#define TAINT_CLEAR 0x0
+
+typedef unsigned int u4;
+
+static u4 getTaintXattr(const char *path)
+{
+    int ret;
+    u4 buf;
+    u4 tag = TAINT_CLEAR;
+
+    ret = getxattr(path, TAINT_XATTR_NAME, &buf, sizeof(buf)); 
+    if (ret > 0) {
+	tag = buf;
+    } else {
+	if (errno == ENOATTR) {
+	    fprintf(stdout, "getxattr(%s): no taint tag\n", path);
+	} else if (errno == ERANGE) {
+	    fprintf(stderr, "Error: getxattr(%s) contents to large\n", path);
+	} else if (errno == ENOTSUP) {
+	    fprintf(stderr, "Error: getxattr(%s) not supported\n", path);
+	} else {
+	    fprintf(stderr, "Errro: getxattr(%s): unknown error code %d\n", path, errno);
+	}
+    }
+
+    return tag;
+}
+
+static void setTaintXattr(const char *path, u4 tag)
+{
+    int ret;
+
+    ret = setxattr(path, TAINT_XATTR_NAME, &tag, sizeof(tag), 0);
+
+    if (ret < 0) {
+	if (errno == ENOSPC || errno == EDQUOT) {
+	    fprintf(stderr, "Error: setxattr(%s): not enough room to set xattr\n", path);
+	} else if (errno == ENOTSUP) {
+	    fprintf(stderr, "Error: setxattr(%s) not supported\n", path);
+	} else {
+	    fprintf(stderr, "Errro: setxattr(%s): unknown error code %d\n", path, errno);
+	}
+    }
+
+}
+
+void usage(const char *prog)
+{
+    fprintf(stderr, USAGE, prog);
+    exit(1);
+}
+
+int main(int argc, char *argv[])
+{
+    u4 tag;
+
+    if (argc != 3 && argc != 4) {
+	usage(argv[0]);
+    }
+
+    if (strlen(argv[1]) != 1) {
+	usage(argv[0]);
+    }
+
+    // Get the taint
+    if (argc == 3) {
+	if (argv[1][0] == 'g') {
+	    tag = getTaintXattr(argv[2]);
+	    fprintf(stdout, "0x%08x\n", tag);
+	    return 0;
+	} else {
+	    usage(argv[0]);
+	}
+    }
+
+    // Set the taint
+    tag = strtol(argv[3], NULL, 16);
+    if (tag == 0 && errno == EINVAL) {
+	usage(argv[0]);
+    }
+
+    if (argv[1][0] == 's') {
+	setTaintXattr(argv[2], tag);
+    } else if (argv[1][0] == 'a') {
+	u4 old = getTaintXattr(argv[2]);
+	setTaintXattr(argv[2], tag | old);
+    } else {
+	usage(argv[0]);
+    }
+
+    return 0;
+}
diff --git a/vm/Dalvik.h b/vm/Dalvik.h
index 054b838..0feceb0 100644
--- a/vm/Dalvik.h
+++ b/vm/Dalvik.h
@@ -84,4 +84,9 @@
 #include "interp/Interp.h"
 #include "InlineNative.h"
 
+#ifdef WITH_TAINT_TRACKING
+#include "interp/Taint.h"
+#include "tprop/TaintProp.h"
+#endif
+
 #endif /*_DALVIK_DALVIK*/
diff --git a/vm/Debugger.c b/vm/Debugger.c
index 4ddf25c..66316b1 100644
--- a/vm/Debugger.c
+++ b/vm/Debugger.c
@@ -2244,7 +2244,12 @@ static Object* getThisObject(const u4* framePtr)
 {
     const StackSaveArea* saveArea = SAVEAREA_FROM_FP(framePtr);
     const Method* method = saveArea->method;
+#ifdef WITH_TAINT_TRACKING
+    /* taint tags are interleaved */
+    int argOffset = (method->registersSize - method->insSize) <<1;
+#else
     int argOffset = method->registersSize - method->insSize;
+#endif
     Object* thisObj;
 
     if (method == NULL) {
@@ -2307,7 +2312,12 @@ void dvmDbgGetLocalValue(ObjectId threadId, FrameId frameId, int slot,
 
     UNUSED_PARAMETER(threadId);
 
+#ifdef WITH_TAINT_TRACKING
+    /* Taint tags are interleaved */
+    slot = untweakSlot(slot, framePtr) <<1;     // Eclipse workaround
+#else
     slot = untweakSlot(slot, framePtr);     // Eclipse workaround
+#endif
 
     switch (tag) {
     case JT_BOOLEAN:
@@ -2373,7 +2383,16 @@ void dvmDbgGetLocalValue(ObjectId threadId, FrameId frameId, int slot,
     case JT_DOUBLE:
     case JT_LONG:
         assert(expectedLen == 8);
+#ifdef WITH_TAINT_TRACKING
+	{
+	    union { u8 ll; u4 parts[2]; } conv;
+	    conv.parts[0] = framePtr[slot];
+	    conv.parts[1] = framePtr[slot+2];
+	    longVal = conv.ll;
+	}
+#else
         longVal = *(u8*)(&framePtr[slot]);
+#endif
         set8BE(buf+1, longVal);
         break;
     default:
@@ -2395,7 +2414,12 @@ void dvmDbgSetLocalValue(ObjectId threadId, FrameId frameId, int slot, u1 tag,
 
     UNUSED_PARAMETER(threadId);
 
+#ifdef WITH_TAINT_TRACKING
+    /* taint tag is interleaved */
+    slot = untweakSlot(slot, framePtr)<<1;     // Eclipse workaround
+#else
     slot = untweakSlot(slot, framePtr);     // Eclipse workaround
+#endif
 
     switch (tag) {
     case JT_BOOLEAN:
@@ -2428,7 +2452,17 @@ void dvmDbgSetLocalValue(ObjectId threadId, FrameId frameId, int slot, u1 tag,
     case JT_DOUBLE:
     case JT_LONG:
         assert(width == 8);
+#ifdef WITH_TAINT_TRACKING
+	/* taint tag is interleaved */
+	{
+	    union { u8 ll; u4 parts[2]; } conv;
+	    conv.ll = value;
+	    framePtr[slot] = conv.parts[0];
+	    framePtr[slot+2] = conv.parts[1];
+	}
+#else
         *(u8*)(&framePtr[slot]) = value;
+#endif
         break;
     case JT_VOID:
     case JT_CLASS_OBJECT:
diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index 96f6dac..5e53165 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -26,6 +26,17 @@
 LOCAL_CFLAGS += -fstrict-aliasing -Wstrict-aliasing=2 -fno-align-jumps
 #LOCAL_CFLAGS += -DUSE_INDIRECT_REF
 
+# Turn on Taint Tracking
+ifeq ($(WITH_TAINT_TRACKING),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_TRACKING
+endif
+ifeq ($(TAINT_JNI_LOG),true)
+  LOCAL_CFLAGS += -DTAINT_JNI_LOG
+endif
+ifeq ($(WITH_TAINT_FAST),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_FAST
+endif
+
 #
 # Optional features.  These may impact the size or performance of the VM.
 #
@@ -194,6 +205,12 @@ LOCAL_SRC_FILES := \
 	test/TestHash.c \
 	test/TestIndirectRefTable.c
 
+ifeq ($(WITH_TAINT_TRACKING), true)
+    LOCAL_SRC_FILES += native/dalvik_system_Taint.c
+    LOCAL_SRC_FILES += tprop/TaintProp.c
+    LOCAL_SRC_FILES += tprop/TaintPolicy.c
+endif
+
 ifeq ($(WITH_JIT_TUNING),true)
   LOCAL_CFLAGS += -DWITH_JIT_TUNING
   # NOTE: Turn on assertion for JIT for now
@@ -247,6 +264,10 @@ LOCAL_C_INCLUDES += \
 	external/zlib \
 	$(KERNEL_HEADERS)
 
+# Taint tracking with file propagation
+ifeq ($(WITH_TAINT_TRACKING),true)
+    LOCAL_C_INCLUDES += dalvik/libattr
+endif
 
 ifeq ($(dvm_simulator),true)
   LOCAL_LDLIBS += -lpthread -ldl
@@ -329,3 +350,9 @@ LOCAL_SHARED_LIBRARIES += \
 
 LOCAL_STATIC_LIBRARIES += \
 	libdex
+
+# Taint tracking with file propagation
+ifeq ($(WITH_TAINT_TRACKING),true)
+    LOCAL_STATIC_LIBRARIES += libattr
+endif
+
diff --git a/vm/Init.c b/vm/Init.c
index c46de25..b3adcf5 100644
--- a/vm/Init.c
+++ b/vm/Init.c
@@ -187,6 +187,9 @@ static void dvmUsage(const char* progName)
 #if defined(WITH_JIT)
         " with_jit"
 #endif
+#ifdef WITH_TAINT_TRACKING
+	" taint_tracking"
+#endif
     );
 #ifdef DVM_SHOW_EXCEPTION
     dvmFprintf(stderr, " show_exception=%d", DVM_SHOW_EXCEPTION);
@@ -841,9 +844,17 @@ static int dvmProcessOptions(int argc, const char* const argv[],
             if (strcmp(argv[i] + 9, "none") == 0)
                 gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
             else if (strcmp(argv[i] + 9, "verified") == 0)
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+                gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
                 gDvm.dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
             else if (strcmp(argv[i] + 9, "all") == 0)
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+                gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
                 gDvm.dexOptMode = OPTIMIZE_MODE_ALL;
+#endif
             else {
                 dvmFprintf(stderr, "Unrecognized dexopt option '%s'\n",argv[i]);
                 return -1;
@@ -998,7 +1009,11 @@ static void setCommandLineDefaults()
 
     /* default verification and optimization modes */
     gDvm.classVerifyMode = VERIFY_MODE_ALL;
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     gDvm.dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
 
     /*
      * Default execution mode.
@@ -1020,6 +1035,9 @@ static void setCommandLineDefaults()
 #else
     gDvm.executionMode = kExecutionModeInterpFast;
 #endif
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_FAST)
+    gDvm.executionMode = kExecutionModeInterpPortable;
+#endif
 }
 
 
diff --git a/vm/Jni.c b/vm/Jni.c
index 10afcaa..f99d323 100644
--- a/vm/Jni.c
+++ b/vm/Jni.c
@@ -410,6 +410,10 @@ bool dvmJniStartup(void)
         return false;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniStartup();
+#endif
+
     return true;
 }
 
@@ -423,6 +427,10 @@ void dvmJniShutdown(void)
 #else
     dvmClearReferenceTable(&gDvm.jniGlobalRefTable);
 #endif
+
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniShutdown();
+#endif
 }
 
 
@@ -1546,6 +1554,10 @@ void dvmCallJNIMethod_general(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(env, pResult, method, self);
@@ -1605,6 +1617,10 @@ void dvmCallJNIMethod_virtualNoRef(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(self->jniEnv, pResult, method, self);
@@ -1639,6 +1655,10 @@ void dvmCallJNIMethod_staticNoRef(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(self->jniEnv, pResult, method, self);
diff --git a/vm/Native.c b/vm/Native.c
index 31832c2..50b4ace 100644
--- a/vm/Native.c
+++ b/vm/Native.c
@@ -447,6 +447,17 @@ bool dvmLoadNativeCode(const char* pathName, Object* classLoader)
 
     LOGD("Trying to load lib %s %p\n", pathName, classLoader);
 
+#ifdef WITH_TAINT_TRACKING
+    if (strncmp(pathName, "/system", 7) != 0) {
+	LOGW("Denying lib %s (not \"/system\" prefix)\n", pathName);
+	return false;
+    }
+    if (strstr(pathName, "/../") != NULL) {
+	LOGW("Denying lib %s (contains \"/../\")\n", pathName);
+	return false;
+    }
+#endif
+
     /*
      * See if we've already loaded it.  If we have, and the class loader
      * matches, return successfully without doing anything.
diff --git a/vm/Thread.c b/vm/Thread.c
index be3e952..abd297c 100644
--- a/vm/Thread.c
+++ b/vm/Thread.c
@@ -3636,6 +3636,10 @@ static void gcScanInterpStackReferences(Thread *thread)
                 /* conservative scan */
                 for (i = method->registersSize - 1; i >= 0; i--) {
                     u4 rval = *framePtr++;
+#ifdef WITH_TAINT_TRACKING
+		    /* taint tags are interleaved, jump over the tag */
+		    framePtr++;
+#endif
                     if (rval != 0 && (rval & 0x3) == 0) {
                         dvmMarkIfObject((Object *)rval);
                     }
@@ -3652,6 +3656,10 @@ static void gcScanInterpStackReferences(Thread *thread)
                 u2 bits = 1 << 1;
                 for (i = method->registersSize - 1; i >= 0; i--) {
                     u4 rval = *framePtr++;
+#ifdef WITH_TAINT_TRACKING
+		    /* taint tags are interleaved, jump over the tag */
+		    framePtr++;
+#endif
 
                     bits >>= 1;
                     if (bits == 1) {
diff --git a/vm/Thread.h b/vm/Thread.h
index 1bb5314..1415812 100644
--- a/vm/Thread.h
+++ b/vm/Thread.h
@@ -73,9 +73,15 @@ void dvmSlayDaemons(void);
 #define kInternalRefDefault     32      /* equally arbitrary */
 #define kInternalRefMax         4096    /* mainly a sanity check */
 
+#ifdef WITH_TAINT_TRACKING
+# define kMinStackSize       (1024 + STACK_OVERFLOW_RESERVE)
+# define kDefaultStackSize   (24*1024)    /* six 4K pages */
+# define kMaxStackSize       (512*1024 + STACK_OVERFLOW_RESERVE)
+#else
 #define kMinStackSize       (512 + STACK_OVERFLOW_RESERVE)
 #define kDefaultStackSize   (12*1024)   /* three 4K pages */
 #define kMaxStackSize       (256*1024 + STACK_OVERFLOW_RESERVE)
+#endif
 
 /*
  * System thread state. See native/SystemThread.h.
diff --git a/vm/interp/Interp.c b/vm/interp/Interp.c
index 233ee3f..fb1e5c3 100644
--- a/vm/interp/Interp.c
+++ b/vm/interp/Interp.c
@@ -280,7 +280,11 @@ Object* dvmGetThisPtr(const Method* method, const u4* fp)
 {
     if (dvmIsStaticMethod(method))
         return NULL;
+#ifdef WITH_TAINT_TRACKING
+    return (Object*)fp[(method->registersSize - method->insSize)<<1];
+#else
     return (Object*)fp[method->registersSize - method->insSize];
+#endif
 }
 
 
@@ -340,7 +344,11 @@ void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly)
     for (i = method->registersSize-1; i >= 0; i--) {
         if (i >= localCount) {
             LOG(LOG_VERBOSE, LOG_TAG"i", "  v%-2d in%-2d : 0x%08x\n",
+#ifdef WITH_TAINT_TRACKING
+                i, i-localCount, framePtr[i<<1]);
+#else
                 i, i-localCount, framePtr[i]);
+#endif
         } else {
             if (inOnly) {
                 LOG(LOG_VERBOSE, LOG_TAG"i", "  [...]\n");
@@ -361,7 +369,11 @@ void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly)
             }
 #endif
             LOG(LOG_VERBOSE, LOG_TAG"i", "  v%-2d      : 0x%08x %s\n",
+#ifdef WITH_TAINT_TRACKING
+                i, framePtr[i<<1], name);
+#else
                 i, framePtr[i], name);
+#endif
         }
     }
 }
@@ -609,6 +621,11 @@ bool dvmInterpHandleFillArrayData(ArrayObject* arrayObj, const u2* arrayData)
         return false;
     }
     copySwappedArrayData(arrayObj->contents, &arrayData[4], size, width);
+#ifdef WITH_TAINT_TRACKING
+    if (arrayObj->length == size) {
+	arrayObj->taint.tag = TAINT_CLEAR;
+    }
+#endif
     return true;
 }
 
@@ -885,7 +902,11 @@ void dvmThrowVerificationError(const Method* method, int kind, int ref)
  * The interpreted stack frame, which holds the method arguments, has
  * already been set up.
  */
+#ifdef WITH_TAINT_TRACKING
+void dvmInterpret(Thread* self, const Method* method, JValue* pResult, u4* rtaint)
+#else
 void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
+#endif
 {
     InterpState interpState;
     bool change;
@@ -939,6 +960,9 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
      *
      * No need to initialize "retval".
      */
+#ifdef WITH_TAINT_TRACKING
+    interpState.rtaint.tag = TAINT_CLEAR;
+#endif
     interpState.method = method;
     interpState.fp = (u4*) self->curFrame;
     interpState.pc = method->insns;
@@ -998,4 +1022,7 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
     }
 
     *pResult = interpState.retval;
+#ifdef WITH_TAINT_TRACKING
+    *rtaint = interpState.rtaint.tag;
+#endif
 }
diff --git a/vm/interp/Interp.h b/vm/interp/Interp.h
index cd4c7ec..99ea803 100644
--- a/vm/interp/Interp.h
+++ b/vm/interp/Interp.h
@@ -23,7 +23,11 @@
  * Interpreter entry point.  Call here after setting up the interpreted
  * stack (most code will want to get here via dvmCallMethod().)
  */
+#ifdef WITH_TAINT_TRACKING
+void dvmInterpret(Thread* thread, const Method* method, JValue* pResult, u4* rtaint);
+#else
 void dvmInterpret(Thread* thread, const Method* method, JValue* pResult);
+#endif
 
 /*
  * Throw an exception for a problem detected by the verifier.
diff --git a/vm/interp/InterpDefs.h b/vm/interp/InterpDefs.h
index c9c80e3..6923ea4 100644
--- a/vm/interp/InterpDefs.h
+++ b/vm/interp/InterpDefs.h
@@ -24,6 +24,10 @@
 #ifndef _DALVIK_INTERP_DEFS
 #define _DALVIK_INTERP_DEFS
 
+#ifdef WITH_TAINT_TRACKING
+#include "interp/Taint.h"
+#endif
+
 
 /*
  * Specify the starting point when switching between interpreters.
@@ -90,6 +94,10 @@ typedef struct InterpState {
     u4*         fp;                     // frame pointer
 
     JValue      retval;                 // return value -- "out" only
+#ifdef WITH_TAINT_TRACKING
+    Taint       rtaint;			// return taint value
+#endif /* WITH_TAINT_TRACKING */
+
     const Method* method;               // method being executed
 
 
diff --git a/vm/interp/Stack.c b/vm/interp/Stack.c
index 5920cbc..c9c36f1 100644
--- a/vm/interp/Stack.c
+++ b/vm/interp/Stack.c
@@ -65,9 +65,16 @@ static bool dvmPushInterpFrame(Thread* self, const Method* method)
     assert(!dvmIsNativeMethod(method));
     assert(!dvmIsAbstractMethod(method));
 
+#ifdef WITH_TAINT_TRACKING
+    /* taint tags are interleaved, plus "native hack" spacer for args */
+    stackReq = method->registersSize * 8 + 4       // params + locals
+                + sizeof(StackSaveArea) * 2     // break frame + regular frame
+                + method->outsSize * 8 + 4;         // args to other methods
+# else
     stackReq = method->registersSize * 4        // params + locals
                 + sizeof(StackSaveArea) * 2     // break frame + regular frame
                 + method->outsSize * 4;         // args to other methods
+#endif
 
     if (self->curFrame != NULL)
         stackPtr = (u1*) SAVEAREA_FROM_FP(self->curFrame);
@@ -91,13 +98,22 @@ static bool dvmPushInterpFrame(Thread* self, const Method* method)
      */
     stackPtr -= sizeof(StackSaveArea);
     breakSaveBlock = (StackSaveArea*)stackPtr;
+#ifdef WITH_TAINT_TRACKING
+    /* interleaved taint tracking plus "native hack" spacer for args */
+    stackPtr -= method->registersSize * 8 + 4 + sizeof(StackSaveArea);
+#else
     stackPtr -= method->registersSize * 4 + sizeof(StackSaveArea);
+#endif
     saveBlock = (StackSaveArea*) stackPtr;
 
 #if !defined(NDEBUG) && !defined(PAD_SAVE_AREA)
     /* debug -- memset the new stack, unless we want valgrind's help */
+#ifdef WITH_TAINT_TRACKING
+    memset(stackPtr - (method->outsSize*8+4), 0xaf, stackReq);
+#else
     memset(stackPtr - (method->outsSize*4), 0xaf, stackReq);
 #endif
+#endif
 #ifdef EASY_GDB
     breakSaveBlock->prevSave = FP_FROM_SAVEAREA(self->curFrame);
     saveBlock->prevSave = breakSaveBlock;
@@ -139,8 +155,14 @@ bool dvmPushJNIFrame(Thread* self, const Method* method)
 
     assert(dvmIsNativeMethod(method));
 
+#ifdef WITH_TAINT_TRACKING
+    /* Interleaved taint tags plus "native hack" spacer */
+    stackReq = method->registersSize * 8 + 4    // params only
+                + sizeof(StackSaveArea) * 2;    // break frame + regular frame
+#else
     stackReq = method->registersSize * 4        // params only
                 + sizeof(StackSaveArea) * 2;    // break frame + regular frame
+#endif
 
     if (self->curFrame != NULL)
         stackPtr = (u1*) SAVEAREA_FROM_FP(self->curFrame);
@@ -165,7 +187,12 @@ bool dvmPushJNIFrame(Thread* self, const Method* method)
      */
     stackPtr -= sizeof(StackSaveArea);
     breakSaveBlock = (StackSaveArea*)stackPtr;
+#ifdef WITH_TAINT_TRACKING
+    /* interleaved taint tags plus "native hack" spacer */
+    stackPtr -= method->registersSize * 8 + 4 + sizeof(StackSaveArea);
+#else
     stackPtr -= method->registersSize * 4 + sizeof(StackSaveArea);
+#endif
     saveBlock = (StackSaveArea*) stackPtr;
 
 #if !defined(NDEBUG) && !defined(PAD_SAVE_AREA)
@@ -453,12 +480,28 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
     ClassObject* clazz;
     u4* ins;
 
+#ifdef WITH_TAINT_TRACKING
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+#endif
+
     clazz = callPrep(self, method, obj, false);
     if (clazz == NULL)
         return;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((u4*)self->curFrame) + 
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
 
     //LOGD("  FP is %p, INs live at >= %p\n", self->curFrame, ins);
 
@@ -468,6 +511,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
         assert(obj != NULL && dvmIsValidObject(obj));
 #endif
         *ins++ = (u4) obj;
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -477,7 +526,19 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
             case 'D': case 'J': {
                 u8 val = va_arg(args, u8);
                 memcpy(ins, &val, 8);       // EABI prevents direct store
+#ifdef WITH_TAINT_TRACKING
+		if (nativeTarget) {
+		    ins += 2;
+		} else { /* adjust for taint tag interleaving */
+		    ins[2] = ins[1];
+		    ins[1] = TAINT_CLEAR;
+		    ins[3] = TAINT_CLEAR;
+		    ins += 4;
+		}
+		slot_cnt += 2;
+#else
                 ins += 2;
+#endif
                 verifyCount += 2;
                 break;
             }
@@ -485,6 +546,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
                 /* floats were normalized to doubles; convert back */
                 float f = (float) va_arg(args, double);
                 *ins++ = dvmFloatToU4(f);
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
@@ -495,18 +562,43 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
                     *ins++ = (u4) dvmDecodeIndirectRef(env, argObj);
                 else
                     *ins++ = (u4) argObj;
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
             default: {
                 /* Z B C S I -- all passed as 32-bit integers */
                 *ins++ = va_arg(args, u4);
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
         }
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	}
+    }
+#endif
+
 #ifndef NDEBUG
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
@@ -531,7 +623,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
         TRACE_METHOD_EXIT(self, method);
 #endif
     } else {
+#ifdef WITH_TAINT_TRACKING
+	u4 rtaint; /* not used */
+        dvmInterpret(self, method, pResult, &rtaint);
+#else
         dvmInterpret(self, method, pResult);
+#endif
     }
 
 bail:
@@ -559,17 +656,39 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
     ClassObject* clazz;
     u4* ins;
 
+#ifdef WITH_TAINT_TRACKING
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+#endif
+
     clazz = callPrep(self, method, obj, false);
     if (clazz == NULL)
         return;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((u4*)self->curFrame) + 
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
 
     /* put "this" pointer into in0 if appropriate */
     if (!dvmIsStaticMethod(method)) {
         assert(obj != NULL);
         *ins++ = (u4) obj;              /* obj is a "real" ref */
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -579,7 +698,19 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         case 'D':                       /* 64-bit quantity; have to use */
         case 'J':                       /*  memcpy() in case of mis-alignment */
             memcpy(ins, &args->j, 8);
-            ins += 2;
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		ins += 2;
+	    } else { /* adjust for taint tag interleaving */
+		ins[2] = ins[1];
+		ins[1] = TAINT_CLEAR;
+		ins[3] = TAINT_CLEAR;
+		ins += 4;
+	    }
+	    slot_cnt += 2;
+#else
+	    ins += 2;
+#endif
             verifyCount++;              /* this needs an extra push */
             break;
         case 'L':                       /* includes array refs */
@@ -587,22 +718,58 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
                 *ins++ = (u4) dvmDecodeIndirectRef(env, args->l);
             else
                 *ins++ = (u4) args->l;
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'F':
         case 'I':
             *ins++ = args->i;           /* full 32 bits */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'S':
             *ins++ = args->s;           /* 16 bits, sign-extended */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'C':
             *ins++ = args->c;           /* 16 bits, unsigned */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'B':
             *ins++ = args->b;           /* 8 bits, sign-extended */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'Z':
             *ins++ = args->z;           /* 8 bits, zero or non-zero */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         default:
             LOGE("Invalid char %c in short signature of %s.%s\n",
@@ -615,6 +782,19 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         args++;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	}
+    }
+#endif
+
 #ifndef NDEBUG
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
@@ -637,7 +817,12 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         TRACE_METHOD_EXIT(self, method);
 #endif
     } else {
+#ifdef WITH_TAINT_TRACKING
+	u4 rtaint; /* not used */
+        dvmInterpret(self, method, pResult, &rtaint);
+#else
         dvmInterpret(self, method, pResult);
+#endif
     }
 
 bail:
@@ -666,6 +851,17 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     int verifyCount, argListLength;
     JValue retval;
 
+#ifdef WITH_TAINT_TRACKING
+    u4 rtaint = TAINT_CLEAR;
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+    /* For simplicity, argument tags for native targets
+     * are unioned. This may cause false positives, but
+     * it is the easiest way to handle this for now.
+     */
+    u4 nativeTag = TAINT_CLEAR;
+#endif
+
     /* verify arg count */
     if (argList != NULL)
         argListLength = argList->length;
@@ -684,7 +880,18 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
         return NULL;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((s4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((s4*)self->curFrame) + 
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((s4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
     verifyCount = 0;
 
     //LOGD("  FP is %p, INs live at >= %p\n", self->curFrame, ins);
@@ -693,6 +900,12 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     if (!dvmIsStaticMethod(method)) {
         assert(obj != NULL);
         *ins++ = (s4) obj;
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -708,7 +921,9 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     types = (ClassObject**) params->contents;
     for (i = 0; i < argListLength; i++) {
         int width;
-
+#ifdef WITH_TAINT_TRACKING
+	int tag = dvmGetPrimitiveTaint(*args, *types);
+#endif
         width = dvmConvertArgument(*args++, *types++, ins);
         if (width < 0) {
             if (*(args-1) != NULL) {
@@ -722,10 +937,47 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
             goto bail_popped;
         }
 
+#ifdef WITH_TAINT_TRACKING
+	/* dvmConvertArgument() returns -1, 1, or 2 */
+	if (nativeTarget) {
+	    nativeTag |= tag; /* TODO: is there a better way to do this?*/
+	    ins += width;
+	} else {
+	    if (width == 2) {
+		ins[2] = ins[1];
+		ins[1] = tag;
+		ins[3] = tag;
+		ins += 4;
+	    } else if (width == 1) {
+		ins[1] = tag;
+		ins += 2;
+	    } else { /* error condition duplicated from above */
+		dvmPopFrame(self);
+		dvmThrowException("Ljava/lang/IllegalArgumentException;",
+		    "argument type mismatch");
+		goto bail_popped;
+	    }
+	}
+	slot_cnt += width;
+#else
         ins += width;
+#endif
         verifyCount += width;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = nativeTag; /* TODO: better way? */
+	    }
+	}
+    }
+#endif
+
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
             method->insSize, clazz->descriptor, method->name);
@@ -746,8 +998,15 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
 #ifdef WITH_PROFILER
         TRACE_METHOD_EXIT(self, method);
 #endif
+#ifdef WITH_TAINT_TRACKING
+	rtaint = ((u4*)self->curFrame)[slot_cnt];
+#endif
     } else {
+#ifdef WITH_TAINT_TRACKING
+        dvmInterpret(self, method, &retval, &rtaint);
+#else
         dvmInterpret(self, method, &retval);
+#endif
     }
 
     /*
@@ -770,6 +1029,9 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
          */
         if (returnType != NULL) {
             retObj = (Object*)dvmWrapPrimitive(retval, returnType);
+#ifdef WITH_TAINT_TRACKING
+	    dvmSetPrimitiveTaint(retObj, returnType, rtaint);
+#endif
             dvmReleaseTrackedAlloc(retObj, NULL);
         }
     }
diff --git a/vm/interp/Stack.h b/vm/interp/Stack.h
index 22f066f..bf466a7 100644
--- a/vm/interp/Stack.h
+++ b/vm/interp/Stack.h
@@ -162,11 +162,21 @@ struct StackSaveArea {
 #define FP_FROM_SAVEAREA(_save) ((void*) ((StackSaveArea*)(_save) +1))
 
 /* when calling a function, get a pointer to outs[0] */
+#ifdef WITH_TAINT_TRACKING
+#define OUTS_FROM_FP(_fp, _argCount) \
+    ((u4*) ((u1*)SAVEAREA_FROM_FP(_fp) - \
+	( ((sizeof(u4) * (_argCount))<<1) +4) ))
+#else /* ndef WITH_TAINT_TRACKING */
 #define OUTS_FROM_FP(_fp, _argCount) \
     ((u4*) ((u1*)SAVEAREA_FROM_FP(_fp) - sizeof(u4) * (_argCount)))
+#endif /* WITH_TAINT_TRACKING */
 
 /* reserve this many bytes for handling StackOverflowError */
-#define STACK_OVERFLOW_RESERVE  512
+#ifdef WITH_TAINT_TRACKING
+# define STACK_OVERFLOW_RESERVE  1024
+#else
+# define STACK_OVERFLOW_RESERVE  512
+#endif
 
 /*
  * Determine if the frame pointer points to a "break frame".
diff --git a/vm/interp/Taint.h b/vm/interp/Taint.h
new file mode 100644
index 0000000..7621c63
--- /dev/null
+++ b/vm/interp/Taint.h
@@ -0,0 +1,50 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Dalvik interpreter public definitions.
+ */
+#ifndef _DALVIK_INTERP_TAINT
+#define _DALVIK_INTERP_TAINT
+
+/* The Taint structure */
+typedef struct Taint {
+    u4 tag;
+} Taint;
+
+/* The Taint markings */
+
+#define TAINT_CLEAR         ((u4)0x00000000) /* No taint */
+#define TAINT_LOCATION      ((u4)0x00000001) /* Location */
+#define TAINT_CONTACTS      ((u4)0x00000002) /* Address Book (ContactsProvider) */
+#define TAINT_MIC           ((u4)0x00000004) /* Microphone Input */
+#define TAINT_PHONE_NUMBER  ((u4)0x00000008) /* Phone Number */
+#define TAINT_LOCATION_GPS  ((u4)0x00000010) /* GPS Location */
+#define TAINT_LOCATION_NET  ((u4)0x00000020) /* NET-based Location */
+#define TAINT_LOCATION_LAST ((u4)0x00000040) /* Last known Location */
+#define TAINT_CAMERA        ((u4)0x00000080) /* camera */
+#define TAINT_ACCELEROMETER ((u4)0x00000100) /* accelerometer */
+#define TAINT_SMS           ((u4)0x00000200) /* SMS */
+#define TAINT_IMEI          ((u4)0x00000400) /* IMEI */
+#define TAINT_IMSI          ((u4)0x00000800) /* IMSI */
+#define TAINT_ICCID         ((u4)0x00001000) /* ICCID (SIM card identifier) */
+#define TAINT_DEVICE_SN     ((u4)0x00002000) /* Device serial number */
+#define TAINT_ACCOUNT       ((u4)0x00004000) /* User account information */
+#define TAINT_HISTORY       ((u4)0x00008000) /* browser history */
+
+#endif /*_DALVIK_INTERP_TAINT*/
diff --git a/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE.S
new file mode 100644
index 0000000..792f933
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide.S" {"instr":"faddd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..0d9d762
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_ADD_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide2addr.S" {"instr":"faddd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT.S
new file mode 100644
index 0000000..b682616
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop.S" {"instr":"fadds   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT_2ADDR.S
new file mode 100644
index 0000000..7c440b6
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_ADD_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop2addr.S" {"instr":"fadds   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_CMPG_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_CMPG_DOUBLE.S
new file mode 100644
index 0000000..b24db9c
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_CMPG_DOUBLE.S
@@ -0,0 +1,54 @@
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * int compare(x, y) {
+     *     if (x == y) {
+     *         return 0;
+     *     } else if (x < y) {
+     *         return -1;
+     *     } else if (x > y) {
+     *         return 1;
+     *     } else {
+     *         return 1;
+     *     }
+     * }
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
+    fcmped  d0, d1                      @ compare (vBB, vCC)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    mov     r0, #1                      @ r0<- 1 (default)
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    b       .L${opcode}_finish          @ argh
+
+%break
+.L${opcode}_finish:
+    fmstat                              @ export status flags
+    mvnmi   r0, #0                      @ (less than) r1<- -1
+    moveq   r0, #0                      @ (equal) r1<- 0
+    SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/arm-vfp_taint/OP_CMPG_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_CMPG_FLOAT.S
new file mode 100644
index 0000000..303a59f
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_CMPG_FLOAT.S
@@ -0,0 +1,48 @@
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * int compare(x, y) {
+     *     if (x == y) {
+     *         return 0;
+     *     } else if (x < y) {
+     *         return -1;
+     *     } else if (x > y) {
+     *         return 1;
+     *     } else {
+     *         return 1;
+     *     }
+     * }
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+    flds    s0, [r2]                    @ s0<- vBB
+    flds    s1, [r3]                    @ s1<- vCC
+    fcmpes  s0, s1                      @ compare (vBB, vCC)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    mov     r0, #1                      @ r0<- 1 (default)
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fmstat                              @ export status flags
+    mvnmi   r0, #0                      @ (less than) r1<- -1
+    moveq   r0, #0                      @ (equal) r1<- 0
+    b       .L${opcode}_finish          @ argh
+
+%break
+.L${opcode}_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/arm-vfp_taint/OP_CMPL_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_CMPL_DOUBLE.S
new file mode 100644
index 0000000..f02a6df
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_CMPL_DOUBLE.S
@@ -0,0 +1,54 @@
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * int compare(x, y) {
+     *     if (x == y) {
+     *         return 0;
+     *     } else if (x > y) {
+     *         return 1;
+     *     } else if (x < y) {
+     *         return -1;
+     *     } else {
+     *         return -1;
+     *     }
+     * }
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
+    fcmped  d0, d1                      @ compare (vBB, vCC)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    mvn     r0, #0                      @ r0<- -1 (default)
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    b       .L${opcode}_finish          @ argh
+
+%break
+.L${opcode}_finish:
+    fmstat                              @ export status flags
+    movgt   r0, #1                      @ (greater than) r1<- 1
+    moveq   r0, #0                      @ (equal) r1<- 0
+    SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/arm-vfp_taint/OP_CMPL_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_CMPL_FLOAT.S
new file mode 100644
index 0000000..9cc54c2
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_CMPL_FLOAT.S
@@ -0,0 +1,48 @@
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * int compare(x, y) {
+     *     if (x == y) {
+     *         return 0;
+     *     } else if (x > y) {
+     *         return 1;
+     *     } else if (x < y) {
+     *         return -1;
+     *     } else {
+     *         return -1;
+     *     }
+     * }
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+    flds    s0, [r2]                    @ s0<- vBB
+    flds    s1, [r3]                    @ s1<- vCC
+    fcmpes  s0, s1                      @ compare (vBB, vCC)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    mvn     r0, #0                      @ r0<- -1 (default)
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fmstat                              @ export status flags
+    movgt   r0, #1                      @ (greater than) r1<- 1
+    moveq   r0, #0                      @ (equal) r1<- 0
+    b       .L${opcode}_finish          @ argh
+
+%break
+.L${opcode}_finish:
+    SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE.S
new file mode 100644
index 0000000..e0090dd
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide.S" {"instr":"fdivd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..508bfa1
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DIV_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide2addr.S" {"instr":"fdivd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT.S
new file mode 100644
index 0000000..3a89320
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop.S" {"instr":"fdivs   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT_2ADDR.S
new file mode 100644
index 0000000..d2b6a1b
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DIV_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop2addr.S" {"instr":"fdivs   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S
new file mode 100644
index 0000000..818fa1d
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funopNarrower.S" {"instr":"fcvtsd  s0, d0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_INT.S b/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_INT.S
new file mode 100644
index 0000000..2051f4c
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_DOUBLE_TO_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funopNarrower.S" {"instr":"ftosizd  s0, d0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_DOUBLE.S
new file mode 100644
index 0000000..517fd38
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funopWider.S" {"instr":"fcvtds  d0, s0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_INT.S b/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_INT.S
new file mode 100644
index 0000000..bbe2962
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_FLOAT_TO_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funop.S" {"instr":"ftosizs s1, s0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_INT_TO_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_INT_TO_DOUBLE.S
new file mode 100644
index 0000000..5c73b4b
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_INT_TO_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funopWider.S" {"instr":"fsitod  d0, s0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_INT_TO_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_INT_TO_FLOAT.S
new file mode 100644
index 0000000..875ffda
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_INT_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/funop.S" {"instr":"fsitos  s1, s0"}
diff --git a/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE.S
new file mode 100644
index 0000000..091e651
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide.S" {"instr":"fmuld   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..2434392
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_MUL_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide2addr.S" {"instr":"fmuld   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT.S
new file mode 100644
index 0000000..1d1b183
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop.S" {"instr":"fmuls   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT_2ADDR.S
new file mode 100644
index 0000000..54fe3d3
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_MUL_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop2addr.S" {"instr":"fmuls   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE.S b/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE.S
new file mode 100644
index 0000000..0d07ce7
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide.S" {"instr":"fsubd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..e520f3e
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_SUB_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinopWide2addr.S" {"instr":"fsubd   d2, d0, d1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT.S b/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT.S
new file mode 100644
index 0000000..527eee1
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop.S" {"instr":"fsubs   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT_2ADDR.S b/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT_2ADDR.S
new file mode 100644
index 0000000..7cc350b
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/OP_SUB_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "arm-vfp_taint/fbinop2addr.S" {"instr":"fsubs   s2, s0, s1"}
diff --git a/vm/mterp/arm-vfp_taint/fbinop.S b/vm/mterp/arm-vfp_taint/fbinop.S
new file mode 100644
index 0000000..257feca
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/fbinop.S
@@ -0,0 +1,35 @@
+    /*
+     * Generic 32-bit floating-point operation.  Provide an "instr" line that
+     * specifies an instruction that performs "s2 = s0 op s1".  Because we
+     * use the "softfp" ABI, this must be an instruction, not a function call.
+     *
+     * For: add-float, sub-float, mul-float, div-float
+     */
+    /* floatop vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    mov     r3, r0, lsr #8              @ r3<- CC
+    and     r2, r0, #255                @ r2<- BB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+    flds    s1, [r3]                    @ s1<- vCC
+    flds    s0, [r2]                    @ s0<- vBB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    $instr                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/arm-vfp_taint/fbinop2addr.S b/vm/mterp/arm-vfp_taint/fbinop2addr.S
new file mode 100644
index 0000000..fe99402
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/fbinop2addr.S
@@ -0,0 +1,34 @@
+    /*
+     * Generic 32-bit floating point "/2addr" binary operation.  Provide
+     * an "instr" line that specifies an instruction that performs
+     * "s2 = s0 op s1".
+     *
+     * For: add-float/2addr, sub-float/2addr, mul-float/2addr, div-float/2addr
+     */
+    /* binop/2addr vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
+    and     r9, r9, #15                 @ r9<- A
+    flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    flds    s0, [r9]                    @ s0<- vA
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    $instr                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/arm-vfp_taint/fbinopWide.S b/vm/mterp/arm-vfp_taint/fbinopWide.S
new file mode 100644
index 0000000..c04e5fd
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/fbinopWide.S
@@ -0,0 +1,41 @@
+    /*
+     * Generic 64-bit double-precision floating point binary operation.
+     * Provide an "instr" line that specifies an instruction that performs
+     * "d2 = d0 op d1".
+     *
+     * for: add-double, sub-double, mul-double, div-double
+     */
+    /* doubleop vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    mov     r3, r0, lsr #8              @ r3<- CC
+    and     r2, r0, #255                @ r2<- BB
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
+    VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    $instr                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/arm-vfp_taint/fbinopWide2addr.S b/vm/mterp/arm-vfp_taint/fbinopWide2addr.S
new file mode 100644
index 0000000..480797b
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/fbinopWide2addr.S
@@ -0,0 +1,42 @@
+    /*
+     * Generic 64-bit floating point "/2addr" binary operation.  Provide
+     * an "instr" line that specifies an instruction that performs
+     * "d2 = d0 op d1".
+     *
+     * For: add-double/2addr, sub-double/2addr, mul-double/2addr,
+     *      div-double/2addr
+     */
+    /* binop/2addr vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
+    and     r9, r9, #15                 @ r9<- A
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    $instr                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/arm-vfp_taint/funop.S b/vm/mterp/arm-vfp_taint/funop.S
new file mode 100644
index 0000000..0db2c31
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/funop.S
@@ -0,0 +1,24 @@
+    /*
+     * Generic 32-bit unary floating-point operation.  Provide an "instr"
+     * line that specifies an instruction that performs "s1 = op s0".
+     *
+     * for: int-to-float, float-to-int
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
+    flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    and     r9, r9, #15                 @ r9<- A
+    $instr                              @ s1<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
+    fsts    s1, [r9]                    @ vA<- s1
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/arm-vfp_taint/funopNarrower.S b/vm/mterp/arm-vfp_taint/funopNarrower.S
new file mode 100644
index 0000000..325866b
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/funopNarrower.S
@@ -0,0 +1,26 @@
+    /*
+     * Generic 64bit-to-32bit unary floating point operation.  Provide an
+     * "instr" line that specifies an instruction that performs "s0 = op d0".
+     *
+     * For: double-to-int, double-to-float
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r3]                    @ d0<- vB
+	flds	s0, [r3]
+	flds	s1, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    and     r9, r9, #15                 @ r9<- A
+    $instr                              @ s0<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
+    fsts    s0, [r9]                    @ vA<- s0
+// begin WITH_TAINT_TRACKING
+    str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/arm-vfp_taint/funopWider.S b/vm/mterp/arm-vfp_taint/funopWider.S
new file mode 100644
index 0000000..f996e81
--- /dev/null
+++ b/vm/mterp/arm-vfp_taint/funopWider.S
@@ -0,0 +1,27 @@
+    /*
+     * Generic 32bit-to-64bit floating point unary operation.  Provide an
+     * "instr" line that specifies an instruction that performs "d0 = op s0".
+     *
+     * For: int-to-double, float-to-double
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
+    flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    and     r9, r9, #15                 @ r9<- A
+    $instr                              @ d0<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
+// begin WITH_TAINT_TRACKING
+//    fstd    d0, [r9]                    @ vA<- d0
+	fsts	s0, [r9]
+	fsts	s1, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/armv5te_taint/OP_ADD_DOUBLE.S b/vm/mterp/armv5te_taint/OP_ADD_DOUBLE.S
new file mode 100644
index 0000000..12ada2e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_dadd"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_DOUBLE_2ADDR.S b/vm/mterp/armv5te_taint/OP_ADD_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..da778b5
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_dadd"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_FLOAT.S b/vm/mterp/armv5te_taint/OP_ADD_FLOAT.S
new file mode 100644
index 0000000..36b2f72
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"bl      __aeabi_fadd"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_FLOAT_2ADDR.S b/vm/mterp/armv5te_taint/OP_ADD_FLOAT_2ADDR.S
new file mode 100644
index 0000000..de888fd
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      __aeabi_fadd"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_INT.S b/vm/mterp/armv5te_taint/OP_ADD_INT.S
new file mode 100644
index 0000000..511e28a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"add     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_ADD_INT_2ADDR.S
new file mode 100644
index 0000000..7acc7cd
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"add     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_ADD_INT_LIT16.S
new file mode 100644
index 0000000..c34fa47
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_INT_LIT16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit16.S" {"instr":"add     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_ADD_INT_LIT8.S
new file mode 100644
index 0000000..9548c6d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"add     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_LONG.S b/vm/mterp/armv5te_taint/OP_ADD_LONG.S
new file mode 100644
index 0000000..84a63d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"preinstr":"adds    r0, r0, r2", "instr":"adc     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_ADD_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_ADD_LONG_2ADDR.S
new file mode 100644
index 0000000..4aed731
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ADD_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"preinstr":"adds    r0, r0, r2", "instr":"adc     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_AGET.S b/vm/mterp/armv5te_taint/OP_AGET.S
new file mode 100644
index 0000000..df06693
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET.S
@@ -0,0 +1,49 @@
+%default { "load":"ldr", "shift":"2" }
+%verify "executed"
+    /*
+     * Array get, 32 bits or less.  vAA <- vBB[vCC].
+     *
+     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17
+     * instructions.  We use a pair of FETCH_Bs instead.
+     *
+     * for: aget, aget-object, aget-boolean, aget-byte, aget-char, aget-short
+     */
+    /* op vAA, vBB, vCC */
+    FETCH_B(r2, 1, 0)                   @ r2<- BB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    FETCH_B(r3, 1, 1)                   @ r3<- CC
+    GET_VREG(r0, r2)                    @ r0<- vBB (array object)
+    GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
+    cmp     r0, #0                      @ null array object?
+    beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl		.L${opcode}_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+    add     r0, r0, r1, lsl #$shift     @ r0<- arrayObj + index*width
+    cmp     r1, r3                      @ compare unsigned index, length
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.L${opcode}_taint_prop_2
+// end WITH_TAINT_TRACKING
+	$load   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r2, r9)                    @ vAA<- r2
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+.L${opcode}_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.L${opcode}_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_AGET_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_AGET_BOOLEAN.S
new file mode 100644
index 0000000..a66a3e0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_BOOLEAN.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_AGET.S" { "load":"ldrb", "shift":"0" }
diff --git a/vm/mterp/armv5te_taint/OP_AGET_BYTE.S b/vm/mterp/armv5te_taint/OP_AGET_BYTE.S
new file mode 100644
index 0000000..bd84869
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_AGET.S" { "load":"ldrsb", "shift":"0" }
diff --git a/vm/mterp/armv5te_taint/OP_AGET_CHAR.S b/vm/mterp/armv5te_taint/OP_AGET_CHAR.S
new file mode 100644
index 0000000..6a7ee2a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_AGET.S" { "load":"ldrh", "shift":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_AGET_OBJECT.S b/vm/mterp/armv5te_taint/OP_AGET_OBJECT.S
new file mode 100644
index 0000000..42e9bdf
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_AGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_AGET_SHORT.S b/vm/mterp/armv5te_taint/OP_AGET_SHORT.S
new file mode 100644
index 0000000..1f49674
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_AGET.S" { "load":"ldrsh", "shift":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_AGET_WIDE.S b/vm/mterp/armv5te_taint/OP_AGET_WIDE.S
new file mode 100644
index 0000000..050bbf8
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AGET_WIDE.S
@@ -0,0 +1,49 @@
+%verify "executed"
+    /*
+     * Array get, 64 bits.  vAA <- vBB[vCC].
+     *
+     * Arrays of long/double are 64-bit aligned, so it's okay to use LDRD.
+     */
+    /* aget-wide vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r0, r2)                    @ r0<- vBB (array object)
+    GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
+    cmp     r0, #0                      @ null array object?
+    beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl		.L${opcode}_taint_prop		@ r10<- taint
+// end WITH_TAINT_TRACKING
+    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+    add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
+    cmp     r1, r3                      @ compare unsigned index, length
+    bcc     .L${opcode}_finish          @ okay, continue below
+    b       common_errArrayIndex        @ index >= length, bail
+    @ May want to swap the order of these two branches depending on how the
+    @ branch prediction (if any) handles conditional forward branches vs.
+    @ unconditional forward branches.
+%break
+
+.L${opcode}_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+    ldrd    r0, [r0, #offArrayObject_contents]  @ r0/r1<- vBB[vCC]
+    mov		r2, r1
+    mov		r1, r10
+    mov		r3, r10
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.L${opcode}_taint_prop:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r10, r3, r10)
+	orr		r10, r10, r2					@ r10<- r10 | r1
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_AND_INT.S b/vm/mterp/armv5te_taint/OP_AND_INT.S
new file mode 100644
index 0000000..43f5f30
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"and     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_AND_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_AND_INT_2ADDR.S
new file mode 100644
index 0000000..0d0f752
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"and     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_AND_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_AND_INT_LIT16.S
new file mode 100644
index 0000000..4b7095d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_INT_LIT16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit16.S" {"instr":"and     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_AND_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_AND_INT_LIT8.S
new file mode 100644
index 0000000..623b451
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"and     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_AND_LONG.S b/vm/mterp/armv5te_taint/OP_AND_LONG.S
new file mode 100644
index 0000000..5405aec
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"preinstr":"and     r0, r0, r2", "instr":"and     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_AND_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_AND_LONG_2ADDR.S
new file mode 100644
index 0000000..b82f491
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_AND_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"preinstr":"and     r0, r0, r2", "instr":"and     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_APUT.S b/vm/mterp/armv5te_taint/OP_APUT.S
new file mode 100644
index 0000000..a210d90
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT.S
@@ -0,0 +1,42 @@
+%default { "store":"str", "shift":"2" }
+%verify "executed"
+    /*
+     * Array put, 32 bits or less.  vBB[vCC] <- vAA.
+     *
+     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17
+     * instructions.  We use a pair of FETCH_Bs instead.
+     *
+     * for: aput, aput-boolean, aput-byte, aput-char, aput-short
+     */
+    /* op vAA, vBB, vCC */
+    FETCH_B(r2, 1, 0)                   @ r2<- BB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    FETCH_B(r3, 1, 1)                   @ r3<- CC
+    GET_VREG(r0, r2)                    @ r0<- vBB (array object)
+    GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
+    cmp     r0, #0                      @ null array object?
+    beq     common_errNullObject        @ yes, bail
+    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+    add     r0, r0, r1, lsl #$shift     @ r0<- arrayObj + index*width
+    cmp     r1, r3                      @ compare unsigned index, length
+    bcs     common_errArrayIndex        @ index >= length, bail
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    GET_VREG(r2, r9)                    @ r2<- vAA
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    $store  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+.L${opcode}_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_APUT_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_APUT_BOOLEAN.S
new file mode 100644
index 0000000..214709f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_BOOLEAN.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_APUT.S" { "store":"strb", "shift":"0" }
diff --git a/vm/mterp/armv5te_taint/OP_APUT_BYTE.S b/vm/mterp/armv5te_taint/OP_APUT_BYTE.S
new file mode 100644
index 0000000..214709f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_APUT.S" { "store":"strb", "shift":"0" }
diff --git a/vm/mterp/armv5te_taint/OP_APUT_CHAR.S b/vm/mterp/armv5te_taint/OP_APUT_CHAR.S
new file mode 100644
index 0000000..256251a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_APUT.S" { "store":"strh", "shift":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_APUT_OBJECT.S b/vm/mterp/armv5te_taint/OP_APUT_OBJECT.S
new file mode 100644
index 0000000..dd4395b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_OBJECT.S
@@ -0,0 +1,62 @@
+%verify "executed"
+    /*
+     * Store an object into an array.  vBB[vCC] <- vAA.
+     *
+     * Note: using the usual FETCH/and/shift stuff, this fits in exactly 17
+     * instructions.  We use a pair of FETCH_Bs instead.
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+    GET_VREG(r0, r3)                    @ r0<- vCC (requested index)
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_1
+// end WITH_TAINT_TRACKING
+    cmp     r1, #0                      @ null array object?
+    GET_VREG(r9, r9)                    @ r9<- vAA
+    beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_2
+// end WITH_TAINT_TRACKING
+    ldr     r3, [r1, #offArrayObject_length]    @ r3<- arrayObj->length
+    add     r10, r1, r0, lsl #2         @ r10<- arrayObj + index*width
+    cmp     r0, r3                      @ compare unsigned index, length
+    bcc     .L${opcode}_finish          @ we're okay, continue on
+    b       common_errArrayIndex        @ index >= length, bail
+
+%break
+    /*
+     * On entry:
+     *  r1 = vBB (arrayObj)
+     *  r9 = vAA (obj)
+     *  r10 = offset into array (vBB + vCC * width)
+     */
+.L${opcode}_finish:
+// begin WITH_TAINT_TRACKING
+	str		r2, [r1, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
+    cmp     r9, #0                      @ storing null reference?
+    beq     .L${opcode}_skip_check      @ yes, skip type checks
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    ldr     r1, [r1, #offObject_clazz]  @ r1<- arrayObj->clazz
+    bl      dvmCanPutArrayElement       @ test object type vs. array type
+    cmp     r0, #0                      @ okay?
+    beq     common_errArrayStore        @ no
+.L${opcode}_skip_check:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+aput_object_taint_prop_1:
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r2, r9, r3)
+	bx		lr
+
+aput_object_taint_prop_2:
+	ldr     r3, [r1, #offArrayObject_taint]
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_APUT_SHORT.S b/vm/mterp/armv5te_taint/OP_APUT_SHORT.S
new file mode 100644
index 0000000..256251a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_APUT.S" { "store":"strh", "shift":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_APUT_WIDE.S b/vm/mterp/armv5te_taint/OP_APUT_WIDE.S
new file mode 100644
index 0000000..c0f88c3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_APUT_WIDE.S
@@ -0,0 +1,48 @@
+%verify "executed"
+    /*
+     * Array put, 64 bits.  vBB[vCC] <- vAA.
+     *
+     * Arrays of long/double are 64-bit aligned, so it's okay to use STRD.
+     */
+    /* aput-wide vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r0, r2)                    @ r0<- vBB (array object)
+    GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
+    cmp     r0, #0                      @ null array object?
+    beq     common_errNullObject        @ yes, bail
+    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	mov		r10, r0
+// end WITH_TAINT_TRACKING
+    add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
+    cmp     r1, r3                      @ compare unsigned index, length
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    bcc     .L${opcode}_finish          @ okay, continue below
+    b       common_errArrayIndex        @ index >= length, bail
+    @ May want to swap the order of these two branches depending on how the
+    @ branch prediction (if any) handles conditional forward branches vs.
+    @ unconditional forward branches.
+%break
+
+.L${opcode}_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr		r2, [r9, #0]
+	ldr		r3, [r9, #8]
+	ldr		r1, [r9, #4]				@ r1<- array taint
+	ldr     r9, [r10, #offArrayObject_taint]
+	orr		r1, r1, r9					@ r1<- r1 | r9
+	str		r1, [r10, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_ARRAY_LENGTH.S b/vm/mterp/armv5te_taint/OP_ARRAY_LENGTH.S
new file mode 100644
index 0000000..2dfae73
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_ARRAY_LENGTH.S
@@ -0,0 +1,21 @@
+%verify "executed"
+    /*
+     * Return the length of an array.
+     */
+    mov     r1, rINST, lsr #12          @ r1<- B
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    GET_VREG(r0, r1)                    @ r0<- vB (object ref)
+    and     r2, r2, #15                 @ r2<- A
+    cmp     r0, #0                      @ is object null?
+    beq     common_errNullObject        @ yup, fail
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    ldr     r3, [r0, #offArrayObject_length]    @ r3<- array length
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r3, r2)                    @ vB<- length
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CHECK_CAST.S b/vm/mterp/armv5te_taint/OP_CHECK_CAST.S
new file mode 100644
index 0000000..74f458b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CHECK_CAST.S
@@ -0,0 +1,73 @@
+%verify "executed"
+%verify "null object"
+%verify "class cast exception thrown, with correct class name"
+%verify "class cast exception not thrown on same class"
+%verify "class cast exception not thrown on subclass"
+%verify "class not resolved"
+%verify "class already resolved"
+    /*
+     * Check to see if a cast from one class to another is allowed.
+     */
+    /* check-cast vAA, class@BBBB */
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH(r2, 1)                        @ r2<- BBBB
+    GET_VREG(r9, r3)                    @ r9<- object
+    ldr     r0, [rGLUE, #offGlue_methodClassDex]    @ r0<- pDvmDex
+    cmp     r9, #0                      @ is object null?
+    ldr     r0, [r0, #offDvmDex_pResClasses]    @ r0<- pDvmDex->pResClasses
+    beq     .L${opcode}_okay            @ null obj, cast always succeeds
+    ldr     r1, [r0, r2, lsl #2]        @ r1<- resolved class
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    cmp     r1, #0                      @ have we resolved this before?
+    beq     .L${opcode}_resolve         @ not resolved, do it now
+.L${opcode}_resolved:
+    cmp     r0, r1                      @ same class (trivial success)?
+    bne     .L${opcode}_fullcheck       @ no, do full check
+.L${opcode}_okay:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds class resolved from BBBB
+     *  r9 holds object
+     */
+.L${opcode}_fullcheck:
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    cmp     r0, #0                      @ failed?
+    bne     .L${opcode}_okay            @ no, success
+
+    @ A cast has failed.  We need to throw a ClassCastException with the
+    @ class of the object that failed to be cast.
+    EXPORT_PC()                         @ about to throw
+    ldr     r3, [r9, #offObject_clazz]  @ r3<- obj->clazz
+    ldr     r0, .LstrClassCastExceptionPtr
+    ldr     r1, [r3, #offClassObject_descriptor] @ r1<- obj->clazz->descriptor
+    bl      dvmThrowExceptionWithClassMessage
+    b       common_exceptionThrown
+
+    /*
+     * Resolution required.  This is the least-likely path.
+     *
+     *  r2 holds BBBB
+     *  r9 holds object
+     */
+.L${opcode}_resolve:
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    mov     r1, r2                      @ r1<- BBBB
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    beq     common_exceptionThrown      @ yes, handle exception
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
+    b       .L${opcode}_resolved        @ pick up where we left off
+
+.LstrClassCastExceptionPtr:
+    .word   .LstrClassCastException
+
diff --git a/vm/mterp/armv5te_taint/OP_CMPG_DOUBLE.S b/vm/mterp/armv5te_taint/OP_CMPG_DOUBLE.S
new file mode 100644
index 0000000..e338f66
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CMPG_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_CMPL_DOUBLE.S" { "naninst":"mov     r1, #1" }
diff --git a/vm/mterp/armv5te_taint/OP_CMPG_FLOAT.S b/vm/mterp/armv5te_taint/OP_CMPG_FLOAT.S
new file mode 100644
index 0000000..fd1ab1c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CMPG_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_CMPL_FLOAT.S" { "naninst":"mov     r1, #1" }
diff --git a/vm/mterp/armv5te_taint/OP_CMPL_DOUBLE.S b/vm/mterp/armv5te_taint/OP_CMPL_DOUBLE.S
new file mode 100644
index 0000000..be68ab4
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CMPL_DOUBLE.S
@@ -0,0 +1,69 @@
+%default { "naninst":"mvn     r1, #0" }
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * Provide a "naninst" instruction that puts 1 or -1 into r1 depending
+     * on what value we'd like to return when one of the operands is NaN.
+     *
+     * See OP_CMPL_FLOAT for an explanation.
+     *
+     * For: cmpl-double, cmpg-double
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r9, r0, #255                @ r9<- BB
+    mov     r10, r0, lsr #8             @ r10<- CC
+// begin WITH_TAINT_TRACKING
+	bl		cmpl_double_taint_prop
+// end WITH_TAINT_TRACKING
+    bl      __aeabi_cdcmple             @ cmp <=: C clear if <, Z set if eq
+    bhi     .L${opcode}_gt_or_nan       @ C set and Z clear, disambiguate
+    mvncc   r1, #0                      @ (less than) r1<- -1
+    moveq   r1, #0                      @ (equal) r1<- 0, trumps less than
+.L${opcode}_finish:
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r3)                    @ vAA<- r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r3, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.L${opcode}_gt_or_nan:
+// begin WITH_TAINT_TRACKING
+//    ldmia   r10, {r0-r1}
+	ldr		r0, [r10, #0]
+	ldr		r1, [r10, #8]
+//    ldmia   r9, {r2-r3}
+	ldr		r2, [r9, #0]
+	ldr		r3, [r9, #8]
+// end WITH_TAINT_TRACKING
+    bl      __aeabi_cdcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .L${opcode}_finish
+    $naninst                            @ r1<- 1 or -1 for NaN
+    b       .L${opcode}_finish
+
+cmpl_double_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[BB]
+    add     r10, rFP, r10, lsl #3       @ r10<- &fp[CC]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+//    ldmia   r10, {r2-r3}                @ r2/r3<- vCC/vCC+1
+	ldr		r2, [r10, #0]
+	ldr		r3, [r10, #8]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_CMPL_FLOAT.S b/vm/mterp/armv5te_taint/OP_CMPL_FLOAT.S
new file mode 100644
index 0000000..96e0590
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CMPL_FLOAT.S
@@ -0,0 +1,125 @@
+%default { "naninst":"mvn     r1, #0" }
+%verify "executed"
+%verify "basic lt, gt, eq */
+%verify "left arg NaN"
+%verify "right arg NaN"
+    /*
+     * Compare two floating-point values.  Puts 0, 1, or -1 into the
+     * destination register based on the results of the comparison.
+     *
+     * Provide a "naninst" instruction that puts 1 or -1 into r1 depending
+     * on what value we'd like to return when one of the operands is NaN.
+     *
+     * The operation we're implementing is:
+     *   if (x == y)
+     *     return 0;
+     *   else if (x < y)
+     *     return -1;
+     *   else if (x > y)
+     *     return 1;
+     *   else
+     *     return {-1,1};  // one or both operands was NaN
+     *
+     * The straightforward implementation requires 3 calls to functions
+     * that return a result in r0.  We can do it with two calls if our
+     * EABI library supports __aeabi_cfcmple (only one if we want to check
+     * for NaN directly):
+     *   check x <= y
+     *     if <, return -1
+     *     if ==, return 0
+     *   check y <= x
+     *     if <, return 1
+     *   return {-1,1}
+     *
+     * for: cmpl-float, cmpg-float
+     */
+    /* op vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r9, r2)                    @ r9<- vBB
+    GET_VREG(r10, r3)                   @ r10<- vCC
+    mov     r0, r9                      @ copy to arg registers
+    mov     r1, r10
+    bl      __aeabi_cfcmple             @ cmp <=: C clear if <, Z set if eq
+    bhi     .L${opcode}_gt_or_nan       @ C set and Z clear, disambiguate
+    mvncc   r1, #0                      @ (less than) r1<- -1
+    moveq   r1, #0                      @ (equal) r1<- 0, trumps less than
+.L${opcode}_finish:
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    SET_VREG(r1, r3)                    @ vAA<- r1 // PJG: in subroutine
+	bl		cmpl_float_taint_prop
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    @ Test for NaN with a second comparison.  EABI forbids testing bit
+    @ patterns, and we can't represent 0x7fc00000 in immediate form, so
+    @ make the library call.
+.L${opcode}_gt_or_nan:
+    mov     r1, r9                      @ reverse order
+    mov     r0, r10
+    bl      __aeabi_cfcmple             @ r0<- Z set if eq, C clear if <
+    @bleq    common_abort
+    movcc   r1, #1                      @ (greater than) r1<- 1
+    bcc     .L${opcode}_finish
+    $naninst                            @ r1<- 1 or -1 for NaN
+    b       .L${opcode}_finish
+
+cmpl_float_taint_prop:
+    SET_VREG(r1, r3)                    @ vAA<- r1
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r3, r0)
+	bx		lr
+
+#if 0       /* "clasic" form */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+    GET_VREG(r9, r2)                    @ r9<- vBB
+    GET_VREG(r10, r3)                   @ r10<- vCC
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpeq              @ r0<- (vBB == vCC)
+    cmp     r0, #0                      @ equal?
+    movne   r1, #0                      @ yes, result is 0
+    bne     ${opcode}_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmplt              @ r0<- (vBB < vCC)
+    cmp     r0, #0                      @ less than?
+    b       ${opcode}_continue
+@%break
+
+${opcode}_continue:
+    mvnne   r1, #0                      @ yes, result is -1
+    bne     ${opcode}_finish
+    mov     r0, r9                      @ r0<- vBB
+    mov     r1, r10                     @ r1<- vCC
+    bl      __aeabi_fcmpgt              @ r0<- (vBB > vCC)
+    cmp     r0, #0                      @ greater than?
+    beq     ${opcode}_nan               @ no, must be NaN
+    mov     r1, #1                      @ yes, result is 1
+    @ fall through to _finish
+
+${opcode}_finish:
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r3)                    @ vAA<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * This is expected to be uncommon, so we double-branch (once to here,
+     * again back to _finish).
+     */
+${opcode}_nan:
+    $naninst                            @ r1<- 1 or -1 for NaN
+    b       ${opcode}_finish
+
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_CMP_LONG.S b/vm/mterp/armv5te_taint/OP_CMP_LONG.S
new file mode 100644
index 0000000..8860c3d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CMP_LONG.S
@@ -0,0 +1,80 @@
+%verify "executed"
+%verify "basic lt, gt, eq"
+%verify "hi equal, lo <=>"
+%verify "lo equal, hi <=>"
+    /*
+     * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination
+     * register based on the results of the comparison.
+     *
+     * We load the full values with LDM, but in practice many values could
+     * be resolved by only looking at the high word.  This could be made
+     * faster or slower by splitting the LDM into a pair of LDRs.
+     *
+     * If we just wanted to set condition flags, we could do this:
+     *  subs    ip, r0, r2
+     *  sbcs    ip, r1, r3
+     *  subeqs  ip, r0, r2
+     * Leaving { <0, 0, >0 } in ip.  However, we have to set it to a specific
+     * integer value, which we can do with 2 conditional mov/mvn instructions
+     * (set 1, set -1; if they're equal we already have 0 in ip), giving
+     * us a constant 5-cycle path plus a branch at the end to the
+     * instruction epilogue code.  The multi-compare approach below needs
+     * 2 or 3 cycles + branch if the high word doesn't match, 6 + branch
+     * in the worst case (the 64-bit values are equal).
+     */
+    /* cmp-long vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+// begin WITH_TAINT_TRACKING
+	bl		cmp_long_taint_prop
+ // end WITH_TAINT_TRACKING
+    cmp     r1, r3                      @ compare (vBB+1, vCC+1)
+    blt     .L${opcode}_less            @ signed compare on high part
+    bgt     .L${opcode}_greater
+    subs    r1, r0, r2                  @ r1<- r0 - r2
+    bhi     .L${opcode}_greater         @ unsigned compare on low part
+    bne     .L${opcode}_less
+    b       .L${opcode}_finish          @ equal; r1 already holds 0
+%break
+
+.L${opcode}_less:
+    mvn     r1, #0                      @ r1<- -1
+    @ Want to cond code the next mov so we can avoid branch, but don't see it;
+    @ instead, we just replicate the tail end.
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.L${opcode}_greater:
+    mov     r1, #1                      @ r1<- 1
+    @ fall through to _finish
+
+.L${opcode}_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r9)                    @ vAA<- r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+cmp_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+	ldr		r2, [r3, #0]
+	ldr		r3, [r3, #8]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_CONST.S b/vm/mterp/armv5te_taint/OP_CONST.S
new file mode 100644
index 0000000..1025a34
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST.S
@@ -0,0 +1,16 @@
+%verify "executed"
+    /* const vAA, #+BBBBbbbb */
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH(r0, 1)                        @ r0<- bbbb (low)
+    FETCH(r1, 2)                        @ r1<- BBBB (high)
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_16.S b/vm/mterp/armv5te_taint/OP_CONST_16.S
new file mode 100644
index 0000000..614d602
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_16.S
@@ -0,0 +1,14 @@
+%verify "executed"
+    /* const/16 vAA, #+BBBB */
+    FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r2)
+    SET_VREG_TAINT(r2, r3, r1)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_4.S b/vm/mterp/armv5te_taint/OP_CONST_4.S
new file mode 100644
index 0000000..99bbec0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_4.S
@@ -0,0 +1,16 @@
+%verify "executed"
+    /* const/4 vA, #+B */
+    mov     r1, rINST, lsl #16          @ r1<- Bxxx0000
+    mov     r0, rINST, lsr #8           @ r0<- A+
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    mov     r1, r1, asr #28             @ r1<- sssssssB (sign-extended)
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r0, r2)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    SET_VREG(r1, r0)                    @ fp[A]<- r1
+    GOTO_OPCODE(ip)                     @ execute next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_CLASS.S b/vm/mterp/armv5te_taint/OP_CONST_CLASS.S
new file mode 100644
index 0000000..7fc8a82
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_CLASS.S
@@ -0,0 +1,46 @@
+%verify "executed"
+%verify "Class already resolved"
+%verify "Class not yet resolved"
+%verify "Class cannot be resolved"
+    /* const/class vAA, Class@BBBB */
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    ldr     r2, [r2, #offDvmDex_pResClasses]   @ r2<- dvmDex->pResClasses
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- pResClasses[BBBB]
+    cmp     r0, #0                      @ not yet resolved?
+    beq     .L${opcode}_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the Class has not yet been resolved.
+     *  r1: BBBB (Class ref)
+     *  r9: target register
+     */
+.L${opcode}_resolve:
+    EXPORT_PC()
+    ldr     r0, [rGLUE, #offGlue_method] @ r0<- glue->method
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- Class reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_HIGH16.S b/vm/mterp/armv5te_taint/OP_CONST_HIGH16.S
new file mode 100644
index 0000000..2302fad
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_HIGH16.S
@@ -0,0 +1,15 @@
+%verify "executed"
+    /* const/high16 vAA, #+BBBB0000 */
+    FETCH(r0, 1)                        @ r0<- 0000BBBB (zero-extended)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    mov     r0, r0, lsl #16             @ r0<- BBBB0000
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_STRING.S b/vm/mterp/armv5te_taint/OP_CONST_STRING.S
new file mode 100644
index 0000000..719444a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_STRING.S
@@ -0,0 +1,45 @@
+%verify "executed"
+%verify "String already resolved"
+%verify "String not yet resolved"
+%verify "String cannot be resolved"
+    /* const/string vAA, String@BBBB */
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    ldr     r2, [r2, #offDvmDex_pResStrings]   @ r2<- dvmDex->pResStrings
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
+    cmp     r0, #0                      @ not yet resolved?
+    beq     .L${opcode}_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBB (String ref)
+     *  r9: target register
+     */
+.L${opcode}_resolve:
+    EXPORT_PC()
+    ldr     r0, [rGLUE, #offGlue_method] @ r0<- glue->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_STRING_JUMBO.S b/vm/mterp/armv5te_taint/OP_CONST_STRING_JUMBO.S
new file mode 100644
index 0000000..a5d30de
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_STRING_JUMBO.S
@@ -0,0 +1,47 @@
+%verify "executed"
+%verify "String already resolved"
+%verify "String not yet resolved"
+%verify "String cannot be resolved"
+    /* const/string vAA, String@BBBBBBBB */
+    FETCH(r0, 1)                        @ r0<- bbbb (low)
+    FETCH(r1, 2)                        @ r1<- BBBB (high)
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    ldr     r2, [r2, #offDvmDex_pResStrings]   @ r2<- dvmDex->pResStrings
+    orr     r1, r0, r1, lsl #16         @ r1<- BBBBbbbb
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
+    cmp     r0, #0
+    beq     .L${opcode}_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the String has not yet been resolved.
+     *  r1: BBBBBBBB (String ref)
+     *  r9: target register
+     */
+.L${opcode}_resolve:
+    EXPORT_PC()
+    ldr     r0, [rGLUE, #offGlue_method] @ r0<- glue->method
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveString            @ r0<- String reference
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_WIDE.S b/vm/mterp/armv5te_taint/OP_CONST_WIDE.S
new file mode 100644
index 0000000..b2338d5
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_WIDE.S
@@ -0,0 +1,23 @@
+%verify "executed"
+    /* const-wide vAA, #+HHHHhhhhBBBBbbbb */
+    FETCH(r0, 1)                        @ r0<- bbbb (low)
+    FETCH(r1, 2)                        @ r1<- BBBB (low middle)
+    FETCH(r2, 3)                        @ r2<- hhhh (high middle)
+    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb (low word)
+    FETCH(r3, 4)                        @ r3<- HHHH (high)
+    mov     r9, rINST, lsr #8           @ r9<- AA
+// begin WITH_TAINT_TRACKING
+    orr     r2, r2, r3, lsl #16         @ r2<- HHHHhhhh (high word)
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_WIDE_16.S b/vm/mterp/armv5te_taint/OP_CONST_WIDE_16.S
new file mode 100644
index 0000000..49ec054
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_WIDE_16.S
@@ -0,0 +1,19 @@
+%verify "executed"
+    /* const-wide/16 vAA, #+BBBB */
+    FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+// begin WITH_TAINT_TRACKING
+    mov     r2, r0, asr #31             @ r1<- ssssssss
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_WIDE_32.S b/vm/mterp/armv5te_taint/OP_CONST_WIDE_32.S
new file mode 100644
index 0000000..2598aea
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_WIDE_32.S
@@ -0,0 +1,19 @@
+%verify "executed"
+    /* const-wide/32 vAA, #+BBBBbbbb */
+    FETCH(r0, 1)                        @ r0<- 0000bbbb (low)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    FETCH_S(r2, 2)                      @ r2<- ssssBBBB (high)
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    orr     r0, r0, r2, lsl #16         @ r0<- BBBBbbbb
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r9<- &fp[AA]
+    mov     r2, r0, asr #31             @ r2<- ssssssss
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_CONST_WIDE_HIGH16.S b/vm/mterp/armv5te_taint/OP_CONST_WIDE_HIGH16.S
new file mode 100644
index 0000000..8b6828e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_CONST_WIDE_HIGH16.S
@@ -0,0 +1,20 @@
+%verify "executed"
+    /* const-wide/high16 vAA, #+BBBB000000000000 */
+    FETCH(r1, 1)                        @ r1<- 0000BBBB (zero-extended)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    mov     r0, #0                      @ r0<- 00000000
+// begin WITH_TAINT_TRACKING
+    mov     r2, r1, lsl #16             @ r1<- BBBB0000
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_DIV_DOUBLE.S b/vm/mterp/armv5te_taint/OP_DIV_DOUBLE.S
new file mode 100644
index 0000000..6b73f1d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_ddiv"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_DOUBLE_2ADDR.S b/vm/mterp/armv5te_taint/OP_DIV_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..f96da56
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_ddiv"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_FLOAT.S b/vm/mterp/armv5te_taint/OP_DIV_FLOAT.S
new file mode 100644
index 0000000..f660396
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"bl      __aeabi_fdiv"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_FLOAT_2ADDR.S b/vm/mterp/armv5te_taint/OP_DIV_FLOAT_2ADDR.S
new file mode 100644
index 0000000..c4df66d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      __aeabi_fdiv"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_INT.S b/vm/mterp/armv5te_taint/OP_DIV_INT.S
new file mode 100644
index 0000000..41b6da8
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"bl     __aeabi_idiv","chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_DIV_INT_2ADDR.S
new file mode 100644
index 0000000..af93c07
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"bl     __aeabi_idiv","chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_DIV_INT_LIT16.S
new file mode 100644
index 0000000..25b893a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_INT_LIT16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit16.S" {"instr":"bl     __aeabi_idiv","chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_DIV_INT_LIT8.S
new file mode 100644
index 0000000..ebe283c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"bl     __aeabi_idiv","chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_LONG.S b/vm/mterp/armv5te_taint/OP_DIV_LONG.S
new file mode 100644
index 0000000..73f4ee8
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_ldivmod", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DIV_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_DIV_LONG_2ADDR.S
new file mode 100644
index 0000000..76b22bc
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DIV_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_ldivmod", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_DOUBLE_TO_FLOAT.S b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_FLOAT.S
new file mode 100644
index 0000000..d121244
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopNarrower.S" {"instr":"bl      __aeabi_d2f"}
diff --git a/vm/mterp/armv5te_taint/OP_DOUBLE_TO_INT.S b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_INT.S
new file mode 100644
index 0000000..c0688ed
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_INT.S
@@ -0,0 +1,55 @@
+%verify "executed"
+/* EABI appears to have Java-style conversions of +inf/-inf/NaN */
+%include "armv5te_taint/unopNarrower.S" {"instr":"bl      __aeabi_d2iz"}
+
+#if 0
+@include "armv5te/unopNarrower.S" {"instr":"bl      d2i_doconv"}
+@break
+/*
+ * Convert the double in r0/r1 to an int in r0.
+ *
+ * We have to clip values to int min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+d2i_doconv:
+    stmfd   sp!, {r4, r5, lr}           @ save regs
+    mov     r2, #0x80000000             @ maxint, as a double (low word)
+    mov     r2, r2, asr #9              @  0xffc00000
+    sub     sp, sp, #4                  @ align for EABI
+    mvn     r3, #0xbe000000             @ maxint, as a double (high word)
+    sub     r3, r3, #0x00200000         @  0x41dfffff
+    mov     r4, r0                      @ save a copy of r0
+    mov     r5, r1                      @  and r1
+    bl      __aeabi_dcmpge              @ is arg >= maxint?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0x80000000             @ return maxint (0x7fffffff)
+    bne     1f
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r3, #0xc1000000             @ minint, as a double (high word)
+    add     r3, r3, #0x00e00000         @  0xc1e00000
+    mov     r2, #0                      @ minint, as a double (low word)
+    bl      __aeabi_dcmple              @ is arg <= minint?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0x80000000             @ return minint (80000000)
+    bne     1f
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r2, r4                      @ compare against self
+    mov     r3, r5
+    bl      __aeabi_dcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    beq     1f                          @ return zero for NaN
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    bl      __aeabi_d2iz                @ convert double to int
+
+1:
+    add     sp, sp, #4
+    ldmfd   sp!, {r4, r5, pc}
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_DOUBLE_TO_LONG.S b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_LONG.S
new file mode 100644
index 0000000..2f54e09
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_DOUBLE_TO_LONG.S
@@ -0,0 +1,54 @@
+%verify "executed"
+@include "armv5te/unopWide.S" {"instr":"bl      __aeabi_d2lz"}
+%include "armv5te_taint/unopWide.S" {"instr":"bl      d2l_doconv"}
+
+%break
+/*
+ * Convert the double in r0/r1 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+d2l_doconv:
+    stmfd   sp!, {r4, r5, lr}           @ save regs
+    mov     r3, #0x43000000             @ maxlong, as a double (high word)
+    add     r3, #0x00e00000             @  0x43e00000
+    mov     r2, #0                      @ maxlong, as a double (low word)
+    sub     sp, sp, #4                  @ align for EABI
+    mov     r4, r0                      @ save a copy of r0
+    mov     r5, r1                      @  and r1
+    bl      __aeabi_dcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffffffffffff)
+    mvnne   r1, #0x80000000
+    bne     1f
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r3, #0xc3000000             @ minlong, as a double (high word)
+    add     r3, #0x00e00000             @  0xc3e00000
+    mov     r2, #0                      @ minlong, as a double (low word)
+    bl      __aeabi_dcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (8000000000000000)
+    movne   r1, #0x80000000
+    bne     1f
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    mov     r2, r4                      @ compare against self
+    mov     r3, r5
+    bl      __aeabi_dcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    beq     1f
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r5
+    bl      __aeabi_d2lz                @ convert double to long
+
+1:
+    add     sp, sp, #4
+    ldmfd   sp!, {r4, r5, pc}
+
diff --git a/vm/mterp/armv5te_taint/OP_EXECUTE_INLINE.S b/vm/mterp/armv5te_taint/OP_EXECUTE_INLINE.S
new file mode 100644
index 0000000..e1439cd
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_EXECUTE_INLINE.S
@@ -0,0 +1,62 @@
+%verify "executed"
+%verify "exception handled"
+    /*
+     * Execute a "native inline" instruction.
+     *
+     * We need to call:
+     *  dvmPerformInlineOp4Std(arg0, arg1, arg2, arg3, &retval, ref)
+     *
+     * The first four args are in r0-r3, but the last two must be pushed
+     * onto the stack.
+     */
+    /* [opt] execute-inline vAA, {vC, vD, vE, vF}, inline@BBBB */
+    FETCH(r10, 1)                       @ r10<- BBBB
+    add     r1, rGLUE, #offGlue_retval  @ r1<- &glue->retval
+    EXPORT_PC()                         @ can throw
+    sub     sp, sp, #8                  @ make room for arg(s)
+    mov     r0, rINST, lsr #12          @ r0<- B
+    str     r1, [sp]                    @ push &glue->retval
+    bl      .L${opcode}_continue        @ make call; will return after
+    add     sp, sp, #8                  @ pop stack
+    cmp     r0, #0                      @ test boolean result of inline
+    beq     common_exceptionThrown      @ returned false, handle exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Extract args, call function.
+     *  r0 = #of args (0-4)
+     *  r10 = call index
+     *  lr = return addr, above  [DO NOT bl out of here w/o preserving LR]
+     *
+     * Other ideas:
+     * - Use a jump table from the main piece to jump directly into the
+     *   AND/LDR pairs.  Costs a data load, saves a branch.
+     * - Have five separate pieces that do the loading, so we can work the
+     *   interleave a little better.  Increases code size.
+     */
+.L${opcode}_continue:
+    rsb     r0, r0, #4                  @ r0<- 4-r0
+    FETCH(r9, 2)                        @ r9<- FEDC
+    add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+// begin WITH_TAINT_TRACKING
+4:  and     ip, r9, #0xf000             @ isolate F
+    ldr     r3, [rFP, ip, lsr #9]      @ r3<- vF (shift right 12, left 2)
+3:  and     ip, r9, #0x0f00             @ isolate E
+    ldr     r2, [rFP, ip, lsr #5]       @ r2<- vE
+2:  and     ip, r9, #0x00f0             @ isolate D
+    ldr     r1, [rFP, ip, lsr #1]       @ r1<- vD
+1:  and     ip, r9, #0x000f             @ isolate C
+    ldr     r0, [rFP, ip, lsl #3]       @ r0<- vC
+0:
+// end WITH_TAINT_TRACKING
+    ldr     r9, .L${opcode}_table       @ table of InlineOperation
+    LDR_PC  "[r9, r10, lsl #4]"         @ sizeof=16, "func" is first entry
+    @ (not reached)
+
+.L${opcode}_table:
+    .word   gDvmInlineOpsTable
+
diff --git a/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY.S b/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY.S
new file mode 100644
index 0000000..ab01689
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY.S
@@ -0,0 +1,111 @@
+%default { "isrange":"0" }
+%verify "executed"
+%verify "unimplemented array type"
+    /*
+     * Create a new array with elements filled from registers.
+     *
+     * for: filled-new-array, filled-new-array/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op {vCCCC..v(CCCC+AA-1)}, type@BBBB */
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
+    EXPORT_PC()                         @ need for resolve and alloc
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
+    mov     r10, rINST, lsr #8          @ r10<- AA or BA
+    cmp     r0, #0                      @ already resolved?
+    bne     .L${opcode}_continue        @ yes, continue on
+8:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    cmp     r0, #0                      @ got null?
+    beq     common_exceptionThrown      @ yes, handle exception
+    b       .L${opcode}_continue
+%break
+
+    /*
+     * On entry:
+     *  r0 holds array class
+     *  r10 holds AA or BA
+     */
+.L${opcode}_continue:
+    ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
+    mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
+    ldrb    r3, [r3, #1]                @ r3<- descriptor[1]
+    .if     $isrange
+    mov     r1, r10                     @ r1<- AA (length)
+    .else
+    mov     r1, r10, lsr #4             @ r1<- B (length)
+    .endif
+    cmp     r3, #'I'                    @ array of ints?
+    cmpne   r3, #'L'                    @ array of objects?
+    cmpne   r3, #'['                    @ array of arrays?
+    mov     r9, r1                      @ save length in r9
+    bne     .L${opcode}_notimpl         @ no, not handled yet
+    bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
+    cmp     r0, #0                      @ null return?
+    beq     common_exceptionThrown      @ alloc failed, handle exception
+
+    FETCH(r1, 2)                        @ r1<- FEDC or CCCC
+    str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
+    add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
+    subs    r9, r9, #1                  @ length--, check for neg
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    bmi     2f                          @ was zero, bail
+
+    @ copy values from registers into the array
+    @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
+    .if     $isrange
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r3)
+	str		r3, [rGLUE, #offGlue_rtaint]	@ rtaint <- clear
+	str		r3, [r2]
+// end WITH_TAINT_TRACKING
+    add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
+1:  ldr     r3, [r2], #4                @ r3<- *r2++
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .else
+    cmp     r9, #4                      @ length was initially 5?
+    and     r2, r10, #15                @ r2<- A
+    bne     1f                          @ <= 4 args, branch
+    GET_VREG(r3, r2)                    @ r3<- vA
+    sub     r9, r9, #1                  @ count--
+    str     r3, [r0, #16]               @ contents[4] = vA
+1:  and     r2, r1, #15                 @ r2<- F/E/D/C
+    GET_VREG(r3, r2)                    @ r3<- vF/vE/vD/vC
+    mov     r1, r1, lsr #4              @ r1<- next reg in low 4
+    subs    r9, r9, #1                  @ count--
+    str     r3, [r0], #4                @ *contents++ = vX
+    bpl     1b
+    @ continue at 2
+    .endif
+
+2:
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    GOTO_OPCODE(ip)                     @ execute it
+
+    /*
+     * Throw an exception indicating that we have not implemented this
+     * mode of filled-new-array.
+     */
+.L${opcode}_notimpl:
+    ldr     r0, .L_strInternalError
+    ldr     r1, .L_strFilledNewArrayNotImpl
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+    .if     (!$isrange)                 @ define in one or the other, not both
+.L_strFilledNewArrayNotImpl:
+    .word   .LstrFilledNewArrayNotImpl
+.L_strInternalError:
+    .word   .LstrInternalError
+    .endif
+
diff --git a/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY_RANGE.S b/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY_RANGE.S
new file mode 100644
index 0000000..2196f61
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FILLED_NEW_ARRAY_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_FILLED_NEW_ARRAY.S" { "isrange":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_FILL_ARRAY_DATA.S b/vm/mterp/armv5te_taint/OP_FILL_ARRAY_DATA.S
new file mode 100644
index 0000000..a0d8399
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FILL_ARRAY_DATA.S
@@ -0,0 +1,15 @@
+%verify "executed"
+    /* fill-array-data vAA, +BBBBBBBB */
+    FETCH(r0, 1)                        @ r0<- bbbb (lo)
+    FETCH(r1, 2)                        @ r1<- BBBB (hi)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    orr     r1, r0, r1, lsl #16         @ r1<- BBBBbbbb
+    GET_VREG(r0, r3)                    @ r0<- vAA (array object)
+    add     r1, rPC, r1, lsl #1         @ r1<- PC + BBBBbbbb*2 (array data off.)
+    EXPORT_PC();
+    bl      dvmInterpHandleFillArrayData@ fill the array with predefined data
+    cmp     r0, #0                      @ 0 means an exception is thrown
+    beq     common_exceptionThrown      @ has exception
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
diff --git a/vm/mterp/armv5te_taint/OP_FLOAT_TO_DOUBLE.S b/vm/mterp/armv5te_taint/OP_FLOAT_TO_DOUBLE.S
new file mode 100644
index 0000000..870be3e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FLOAT_TO_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWider.S" {"instr":"bl      __aeabi_f2d"}
diff --git a/vm/mterp/armv5te_taint/OP_FLOAT_TO_INT.S b/vm/mterp/armv5te_taint/OP_FLOAT_TO_INT.S
new file mode 100644
index 0000000..ba14c04
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FLOAT_TO_INT.S
@@ -0,0 +1,41 @@
+%verify "executed"
+/* EABI appears to have Java-style conversions of +inf/-inf/NaN */
+%include "armv5te_taint/unop.S" {"instr":"bl      __aeabi_f2iz"}
+
+#if 0
+@include "armv5te/unop.S" {"instr":"bl      f2i_doconv"}
+@break
+/*
+ * Convert the float in r0 to an int in r0.
+ *
+ * We have to clip values to int min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+f2i_doconv:
+    stmfd   sp!, {r4, lr}
+    mov     r1, #0x4f000000             @ (float)maxint
+    mov     r4, r0
+    bl      __aeabi_fcmpge              @ is arg >= maxint?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0x80000000             @ return maxint (7fffffff)
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, #0xcf000000             @ (float)minint
+    bl      __aeabi_fcmple              @ is arg <= minint?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0x80000000             @ return minint (80000000)
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r4
+    bl      __aeabi_fcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    ldmeqfd sp!, {r4, pc}               @ return zero for NaN
+
+    mov     r0, r4                      @ recover arg
+    bl      __aeabi_f2iz                @ convert float to int
+    ldmfd   sp!, {r4, pc}
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_FLOAT_TO_LONG.S b/vm/mterp/armv5te_taint/OP_FLOAT_TO_LONG.S
new file mode 100644
index 0000000..e390ea6
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_FLOAT_TO_LONG.S
@@ -0,0 +1,41 @@
+%verify "executed"
+@include "armv5te/unopWider.S" {"instr":"bl      __aeabi_f2lz"}
+%include "armv5te_taint/unopWider.S" {"instr":"bl      f2l_doconv"}
+
+%break
+/*
+ * Convert the float in r0 to a long in r0/r1.
+ *
+ * We have to clip values to long min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+f2l_doconv:
+    stmfd   sp!, {r4, lr}
+    mov     r1, #0x5f000000             @ (float)maxlong
+    mov     r4, r0
+    bl      __aeabi_fcmpge              @ is arg >= maxlong?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0                      @ return maxlong (7fffffff)
+    mvnne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, #0xdf000000             @ (float)minlong
+    bl      __aeabi_fcmple              @ is arg <= minlong?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0                      @ return minlong (80000000)
+    movne   r1, #0x80000000
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r4
+    bl      __aeabi_fcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    moveq   r1, #0                      @ return zero for NaN
+    ldmeqfd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    bl      __aeabi_f2lz                @ convert float to long
+    ldmfd   sp!, {r4, pc}
+
diff --git a/vm/mterp/armv5te_taint/OP_GOTO.S b/vm/mterp/armv5te_taint/OP_GOTO.S
new file mode 100644
index 0000000..26f0c8f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_GOTO.S
@@ -0,0 +1,25 @@
+%verify "executed"
+%verify "forward and backward"
+    /*
+     * Unconditional branch, 8-bit offset.
+     *
+     * The branch distance is a signed code-unit offset, which we need to
+     * double to get a byte offset.
+     */
+    /* goto +AA */
+    mov     r0, rINST, lsl #16          @ r0<- AAxx0000
+    movs    r9, r0, asr #24             @ r9<- ssssssAA (sign-extended)
+    mov     r9, r9, lsl #1              @ r9<- byte offset
+    bmi     common_backwardBranch       @ backward branch, do periodic checks
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
diff --git a/vm/mterp/armv5te_taint/OP_GOTO_16.S b/vm/mterp/armv5te_taint/OP_GOTO_16.S
new file mode 100644
index 0000000..f738a98
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_GOTO_16.S
@@ -0,0 +1,25 @@
+%verify "executed"
+%verify "forward and backward"
+    /*
+     * Unconditional branch, 16-bit offset.
+     *
+     * The branch distance is a signed code-unit offset, which we need to
+     * double to get a byte offset.
+     */
+    /* goto/16 +AAAA */
+    FETCH_S(r0, 1)                      @ r0<- ssssAAAA (sign-extended)
+    movs    r9, r0, asl #1              @ r9<- byte offset, check sign
+    bmi     common_backwardBranch       @ backward branch, do periodic checks
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_GOTO_32.S b/vm/mterp/armv5te_taint/OP_GOTO_32.S
new file mode 100644
index 0000000..17780b9
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_GOTO_32.S
@@ -0,0 +1,32 @@
+%verify "executed"
+%verify "forward, backward, self"
+    /*
+     * Unconditional branch, 32-bit offset.
+     *
+     * The branch distance is a signed code-unit offset, which we need to
+     * double to get a byte offset.
+     *
+     * Unlike most opcodes, this one is allowed to branch to itself, so
+     * our "backward branch" test must be "<=0" instead of "<0".  The ORRS
+     * instruction doesn't affect the V flag, so we need to clear it
+     * explicitly.
+     */
+    /* goto/32 +AAAAAAAA */
+    FETCH(r0, 1)                        @ r0<- aaaa (lo)
+    FETCH(r1, 2)                        @ r1<- AAAA (hi)
+    cmp     ip, ip                      @ (clear V flag during stall)
+    orrs    r0, r0, r1, lsl #16         @ r0<- AAAAaaaa, check sign
+    mov     r9, r0, asl #1              @ r9<- byte offset
+    ble     common_backwardBranch       @ backward branch, do periodic checks
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
diff --git a/vm/mterp/armv5te_taint/OP_IF_EQ.S b/vm/mterp/armv5te_taint/OP_IF_EQ.S
new file mode 100644
index 0000000..2ba7d90
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_EQ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"ne" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_EQZ.S b/vm/mterp/armv5te_taint/OP_IF_EQZ.S
new file mode 100644
index 0000000..345ac4f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_EQZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"ne" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_GE.S b/vm/mterp/armv5te_taint/OP_IF_GE.S
new file mode 100644
index 0000000..25f6035
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_GE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"lt" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_GEZ.S b/vm/mterp/armv5te_taint/OP_IF_GEZ.S
new file mode 100644
index 0000000..de0a5d7
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_GEZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"lt" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_GT.S b/vm/mterp/armv5te_taint/OP_IF_GT.S
new file mode 100644
index 0000000..b534ee7
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_GT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"le" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_GTZ.S b/vm/mterp/armv5te_taint/OP_IF_GTZ.S
new file mode 100644
index 0000000..3456f00
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_GTZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"le" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_LE.S b/vm/mterp/armv5te_taint/OP_IF_LE.S
new file mode 100644
index 0000000..58f3621
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_LE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"gt" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_LEZ.S b/vm/mterp/armv5te_taint/OP_IF_LEZ.S
new file mode 100644
index 0000000..a98e446
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_LEZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"gt" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_LT.S b/vm/mterp/armv5te_taint/OP_IF_LT.S
new file mode 100644
index 0000000..0bfbac3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_LT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"ge" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_LTZ.S b/vm/mterp/armv5te_taint/OP_IF_LTZ.S
new file mode 100644
index 0000000..48f4231
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_LTZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"ge" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_NE.S b/vm/mterp/armv5te_taint/OP_IF_NE.S
new file mode 100644
index 0000000..e924486
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_NE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/bincmp.S" { "revcmp":"eq" }
diff --git a/vm/mterp/armv5te_taint/OP_IF_NEZ.S b/vm/mterp/armv5te_taint/OP_IF_NEZ.S
new file mode 100644
index 0000000..41afc94
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IF_NEZ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/zcmp.S" { "revcmp":"eq" }
diff --git a/vm/mterp/armv5te_taint/OP_IGET.S b/vm/mterp/armv5te_taint/OP_IGET.S
new file mode 100644
index 0000000..6dda5dc
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET.S
@@ -0,0 +1,63 @@
+%default { "load":"ldr", "sqnum":"0" }
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit instance field get.
+     *
+     * for: iget, iget-object, iget-boolean, iget-byte, iget-char, iget-short
+     */
+    /* op vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
+// begin WITH_TAINT_TRACKING
+    bl		.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0
+    bne     .L${opcode}_finish
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    @bl      common_squeak${sqnum}
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    $load   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.L${opcode}_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_IGET_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_IGET_BOOLEAN.S
new file mode 100644
index 0000000..65a176e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_BOOLEAN.S
@@ -0,0 +1,3 @@
+%verify "executed"
+@include "armv5te/OP_IGET.S" { "load":"ldrb", "sqnum":"1" }
+%include "armv5te_taint/OP_IGET.S" { "load":"ldr", "sqnum":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_IGET_BYTE.S b/vm/mterp/armv5te_taint/OP_IGET_BYTE.S
new file mode 100644
index 0000000..c742020
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_BYTE.S
@@ -0,0 +1,4 @@
+%verify "executed"
+%verify "negative value is sign-extended"
+@include "armv5te/OP_IGET.S" { "load":"ldrsb", "sqnum":"2" }
+%include "armv5te_taint/OP_IGET.S" { "load":"ldr", "sqnum":"2" }
diff --git a/vm/mterp/armv5te_taint/OP_IGET_CHAR.S b/vm/mterp/armv5te_taint/OP_IGET_CHAR.S
new file mode 100644
index 0000000..1bdbedc
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_CHAR.S
@@ -0,0 +1,4 @@
+%verify "executed"
+%verify "large values are not sign-extended"
+@include "armv5te/OP_IGET.S" { "load":"ldrh", "sqnum":"3" }
+%include "armv5te_taint/OP_IGET.S" { "load":"ldr", "sqnum":"3" }
diff --git a/vm/mterp/armv5te_taint/OP_IGET_OBJECT.S b/vm/mterp/armv5te_taint/OP_IGET_OBJECT.S
new file mode 100644
index 0000000..72a589d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_IGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_IGET_OBJECT_QUICK.S b/vm/mterp/armv5te_taint/OP_IGET_OBJECT_QUICK.S
new file mode 100644
index 0000000..64b6847
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_OBJECT_QUICK.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_IGET_QUICK.S"
diff --git a/vm/mterp/armv5te_taint/OP_IGET_QUICK.S b/vm/mterp/armv5te_taint/OP_IGET_QUICK.S
new file mode 100644
index 0000000..093621b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_QUICK.S
@@ -0,0 +1,36 @@
+%verify "executed"
+%verify "null object"
+    /* For: iget-quick, iget-object-quick */
+    /* op vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    GET_VREG(r3, r2)                    @ r3<- object we're operating on
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
+    beq     common_errNullObject        @ object was null
+    ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
+// begin WITH_TAINT_TRACKING
+	bl		.L${opcode}_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+.L${opcode}_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_IGET_SHORT.S b/vm/mterp/armv5te_taint/OP_IGET_SHORT.S
new file mode 100644
index 0000000..1d8f1ba
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_SHORT.S
@@ -0,0 +1,4 @@
+%verify "executed"
+%verify "negative value is sign-extended"
+@include "armv5te/OP_IGET.S" { "load":"ldrsh", "sqnum":"4" }
+%include "armv5te_taint/OP_IGET.S" { "load":"ldr", "sqnum":"4" }
diff --git a/vm/mterp/armv5te_taint/OP_IGET_WIDE.S b/vm/mterp/armv5te_taint/OP_IGET_WIDE.S
new file mode 100644
index 0000000..7880e3e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_WIDE.S
@@ -0,0 +1,62 @@
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * Wide 32-bit instance field get.
+     */
+    /* iget-wide vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_taint_prop
+// end WITH_TAINT_TRACKING
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0
+    bne     .L${opcode}_finish
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    and     r2, r2, #15                 @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #8
+	ldr		r3, [r9, r3]
+	orr		r10, r3, r10
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+iget_wide_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_IGET_WIDE_QUICK.S b/vm/mterp/armv5te_taint/OP_IGET_WIDE_QUICK.S
new file mode 100644
index 0000000..aec590c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IGET_WIDE_QUICK.S
@@ -0,0 +1,37 @@
+%verify "executed"
+%verify "null object"
+    /* iget-wide-quick vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    GET_VREG(r3, r2)                    @ r3<- object we're operating on
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
+    beq     common_errNullObject        @ object was null
+// begin WITH_TAINT_TRACKING
+	add		r10, r1, #8
+    ldrd    r0, [r3, r1]                @ r0<- obj.field (64 bits, aligned)
+    ldr		r10, [r3, r10]
+    orr		r10, r9, r10
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+iget_wide_quick_taint_prop:
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_INSTANCE_OF.S b/vm/mterp/armv5te_taint/OP_INSTANCE_OF.S
new file mode 100644
index 0000000..d4570af
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INSTANCE_OF.S
@@ -0,0 +1,96 @@
+%verify "executed"
+%verify "null object"
+%verify "class cast exception thrown, with correct class name"
+%verify "class cast exception not thrown on same class"
+%verify "class cast exception not thrown on subclass"
+%verify "class not resolved"
+%verify "class already resolved"
+    /*
+     * Check to see if an object reference is an instance of a class.
+     *
+     * Most common situation is a non-null object, being compared against
+     * an already-resolved class.
+     */
+    /* instance-of vA, vB, class@CCCC */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    GET_VREG(r0, r3)                    @ r0<- vB (object)
+    and     r9, r9, #15                 @ r9<- A
+    cmp     r0, #0                      @ is object null?
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- pDvmDex
+    beq     .L${opcode}_store           @ null obj, not an instance, store r0
+    FETCH(r3, 1)                        @ r3<- CCCC
+    ldr     r2, [r2, #offDvmDex_pResClasses]    @ r2<- pDvmDex->pResClasses
+    ldr     r1, [r2, r3, lsl #2]        @ r1<- resolved class
+    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
+    cmp     r1, #0                      @ have we resolved this before?
+    beq     .L${opcode}_resolve         @ not resolved, do it now
+.L${opcode}_resolved: @ r0=obj->clazz, r1=resolved class
+    cmp     r0, r1                      @ same class (trivial success)?
+    beq     .L${opcode}_trivial         @ yes, trivial finish
+    b       .L${opcode}_fullcheck       @ no, do full check
+%break
+
+    /*
+     * Trivial test failed, need to perform full check.  This is common.
+     *  r0 holds obj->clazz
+     *  r1 holds class resolved from BBBB
+     *  r9 holds A
+     */
+.L${opcode}_fullcheck:
+    bl      dvmInstanceofNonTrivial     @ r0<- boolean result
+    @ fall through to ${opcode}_store
+
+    /*
+     * r0 holds boolean result
+     * r9 holds A
+     */
+.L${opcode}_store:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * Trivial test succeeded, save and bail.
+     *  r9 holds A
+     */
+.L${opcode}_trivial:
+    mov     r0, #1                      @ indicate success
+    @ could b ${opcode}_store, but copying is faster and cheaper
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
+    SET_VREG(r0, r9)                    @ vA<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * Resolution required.  This is the least-likely path.
+     *
+     *  r3 holds BBBB
+     *  r9 holds A
+     */
+.L${opcode}_resolve:
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [rGLUE, #offGlue_method]    @ r0<- glue->method
+    mov     r1, r3                      @ r1<- BBBB
+    mov     r2, #1                      @ r2<- true
+    ldr     r0, [r0, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    beq     common_exceptionThrown      @ yes, handle exception
+    mov     r1, r0                      @ r1<- class resolved from BBB
+    mov     r3, rINST, lsr #12          @ r3<- B
+    GET_VREG(r0, r3)                    @ r0<- vB (object)
+    ldr     r0, [r0, #offObject_clazz]  @ r0<- obj->clazz
+    b       .L${opcode}_resolved        @ pick up where we left off
+
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_BYTE.S b/vm/mterp/armv5te_taint/OP_INT_TO_BYTE.S
new file mode 100644
index 0000000..b3fb9ae
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"preinstr":"mov     r0, r0, asl #24", "instr":"mov     r0, r0, asr #24"}
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_CHAR.S b/vm/mterp/armv5te_taint/OP_INT_TO_CHAR.S
new file mode 100644
index 0000000..003f8f9
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"preinstr":"mov     r0, r0, asl #16", "instr":"mov     r0, r0, lsr #16"}
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_DOUBLE.S b/vm/mterp/armv5te_taint/OP_INT_TO_DOUBLE.S
new file mode 100644
index 0000000..934130d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWider.S" {"instr":"bl      __aeabi_i2d"}
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_FLOAT.S b/vm/mterp/armv5te_taint/OP_INT_TO_FLOAT.S
new file mode 100644
index 0000000..e67e344
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"instr":"bl      __aeabi_i2f"}
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_LONG.S b/vm/mterp/armv5te_taint/OP_INT_TO_LONG.S
new file mode 100644
index 0000000..4021482
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWider.S" {"instr":"mov     r1, r0, asr #31"}
diff --git a/vm/mterp/armv5te_taint/OP_INT_TO_SHORT.S b/vm/mterp/armv5te_taint/OP_INT_TO_SHORT.S
new file mode 100644
index 0000000..05c7940
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INT_TO_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"preinstr":"mov     r0, r0, asl #16", "instr":"mov     r0, r0, asr #16"}
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT.S b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT.S
new file mode 100644
index 0000000..c8d551c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT.S
@@ -0,0 +1,48 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+    /*
+     * Handle a direct method call.
+     *
+     * (We could defer the "is 'this' pointer null" test to the common
+     * method invocation code, and use a flag to indicate that static
+     * calls don't count.  If we do this as part of copying the arguments
+     * out we could avoiding loading the first arg twice.)
+     *
+     * for: invoke-direct, invoke-direct/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
+    FETCH(r10, 2)                       @ r10<- GFED or CCCC
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
+    .if     (!$isrange)
+    and     r10, r10, #15               @ r10<- D (or stays CCCC)
+    .endif
+    cmp     r0, #0                      @ already resolved?
+    EXPORT_PC()                         @ must export for invoke
+    GET_VREG(r2, r10)                   @ r2<- "this" ptr
+    beq     .L${opcode}_resolve         @ not resolved, do it now
+.L${opcode}_finish:
+    cmp     r2, #0                      @ null "this" ref?
+    bne     common_invokeMethod${routine}   @ no, continue on
+    b       common_errNullObject        @ yes, throw exception
+%break
+
+    /*
+     * On entry:
+     *  r1 = reference (BBBB or CCCC)
+     *  r10 = "this" register
+     */
+.L${opcode}_resolve:
+    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_DIRECT          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
+    bne     .L${opcode}_finish          @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_EMPTY.S b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_EMPTY.S
new file mode 100644
index 0000000..3c6b192
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_EMPTY.S
@@ -0,0 +1,7 @@
+%verify "executed"
+    /*
+     * invoke-direct-empty is a no-op in a "standard" interpreter.
+     */
+    FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    GOTO_OPCODE(ip)                     @ execute it
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_RANGE.S
new file mode 100644
index 0000000..a1b41c6
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_DIRECT_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_DIRECT.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE.S b/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE.S
new file mode 100644
index 0000000..5463d5c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE.S
@@ -0,0 +1,28 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+%verify "null object"
+    /*
+     * Handle an interface method call.
+     *
+     * for: invoke-interface, invoke-interface/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
+    FETCH(r1, 1)                        @ r1<- BBBB
+    .if     (!$isrange)
+    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
+    .endif
+    EXPORT_PC()                         @ must export for invoke
+    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
+    cmp     r0, #0                      @ null obj?
+    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
+    beq     common_errNullObject        @ yes, fail
+    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
+    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yes, handle exception
+    b       common_invokeMethod${routine} @ jump to common handler 
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE_RANGE.S
new file mode 100644
index 0000000..12b8390
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_INTERFACE_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_INTERFACE.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_STATIC.S b/vm/mterp/armv5te_taint/OP_INVOKE_STATIC.S
new file mode 100644
index 0000000..57d337b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_STATIC.S
@@ -0,0 +1,25 @@
+%default { "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+    /*
+     * Handle a static method call.
+     *
+     * for: invoke-static, invoke-static/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
+    cmp     r0, #0                      @ already resolved?
+    EXPORT_PC()                         @ must export for invoke
+    bne     common_invokeMethod${routine} @ yes, continue on
+0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_STATIC          @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     common_invokeMethod${routine} @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_STATIC_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_STATIC_RANGE.S
new file mode 100644
index 0000000..e78f3ee
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_STATIC_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_STATIC.S" { "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_SUPER.S b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER.S
new file mode 100644
index 0000000..f24f690
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER.S
@@ -0,0 +1,61 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+    /*
+     * Handle a "super" method call.
+     *
+     * for: invoke-super, invoke-super/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    FETCH(r10, 2)                       @ r10<- GFED or CCCC
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    .if     (!$isrange)
+    and     r10, r10, #15               @ r10<- D (or stays CCCC)
+    .endif
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
+    GET_VREG(r2, r10)                   @ r2<- "this" ptr
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
+    cmp     r2, #0                      @ null "this"?
+    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
+    beq     common_errNullObject        @ null "this", throw exception
+    cmp     r0, #0                      @ already resolved?
+    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
+    EXPORT_PC()                         @ must export for invoke
+    bne     .L${opcode}_continue        @ resolved, continue on
+    b       .L${opcode}_resolve         @ do resolve now
+%break
+
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r9 = method->clazz
+     */
+.L${opcode}_continue:
+    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
+    EXPORT_PC()                         @ must export for invoke
+    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
+    bcs     .L${opcode}_nsm             @ method not present in superclass
+    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
+    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethod${routine} @ continue on
+
+.L${opcode}_resolve:
+    mov     r0, r9                      @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .L${opcode}_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
+
+    /*
+     * Throw a NoSuchMethodError with the method name as the message.
+     *  r0 = resolved base method
+     */
+.L${opcode}_nsm:
+    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
+    b       common_errNoSuchMethod
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK.S b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK.S
new file mode 100644
index 0000000..90b2a91
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK.S
@@ -0,0 +1,26 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+    /*
+     * Handle an optimized "super" method call.
+     *
+     * for: [opt] invoke-super-quick, invoke-super-quick/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    FETCH(r10, 2)                       @ r10<- GFED or CCCC
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    .if     (!$isrange)
+    and     r10, r10, #15               @ r10<- D (or stays CCCC)
+    .endif
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
+    EXPORT_PC()                         @ must export for invoke
+    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
+    GET_VREG(r3, r10)                   @ r3<- "this"
+    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
+    cmp     r3, #0                      @ null "this" ref?
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
+    beq     common_errNullObject        @ "this" is null, throw exception
+    bl      common_invokeMethod${routine} @ continue on
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK_RANGE.S
new file mode 100644
index 0000000..82c3d39
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_QUICK_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_SUPER_QUICK.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_RANGE.S
new file mode 100644
index 0000000..7228e15
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_SUPER_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_SUPER.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL.S b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL.S
new file mode 100644
index 0000000..33dc108
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL.S
@@ -0,0 +1,46 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "unknown method"
+%verify "null object"
+    /*
+     * Handle a virtual method call.
+     *
+     * for: invoke-virtual, invoke-virtual/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
+    FETCH(r10, 2)                       @ r10<- GFED or CCCC
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
+    .if     (!$isrange)
+    and     r10, r10, #15               @ r10<- D (or stays CCCC)
+    .endif
+    cmp     r0, #0                      @ already resolved?
+    EXPORT_PC()                         @ must export for invoke
+    bne     .L${opcode}_continue        @ yes, continue on
+    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    mov     r2, #METHOD_VIRTUAL         @ resolver method type
+    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
+    cmp     r0, #0                      @ got null?
+    bne     .L${opcode}_continue        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
+%break
+
+    /*
+     * At this point:
+     *  r0 = resolved base method
+     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
+     */
+.L${opcode}_continue:
+    GET_VREG(r1, r10)                   @ r1<- "this" ptr
+    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
+    cmp     r1, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
+    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
+    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
+    bl      common_invokeMethod${routine} @ continue on
+
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK.S b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK.S
new file mode 100644
index 0000000..bc34023
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK.S
@@ -0,0 +1,23 @@
+%default { "isrange":"0", "routine":"NoRange" }
+%verify "executed"
+%verify "null object"
+    /*
+     * Handle an optimized virtual method call.
+     *
+     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
+     */
+    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
+    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
+    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
+    FETCH(r1, 1)                        @ r1<- BBBB
+    .if     (!$isrange)
+    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
+    .endif
+    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
+    cmp     r2, #0                      @ is "this" null?
+    beq     common_errNullObject        @ null "this", throw exception
+    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
+    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
+    EXPORT_PC()                         @ invoke must export
+    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
+    bl      common_invokeMethod${routine} @ continue on
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK_RANGE.S
new file mode 100644
index 0000000..f52c7b8
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_QUICK_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_VIRTUAL_QUICK.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_RANGE.S b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_RANGE.S
new file mode 100644
index 0000000..4371740
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_INVOKE_VIRTUAL_RANGE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_INVOKE_VIRTUAL.S" { "isrange":"1", "routine":"Range" }
diff --git a/vm/mterp/armv5te_taint/OP_IPUT.S b/vm/mterp/armv5te_taint/OP_IPUT.S
new file mode 100644
index 0000000..4ef135b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT.S
@@ -0,0 +1,55 @@
+%default { "store":"str", "sqnum":"0" }
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit instance field put.
+     *
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
+     */
+    /* op vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish up
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    @bl      common_squeak${sqnum}
+    mov     r1, rINST, lsr #8           @ r1<- A+
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    and     r1, r1, #15                 @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    $store  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_IPUT_BOOLEAN.S
new file mode 100644
index 0000000..a2b7703
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_BOOLEAN.S
@@ -0,0 +1,3 @@
+%verify "executed"
+@include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"1" }
+%include "armv5te_taint/OP_IPUT.S" { "store":"str", "sqnum":"1" }
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_BYTE.S b/vm/mterp/armv5te_taint/OP_IPUT_BYTE.S
new file mode 100644
index 0000000..7f3cd52
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_BYTE.S
@@ -0,0 +1,3 @@
+%verify "executed"
+@include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"2" }
+%include "armv5te_taint/OP_IPUT.S" { "store":"str", "sqnum":"2" }
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_CHAR.S b/vm/mterp/armv5te_taint/OP_IPUT_CHAR.S
new file mode 100644
index 0000000..e6c6d49
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_CHAR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+@include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"3" }
+%include "armv5te_taint/OP_IPUT.S" { "store":"str", "sqnum":"3" }
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_OBJECT.S b/vm/mterp/armv5te_taint/OP_IPUT_OBJECT.S
new file mode 100644
index 0000000..a82a5b2
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_IPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_OBJECT_QUICK.S b/vm/mterp/armv5te_taint/OP_IPUT_OBJECT_QUICK.S
new file mode 100644
index 0000000..6095c11
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_OBJECT_QUICK.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_IPUT_QUICK.S"
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_QUICK.S b/vm/mterp/armv5te_taint/OP_IPUT_QUICK.S
new file mode 100644
index 0000000..27d65a0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_QUICK.S
@@ -0,0 +1,25 @@
+%verify "executed"
+%verify "null object"
+    /* For: iput-quick, iput-object-quick */
+    /* op vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    GET_VREG(r3, r2)                    @ r3<- fp[B], the object pointer
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
+    beq     common_errNullObject        @ object was null
+    and     r2, r2, #15
+    GET_VREG(r0, r2)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_SHORT.S b/vm/mterp/armv5te_taint/OP_IPUT_SHORT.S
new file mode 100644
index 0000000..2944840
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_SHORT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+@include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"4" }
+%include "armv5te_taint/OP_IPUT.S" { "store":"str", "sqnum":"4" }
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_WIDE.S b/vm/mterp/armv5te_taint/OP_IPUT_WIDE.S
new file mode 100644
index 0000000..4f319d0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_WIDE.S
@@ -0,0 +1,52 @@
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /* iput-wide vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish up
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r10, [r2, #4]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_IPUT_WIDE_QUICK.S b/vm/mterp/armv5te_taint/OP_IPUT_WIDE_QUICK.S
new file mode 100644
index 0000000..1ebcfe0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_IPUT_WIDE_QUICK.S
@@ -0,0 +1,31 @@
+%verify "executed"
+%verify "null object"
+    /* iput-wide-quick vA, vB, offset@CCCC */
+    mov     r0, rINST, lsr #8           @ r0<- A(+)
+    mov     r1, rINST, lsr #12          @ r1<- B
+    and     r0, r0, #15
+    GET_VREG(r2, r1)                    @ r2<- fp[B], the object pointer
+// begin WITH_TAINT_TRACKING
+	bl iput_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
+    beq     common_errNullObject        @ object was null
+    FETCH(r3, 1)                        @ r3<- field byte offset
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    strd    r0, [r2, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r9, [r2, r3]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+iput_wide_quick_taint_prop:
+    add     r3, rFP, r0, lsl #3         @ r3<- &fp[A]
+    cmp     r2, #0                      @ check object for null
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r9, [r3, #4]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_LONG_TO_DOUBLE.S b/vm/mterp/armv5te_taint/OP_LONG_TO_DOUBLE.S
new file mode 100644
index 0000000..da6fc00
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_LONG_TO_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWide.S" {"instr":"bl      __aeabi_l2d"}
diff --git a/vm/mterp/armv5te_taint/OP_LONG_TO_FLOAT.S b/vm/mterp/armv5te_taint/OP_LONG_TO_FLOAT.S
new file mode 100644
index 0000000..4a70215
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_LONG_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopNarrower.S" {"instr":"bl      __aeabi_l2f"}
diff --git a/vm/mterp/armv5te_taint/OP_LONG_TO_INT.S b/vm/mterp/armv5te_taint/OP_LONG_TO_INT.S
new file mode 100644
index 0000000..9ae56fb
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_LONG_TO_INT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* we ignore the high word, making this equivalent to a 32-bit reg move */
+%include "armv5te_taint/OP_MOVE.S"
diff --git a/vm/mterp/armv5te_taint/OP_MONITOR_ENTER.S b/vm/mterp/armv5te_taint/OP_MONITOR_ENTER.S
new file mode 100644
index 0000000..524621a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MONITOR_ENTER.S
@@ -0,0 +1,23 @@
+%verify "executed"
+%verify "exception for null object"
+    /*
+     * Synchronize on an object.
+     */
+    /* monitor-enter vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    GET_VREG(r1, r2)                    @ r1<- vAA (object)
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    cmp     r1, #0                      @ null object?
+    EXPORT_PC()                         @ need for precise GC, MONITOR_TRACKING
+    beq     common_errNullObject        @ null object, throw an exception
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    bl      dvmLockObject               @ call(self, obj)
+#ifdef WITH_DEADLOCK_PREDICTION /* implies WITH_MONITOR_TRACKING */
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    ldr     r1, [r0, #offThread_exception] @ check for exception
+    cmp     r1, #0
+    bne     common_exceptionThrown      @ exception raised, bail out
+#endif
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MONITOR_EXIT.S b/vm/mterp/armv5te_taint/OP_MONITOR_EXIT.S
new file mode 100644
index 0000000..b334ae9
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MONITOR_EXIT.S
@@ -0,0 +1,24 @@
+%verify "executed"
+%verify "exception for null object (impossible in javac)"
+%verify "dvmUnlockObject fails"
+    /*
+     * Unlock an object.
+     *
+     * Exceptions that occur when unlocking a monitor need to appear as
+     * if they happened at the following instruction.  See the Dalvik
+     * instruction spec.
+     */
+    /* monitor-exit vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    EXPORT_PC()                         @ before fetch: export the PC
+    GET_VREG(r1, r2)                    @ r1<- vAA (object)
+    cmp     r1, #0                      @ null object?
+    beq     common_errNullObject        @ yes
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    bl      dvmUnlockObject             @ r0<- success for unlock(self, obj)
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yes, exception is pending
+    FETCH_ADVANCE_INST(1)               @ before throw: advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE.S b/vm/mterp/armv5te_taint/OP_MOVE.S
new file mode 100644
index 0000000..6ac4234
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE.S
@@ -0,0 +1,17 @@
+%verify "executed"
+    /* for move, move-object, long-to-int */
+    /* op vA, vB */
+    mov     r1, rINST, lsr #12          @ r1<- B from 15:12
+    mov     r0, rINST, lsr #8           @ r0<- A from 11:8
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    GET_VREG(r2, r1)                    @ r2<- fp[B]
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    SET_VREG(r2, r0)                    @ fp[A]<- r2
+    GOTO_OPCODE(ip)                     @ execute next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_16.S b/vm/mterp/armv5te_taint/OP_MOVE_16.S
new file mode 100644
index 0000000..5ba74b4
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_16.S
@@ -0,0 +1,16 @@
+%verify "executed"
+    /* for: move/16, move-object/16 */
+    /* op vAAAA, vBBBB */
+    FETCH(r1, 2)                        @ r1<- BBBB
+    FETCH(r0, 1)                        @ r0<- AAAA
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r2, r0)                    @ fp[AAAA]<- r2
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_EXCEPTION.S b/vm/mterp/armv5te_taint/OP_MOVE_EXCEPTION.S
new file mode 100644
index 0000000..9b3ae00
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_EXCEPTION.S
@@ -0,0 +1,17 @@
+%verify "executed"
+    /* move-exception vAA */
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    ldr     r3, [r0, #offThread_exception]  @ r3<- dvmGetException bypass
+    mov     r1, #0                      @ r1<- 0
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    SET_VREG(r3, r2)                    @ fp[AA]<- exception obj
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	SET_TAINT_CLEAR(r9)
+	SET_VREG_TAINT(r9, r2, r3)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r1, [r0, #offThread_exception]  @ dvmClearException bypass
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_FROM16.S b/vm/mterp/armv5te_taint/OP_MOVE_FROM16.S
new file mode 100644
index 0000000..2db944a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_FROM16.S
@@ -0,0 +1,16 @@
+%verify "executed"
+    /* for: move/from16, move-object/from16 */
+    /* op vAA, vBBBB */
+    FETCH(r1, 1)                        @ r1<- BBBB
+    mov     r0, rINST, lsr #8           @ r0<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r2, r0)                    @ fp[AA]<- r2
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_OBJECT.S b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT.S
new file mode 100644
index 0000000..0c2f8fa
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_MOVE.S"
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_16.S b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_16.S
new file mode 100644
index 0000000..6acec7d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_MOVE_16.S"
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_FROM16.S b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_FROM16.S
new file mode 100644
index 0000000..1df9a41
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_OBJECT_FROM16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_MOVE_FROM16.S"
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_RESULT.S b/vm/mterp/armv5te_taint/OP_MOVE_RESULT.S
new file mode 100644
index 0000000..28d47c3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_RESULT.S
@@ -0,0 +1,15 @@
+%verify "executed"
+    /* for: move-result, move-result-object */
+    /* op vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_RESULT_OBJECT.S b/vm/mterp/armv5te_taint/OP_MOVE_RESULT_OBJECT.S
new file mode 100644
index 0000000..3d3620a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_RESULT_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_MOVE_RESULT.S"
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_RESULT_WIDE.S b/vm/mterp/armv5te_taint/OP_MOVE_RESULT_WIDE.S
new file mode 100644
index 0000000..0c8fc41
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_RESULT_WIDE.S
@@ -0,0 +1,20 @@
+%verify "executed"
+    /* move-result-wide vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    ldmia   r3, {r0-r1}                 @ r0/r1<- retval.j
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+	ldr r3, [rGLUE, #offGlue_rtaint]
+	str	r0, [r2, #0]
+	str r3, [r2, #4]
+	str r1, [r2, #8]
+	str r3, [r2, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_WIDE.S b/vm/mterp/armv5te_taint/OP_MOVE_WIDE.S
new file mode 100644
index 0000000..9240f0d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_WIDE.S
@@ -0,0 +1,18 @@
+%verify "executed"
+    /* move-wide vA, vB */
+    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r2, r2, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[A]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[B]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[A]<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_WIDE_16.S b/vm/mterp/armv5te_taint/OP_MOVE_WIDE_16.S
new file mode 100644
index 0000000..40d448d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_WIDE_16.S
@@ -0,0 +1,17 @@
+%verify "executed"
+    /* move-wide/16 vAAAA, vBBBB */
+    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    FETCH(r3, 2)                        @ r3<- BBBB
+    FETCH(r2, 1)                        @ r2<- AAAA
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AAAA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AAAA]<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MOVE_WIDE_FROM16.S b/vm/mterp/armv5te_taint/OP_MOVE_WIDE_FROM16.S
new file mode 100644
index 0000000..8e17891
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MOVE_WIDE_FROM16.S
@@ -0,0 +1,17 @@
+%verify "executed"
+    /* move-wide/from16 vAA, vBBBB */
+    /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    FETCH(r3, 1)                        @ r3<- BBBB
+    mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AA]<- r0/r1
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_MUL_DOUBLE.S b/vm/mterp/armv5te_taint/OP_MUL_DOUBLE.S
new file mode 100644
index 0000000..348f7cf
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_dmul"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_DOUBLE_2ADDR.S b/vm/mterp/armv5te_taint/OP_MUL_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..3a77339
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_dmul"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_FLOAT.S b/vm/mterp/armv5te_taint/OP_MUL_FLOAT.S
new file mode 100644
index 0000000..788d975
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"bl      __aeabi_fmul"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_FLOAT_2ADDR.S b/vm/mterp/armv5te_taint/OP_MUL_FLOAT_2ADDR.S
new file mode 100644
index 0000000..7eb5364
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      __aeabi_fmul"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_INT.S b/vm/mterp/armv5te_taint/OP_MUL_INT.S
new file mode 100644
index 0000000..08ac7d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_INT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
+%include "armv5te_taint/binop.S" {"instr":"mul     r0, r1, r0"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_MUL_INT_2ADDR.S
new file mode 100644
index 0000000..544b1d6
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_INT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
+%include "armv5te_taint/binop2addr.S" {"instr":"mul     r0, r1, r0"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_MUL_INT_LIT16.S
new file mode 100644
index 0000000..1ca060a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_INT_LIT16.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
+%include "armv5te_taint/binopLit16.S" {"instr":"mul     r0, r1, r0"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_MUL_INT_LIT8.S
new file mode 100644
index 0000000..c97f476
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_INT_LIT8.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
+%include "armv5te_taint/binopLit8.S" {"instr":"mul     r0, r1, r0"}
diff --git a/vm/mterp/armv5te_taint/OP_MUL_LONG.S b/vm/mterp/armv5te_taint/OP_MUL_LONG.S
new file mode 100644
index 0000000..663900f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_LONG.S
@@ -0,0 +1,64 @@
+%verify "executed"
+    /*
+     * Signed 64-bit integer multiply.
+     *
+     * Consider WXxYZ (r1r0 x r3r2) with a long multiply:
+     *        WX
+     *      x YZ
+     *  --------
+     *     ZW ZX
+     *  YW YX
+     *
+     * The low word of the result holds ZX, the high word holds
+     * (ZW+YX) + (the high overflow from ZX).  YW doesn't matter because
+     * it doesn't fit in the low 64 bits.
+     *
+     * Unlike most ARM math operations, multiply instructions have
+     * restrictions on using the same register more than once (Rd and Rm
+     * cannot be the same).
+     */
+    /* mul-long vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+// begin WITH_TAINT_TRACKING
+    bl		mul_long_taint_prop
+// end WITH_TAINT_TRACKING
+    mul     ip, r2, r1                  @  ip<- ZxW
+    umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
+    mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
+    mov     r0, rINST, lsr #8           @ r0<- AA
+    add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
+// begin WITH_TAINT_TRACKING
+    add     r0, rFP, r0, lsl #3         @ r0<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+mul_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_MUL_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_MUL_LONG_2ADDR.S
new file mode 100644
index 0000000..4440c88
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_MUL_LONG_2ADDR.S
@@ -0,0 +1,49 @@
+%verify "executed"
+    /*
+     * Signed 64-bit integer multiply, "/2addr" version.
+     *
+     * See OP_MUL_LONG for an explanation.
+     *
+     * We get a little tight on registers, so to avoid looking up &fp[A]
+     * again we stuff it into rINST.
+     */
+    /* mul-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r1, rINST, lsr #12          @ r1<- B
+// begin WITH_TAINT_TRACKING
+	bl		mul_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
+    umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
+    mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
+    mov     r0, rINST                   @ r0<- &fp[A] (free up rINST)
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+%break
+
+mul_long_2addr_taint_prop:
+    and     r9, r9, #15
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     rINST, rFP, r9, lsl #3      @ rINST<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r9, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
+    ldr		r0, [rINST, #0]
+    ldr		r10, [rINST, #4]
+    ldr		r1, [rINST, #8]
+	orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	mul     ip, r2, r1                  @  ip<- ZxW
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_NEG_DOUBLE.S b/vm/mterp/armv5te_taint/OP_NEG_DOUBLE.S
new file mode 100644
index 0000000..08533d2
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEG_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWide.S" {"instr":"add     r1, r1, #0x80000000"}
diff --git a/vm/mterp/armv5te_taint/OP_NEG_FLOAT.S b/vm/mterp/armv5te_taint/OP_NEG_FLOAT.S
new file mode 100644
index 0000000..3e58179
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEG_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"instr":"add     r0, r0, #0x80000000"}
diff --git a/vm/mterp/armv5te_taint/OP_NEG_INT.S b/vm/mterp/armv5te_taint/OP_NEG_INT.S
new file mode 100644
index 0000000..39ae8a3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEG_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"instr":"rsb     r0, r0, #0"}
diff --git a/vm/mterp/armv5te_taint/OP_NEG_LONG.S b/vm/mterp/armv5te_taint/OP_NEG_LONG.S
new file mode 100644
index 0000000..a3aeade
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEG_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWide.S" {"preinstr":"rsbs    r0, r0, #0", "instr":"rsc     r1, r1, #0"}
diff --git a/vm/mterp/armv5te_taint/OP_NEW_ARRAY.S b/vm/mterp/armv5te_taint/OP_NEW_ARRAY.S
new file mode 100644
index 0000000..d0c4bee
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEW_ARRAY.S
@@ -0,0 +1,67 @@
+%verify "executed"
+%verify "negative array length"
+%verify "allocation fails"
+    /*
+     * Allocate an array of objects, specified with the array class
+     * and a count.
+     *
+     * The verifier guarantees that this is an array class, so we don't
+     * check for it here.
+     */
+    /* new-array vA, vB, class@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    FETCH(r2, 1)                        @ r2<- CCCC
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    GET_VREG(r1, r0)                    @ r1<- vB (array length)
+    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
+    cmp     r1, #0                      @ check length
+    ldr     r0, [r3, r2, lsl #2]        @ r0<- resolved class
+    bmi     common_errNegativeArraySize @ negative length, bail
+    cmp     r0, #0                      @ already resolved?
+    EXPORT_PC()                         @ req'd for resolve, alloc
+    bne     .L${opcode}_finish          @ resolved, continue
+    b       .L${opcode}_resolve         @ do resolve now
+%break
+
+
+    /*
+     * Resolve class.  (This is an uncommon case.)
+     *
+     *  r1 holds array length
+     *  r2 holds class ref CCCC
+     */
+.L${opcode}_resolve:
+    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    mov     r9, r1                      @ r9<- length (save)
+    mov     r1, r2                      @ r1<- CCCC
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- call(clazz, ref)
+    cmp     r0, #0                      @ got null?
+    mov     r1, r9                      @ r1<- length (restore)
+    beq     common_exceptionThrown      @ yes, handle exception
+    @ fall through to ${opcode}_finish
+
+    /*
+     * Finish allocation.
+     *
+     *  r0 holds class
+     *  r1 holds array length
+     */
+.L${opcode}_finish:
+    mov     r2, #ALLOC_DONT_TRACK       @ don't track in local refs table
+    bl      dvmAllocArrayByClass        @ r0<- call(clazz, length, flags)
+    cmp     r0, #0                      @ failed?
+    mov     r2, rINST, lsr #8           @ r2<- A+
+    beq     common_exceptionThrown      @ yes, handle the exception
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ vA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv5te_taint/OP_NEW_INSTANCE.S b/vm/mterp/armv5te_taint/OP_NEW_INSTANCE.S
new file mode 100644
index 0000000..322d37b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NEW_INSTANCE.S
@@ -0,0 +1,74 @@
+%verify "executed"
+%verify "class not resolved"
+%verify "class cannot be resolved"
+%verify "class not initialized"
+%verify "class fails to initialize"
+%verify "class already resolved/initialized"
+%verify "class is abstract or interface"
+%verify "allocation fails"
+    /*
+     * Create a new instance of a class.
+     */
+    /* new-instance vAA, class@BBBB */
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
+    FETCH(r1, 1)                        @ r1<- BBBB
+    ldr     r3, [r3, #offDvmDex_pResClasses]    @ r3<- pDvmDex->pResClasses
+    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved class
+    EXPORT_PC()                         @ req'd for init, resolve, alloc
+    cmp     r0, #0                      @ already resolved?
+    beq     .L${opcode}_resolve         @ no, resolve it now
+.L${opcode}_resolved:   @ r0=class
+    ldrb    r1, [r0, #offClassObject_status]    @ r1<- ClassStatus enum
+    cmp     r1, #CLASS_INITIALIZED      @ has class been initialized?
+    bne     .L${opcode}_needinit        @ no, init class now
+.L${opcode}_initialized: @ r0=class
+    mov     r1, #ALLOC_DONT_TRACK       @ flags for alloc call
+    bl      dvmAllocObject              @ r0<- new object
+    b       .L${opcode}_finish          @ continue
+%break
+
+    .balign 32                          @ minimize cache lines
+.L${opcode}_finish: @ r0=new object
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    cmp     r0, #0                      @ failed?
+    beq     common_exceptionThrown      @ yes, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r3)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * Class initialization required.
+     *
+     *  r0 holds class object
+     */
+.L${opcode}_needinit:
+    mov     r9, r0                      @ save r0
+    bl      dvmInitClass                @ initialize class
+    cmp     r0, #0                      @ check boolean result
+    mov     r0, r9                      @ restore r0
+    bne     .L${opcode}_initialized     @ success, continue
+    b       common_exceptionThrown      @ failed, deal with init exception
+
+    /*
+     * Resolution required.  This is the least-likely path.
+     *
+     *  r1 holds BBBB
+     */
+.L${opcode}_resolve:
+    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
+    mov     r2, #0                      @ r2<- false
+    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveClass             @ r0<- resolved ClassObject ptr
+    cmp     r0, #0                      @ got null?
+    bne     .L${opcode}_resolved        @ no, continue
+    b       common_exceptionThrown      @ yes, handle exception
+
+.LstrInstantiationErrorPtr:
+    .word   .LstrInstantiationError
+
diff --git a/vm/mterp/armv5te_taint/OP_NOP.S b/vm/mterp/armv5te_taint/OP_NOP.S
new file mode 100644
index 0000000..1b72d3c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NOP.S
@@ -0,0 +1,15 @@
+%verify "executed"
+    FETCH_ADVANCE_INST(1)               @ advance to next instr, load rINST
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    GOTO_OPCODE(ip)                     @ execute it
+
+#ifdef ASSIST_DEBUGGER
+    /* insert fake function header to help gdb find the stack frame */
+    .type   dalvik_inst, %function
+dalvik_inst:
+    .fnstart
+    MTERP_ENTRY1
+    MTERP_ENTRY2
+    .fnend
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_NOT_INT.S b/vm/mterp/armv5te_taint/OP_NOT_INT.S
new file mode 100644
index 0000000..604828f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NOT_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unop.S" {"instr":"mvn     r0, r0"}
diff --git a/vm/mterp/armv5te_taint/OP_NOT_LONG.S b/vm/mterp/armv5te_taint/OP_NOT_LONG.S
new file mode 100644
index 0000000..ecf4d6c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_NOT_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/unopWide.S" {"preinstr":"mvn     r0, r0", "instr":"mvn     r1, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_INT.S b/vm/mterp/armv5te_taint/OP_OR_INT.S
new file mode 100644
index 0000000..687447a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"orr     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_OR_INT_2ADDR.S
new file mode 100644
index 0000000..f1c23a0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"orr     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_OR_INT_LIT16.S
new file mode 100644
index 0000000..17d35ea
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_INT_LIT16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit16.S" {"instr":"orr     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_OR_INT_LIT8.S
new file mode 100644
index 0000000..0d61dd9
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"orr     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_LONG.S b/vm/mterp/armv5te_taint/OP_OR_LONG.S
new file mode 100644
index 0000000..6699ea4
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"preinstr":"orr     r0, r0, r2", "instr":"orr     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_OR_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_OR_LONG_2ADDR.S
new file mode 100644
index 0000000..f9f4fba
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_OR_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"preinstr":"orr     r0, r0, r2", "instr":"orr     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_PACKED_SWITCH.S b/vm/mterp/armv5te_taint/OP_PACKED_SWITCH.S
new file mode 100644
index 0000000..72e742a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_PACKED_SWITCH.S
@@ -0,0 +1,35 @@
+%default { "func":"dvmInterpHandlePackedSwitch" }
+%verify executed
+    /*
+     * Handle a packed-switch or sparse-switch instruction.  In both cases
+     * we decode it and hand it off to a helper function.
+     *
+     * We don't really expect backward branches in a switch statement, but
+     * they're perfectly legal, so we check for them here.
+     *
+     * for: packed-switch, sparse-switch
+     */
+    /* op vAA, +BBBB */
+    FETCH(r0, 1)                        @ r0<- bbbb (lo)
+    FETCH(r1, 2)                        @ r1<- BBBB (hi)
+    mov     r3, rINST, lsr #8           @ r3<- AA
+    orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb
+    GET_VREG(r1, r3)                    @ r1<- vAA
+    add     r0, rPC, r0, lsl #1         @ r0<- PC + BBBBbbbb*2
+    bl      $func                       @ r0<- code-unit branch offset
+    movs    r9, r0, asl #1              @ r9<- branch byte offset, check sign
+    bmi     common_backwardBranch       @ backward branch, do periodic checks
+    beq     common_backwardBranch       @ (want to use BLE but V is unknown)
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
diff --git a/vm/mterp/armv5te_taint/OP_REM_DOUBLE.S b/vm/mterp/armv5te_taint/OP_REM_DOUBLE.S
new file mode 100644
index 0000000..315a453
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_DOUBLE.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* EABI doesn't define a double remainder function, but libm does */
+%include "armv5te_taint/binopWide.S" {"instr":"bl      fmod"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_DOUBLE_2ADDR.S b/vm/mterp/armv5te_taint/OP_REM_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..037f7b2
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_DOUBLE_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* EABI doesn't define a double remainder function, but libm does */
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      fmod"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_FLOAT.S b/vm/mterp/armv5te_taint/OP_REM_FLOAT.S
new file mode 100644
index 0000000..8dda456
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_FLOAT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* EABI doesn't define a float remainder function, but libm does */
+%include "armv5te_taint/binop.S" {"instr":"bl      fmodf"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_FLOAT_2ADDR.S b/vm/mterp/armv5te_taint/OP_REM_FLOAT_2ADDR.S
new file mode 100644
index 0000000..70eaa30
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_FLOAT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* EABI doesn't define a float remainder function, but libm does */
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      fmodf"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_INT.S b/vm/mterp/armv5te_taint/OP_REM_INT.S
new file mode 100644
index 0000000..02bf805
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_INT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* idivmod returns quotient in r0 and remainder in r1 */
+%include "armv5te_taint/binop.S" {"instr":"bl      __aeabi_idivmod", "result":"r1", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_REM_INT_2ADDR.S
new file mode 100644
index 0000000..bd3484f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_INT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* idivmod returns quotient in r0 and remainder in r1 */
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      __aeabi_idivmod", "result":"r1", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_REM_INT_LIT16.S
new file mode 100644
index 0000000..f0c417d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_INT_LIT16.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* idivmod returns quotient in r0 and remainder in r1 */
+%include "armv5te_taint/binopLit16.S" {"instr":"bl      __aeabi_idivmod", "result":"r1", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_REM_INT_LIT8.S
new file mode 100644
index 0000000..4b4041f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_INT_LIT8.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* idivmod returns quotient in r0 and remainder in r1 */
+%include "armv5te_taint/binopLit8.S" {"instr":"bl      __aeabi_idivmod", "result":"r1", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_LONG.S b/vm/mterp/armv5te_taint/OP_REM_LONG.S
new file mode 100644
index 0000000..dddcde3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_LONG.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_ldivmod", "result0":"r2", "result1":"r3", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_REM_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_REM_LONG_2ADDR.S
new file mode 100644
index 0000000..631e6ea
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_REM_LONG_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_ldivmod", "result0":"r2", "result1":"r3", "chkzero":"1"}
diff --git a/vm/mterp/armv5te_taint/OP_RETURN.S b/vm/mterp/armv5te_taint/OP_RETURN.S
new file mode 100644
index 0000000..89c85e2
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RETURN.S
@@ -0,0 +1,18 @@
+%verify "executed"
+    /*
+     * Return a 32-bit value.  Copies the return value into the "glue"
+     * structure, then jumps to the return handler.
+     *
+     * for: return, return-object
+     */
+    /* op vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    GET_VREG(r0, r2)                    @ r0<- vAA
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r3, r2, r1)
+	str		r3, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
+    str     r0, [rGLUE, #offGlue_retval] @ retval.i <- vAA
+    b       common_returnFromMethod
+
diff --git a/vm/mterp/armv5te_taint/OP_RETURN_OBJECT.S b/vm/mterp/armv5te_taint/OP_RETURN_OBJECT.S
new file mode 100644
index 0000000..2febd99
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RETURN_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_RETURN.S"
diff --git a/vm/mterp/armv5te_taint/OP_RETURN_VOID.S b/vm/mterp/armv5te_taint/OP_RETURN_VOID.S
new file mode 100644
index 0000000..5442021
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RETURN_VOID.S
@@ -0,0 +1,5 @@
+%verify "executed"
+	SET_TAINT_CLEAR(r1)
+	str		r1, [rGLUE, #offGlue_rtaint]
+    b       common_returnFromMethod
+
diff --git a/vm/mterp/armv5te_taint/OP_RETURN_WIDE.S b/vm/mterp/armv5te_taint/OP_RETURN_WIDE.S
new file mode 100644
index 0000000..42eaf6f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RETURN_WIDE.S
@@ -0,0 +1,21 @@
+%verify "executed"
+    /*
+     * Return a 64-bit value.  Copies the return value into the "glue"
+     * structure, then jumps to the return handler.
+     */
+    /* return-wide vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r9, [r2, #4]
+	str		r9, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
+    stmia   r3, {r0-r1}                 @ retval<- r0/r1
+    b       common_returnFromMethod
+
diff --git a/vm/mterp/armv5te_taint/OP_RSUB_INT.S b/vm/mterp/armv5te_taint/OP_RSUB_INT.S
new file mode 100644
index 0000000..92d25a6
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RSUB_INT.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */
+%include "armv5te_taint/binopLit16.S" {"instr":"rsb     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_RSUB_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_RSUB_INT_LIT8.S
new file mode 100644
index 0000000..2118a4f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_RSUB_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"rsb     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SGET.S b/vm/mterp/armv5te_taint/OP_SGET.S
new file mode 100644
index 0000000..4bcd97d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET.S
@@ -0,0 +1,43 @@
+%verify "executed"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit SGET handler.
+     *
+     * for: sget, sget-object, sget-boolean, sget-byte, sget-char, sget-short
+     */
+    /* op vAA, field@BBBB */
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref BBBB
+    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    beq     .L${opcode}_resolve         @ yes, do resolve
+.L${opcode}_finish: @ field ptr in r0
+    ldr     r1, [r0, #offStaticField_value] @ r1<- field value
+    mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    SET_VREG(r1, r2)                    @ fp[AA]<- r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1: BBBB field ref
+     */
+.L${opcode}_resolve:
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish
+    b       common_exceptionThrown      @ no, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_SGET_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_SGET_BOOLEAN.S
new file mode 100644
index 0000000..4bcac59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_BOOLEAN.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_SGET_BYTE.S b/vm/mterp/armv5te_taint/OP_SGET_BYTE.S
new file mode 100644
index 0000000..4bcac59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_SGET_CHAR.S b/vm/mterp/armv5te_taint/OP_SGET_CHAR.S
new file mode 100644
index 0000000..4bcac59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_SGET_OBJECT.S b/vm/mterp/armv5te_taint/OP_SGET_OBJECT.S
new file mode 100644
index 0000000..4bcac59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_SGET_SHORT.S b/vm/mterp/armv5te_taint/OP_SGET_SHORT.S
new file mode 100644
index 0000000..4bcac59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SGET.S"
diff --git a/vm/mterp/armv5te_taint/OP_SGET_WIDE.S b/vm/mterp/armv5te_taint/OP_SGET_WIDE.S
new file mode 100644
index 0000000..f467fff
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SGET_WIDE.S
@@ -0,0 +1,47 @@
+%verify "executed"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * 64-bit SGET handler.
+     */
+    /* sget-wide vAA, field@BBBB */
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref BBBB
+    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    beq     .L${opcode}_resolve         @ yes, do resolve
+    b		.L${opcode}_finish
+
+%break
+
+.L${opcode}_finish:
+    mov     r1, rINST, lsr #8           @ r1<- AA
+    ldrd    r2, [r0, #offStaticField_value] @ r2/r3<- field value (aligned)
+// begin WITH_TAINT_TRACKING
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[AA]
+    ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+//    stmia   r1, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+	str		r2, [r1, #0]
+	str		r0, [r1, #4]
+	str		r3, [r1, #8]
+	str		r0, [r1, #12]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1: BBBB field ref
+     */
+.L${opcode}_resolve:
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish
+    b       common_exceptionThrown      @ no, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_SHL_INT.S b/vm/mterp/armv5te_taint/OP_SHL_INT.S
new file mode 100644
index 0000000..dd9c2ed
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHL_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asl r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHL_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_SHL_INT_2ADDR.S
new file mode 100644
index 0000000..f201b86
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHL_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asl r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHL_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_SHL_INT_LIT8.S
new file mode 100644
index 0000000..64024da
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHL_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asl r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHL_LONG.S b/vm/mterp/armv5te_taint/OP_SHL_LONG.S
new file mode 100644
index 0000000..2fe30b7
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHL_LONG.S
@@ -0,0 +1,50 @@
+%verify "executed"
+    /*
+     * Long integer shift.  This is different from the generic 32/64-bit
+     * binary operations because vAA/vBB are 64-bit but vCC (the shift
+     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low
+     * 6 bits of the shift distance.
+     */
+    /* shl-long vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r3, r0, #255                @ r3<- BB
+    mov     r0, r0, lsr #8              @ r0<- CC
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r1, r1, asl r2              @  r1<- r1 << r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r1, r1, r0, lsr r3          @  r1<- r1 | (r0 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    movpl   r1, r0, asl ip              @  if r2 >= 32, r1<- r0 << (r2-32)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    mov     r0, r0, asl r2              @  r0<- r0 << r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+shl_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_SHL_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_SHL_LONG_2ADDR.S
new file mode 100644
index 0000000..1ae33f7
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHL_LONG_2ADDR.S
@@ -0,0 +1,46 @@
+%verify "executed"
+    /*
+     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
+     * 32-bit shift distance.
+     */
+    /* shl-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+    GET_VREG(r2, r3)                    @ r2<- vB
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r1, r1, asl r2              @  r1<- r1 << r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r1, r1, r0, lsr r3          @  r1<- r1 | (r0 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    movpl   r1, r0, asl ip              @  if r2 >= 32, r1<- r0 << (r2-32)
+    mov     r0, r0, asl r2              @  r0<- r0 << r2
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+shl_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_SHR_INT.S b/vm/mterp/armv5te_taint/OP_SHR_INT.S
new file mode 100644
index 0000000..36ab4f5
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHR_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHR_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_SHR_INT_2ADDR.S
new file mode 100644
index 0000000..d2e21e5
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHR_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_SHR_INT_LIT8.S
new file mode 100644
index 0000000..7ef339a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHR_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SHR_LONG.S b/vm/mterp/armv5te_taint/OP_SHR_LONG.S
new file mode 100644
index 0000000..c370d26
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHR_LONG.S
@@ -0,0 +1,50 @@
+%verify "executed"
+    /*
+     * Long integer shift.  This is different from the generic 32/64-bit
+     * binary operations because vAA/vBB are 64-bit but vCC (the shift
+     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low
+     * 6 bits of the shift distance.
+     */
+    /* shr-long vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r3, r0, #255                @ r3<- BB
+    mov     r0, r0, lsr #8              @ r0<- CC
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r0, r0, lsr r2              @  r0<- r2 >> r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r0, r0, r1, asl r3          @  r0<- r0 | (r1 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    movpl   r0, r1, asr ip              @  if r2 >= 32, r0<-r1 >> (r2-32)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    mov     r1, r1, asr r2              @  r1<- r1 >> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+shr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_SHR_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_SHR_LONG_2ADDR.S
new file mode 100644
index 0000000..eb1f66d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SHR_LONG_2ADDR.S
@@ -0,0 +1,47 @@
+%verify "executed"
+    /*
+     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
+     * 32-bit shift distance.
+     */
+    /* shr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+    GET_VREG(r2, r3)                    @ r2<- vB
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r0, r0, lsr r2              @  r0<- r2 >> r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r0, r0, r1, asl r3          @  r0<- r0 | (r1 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    movpl   r0, r1, asr ip              @  if r2 >= 32, r0<-r1 >> (r2-32)
+    mov     r1, r1, asr r2              @  r1<- r1 >> r2
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+// OP_SHR_LONG_2ADDR.S
+shr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_SPARSE_SWITCH.S b/vm/mterp/armv5te_taint/OP_SPARSE_SWITCH.S
new file mode 100644
index 0000000..c3fd086
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPARSE_SWITCH.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_PACKED_SWITCH.S" { "func":"dvmInterpHandleSparseSwitch" }
diff --git a/vm/mterp/armv5te_taint/OP_SPUT.S b/vm/mterp/armv5te_taint/OP_SPUT.S
new file mode 100644
index 0000000..78c8406
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT.S
@@ -0,0 +1,43 @@
+%verify "executed"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit SPUT handler.
+     *
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
+     */
+    /* op vAA, field@BBBB */
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref BBBB
+    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    beq     .L${opcode}_resolve         @ yes, do resolve
+.L${opcode}_finish:   @ field ptr in r0
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_VREG(r1, r2)                    @ r1<- fp[AA]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1: BBBB field ref
+     */
+.L${opcode}_resolve:
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish
+    b       common_exceptionThrown      @ no, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_BOOLEAN.S b/vm/mterp/armv5te_taint/OP_SPUT_BOOLEAN.S
new file mode 100644
index 0000000..c4287d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_BOOLEAN.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_BYTE.S b/vm/mterp/armv5te_taint/OP_SPUT_BYTE.S
new file mode 100644
index 0000000..c4287d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_CHAR.S b/vm/mterp/armv5te_taint/OP_SPUT_CHAR.S
new file mode 100644
index 0000000..c4287d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_OBJECT.S b/vm/mterp/armv5te_taint/OP_SPUT_OBJECT.S
new file mode 100644
index 0000000..c4287d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_OBJECT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_SHORT.S b/vm/mterp/armv5te_taint/OP_SPUT_SHORT.S
new file mode 100644
index 0000000..c4287d1
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/OP_SPUT.S"
diff --git a/vm/mterp/armv5te_taint/OP_SPUT_WIDE.S b/vm/mterp/armv5te_taint/OP_SPUT_WIDE.S
new file mode 100644
index 0000000..5c41824
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SPUT_WIDE.S
@@ -0,0 +1,48 @@
+%verify "executed"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * 64-bit SPUT handler.
+     */
+    /* sput-wide vAA, field@BBBB */
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref BBBB
+    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    cmp     r0, #0                      @ is resolved entry null?
+    beq     .L${opcode}_resolve         @ yes, do resolve
+.L${opcode}_finish: @ field ptr in r0, AA in r9
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr r1, [r9, #4]
+	ldr r2, [r9, #0]
+	ldr r3, [r9, #8]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r2, [r0, #offStaticField_value] @ field<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+    str		r1, [r0, #offStaticField_taint]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+%break
+
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1: BBBB field ref
+     *  r9: &fp[AA]
+     */
+.L${opcode}_resolve:
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish
+    b       common_exceptionThrown      @ no, handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_SUB_DOUBLE.S b/vm/mterp/armv5te_taint/OP_SUB_DOUBLE.S
new file mode 100644
index 0000000..b591d80
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_DOUBLE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"instr":"bl      __aeabi_dsub"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_DOUBLE_2ADDR.S b/vm/mterp/armv5te_taint/OP_SUB_DOUBLE_2ADDR.S
new file mode 100644
index 0000000..ad3a16a
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_DOUBLE_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"instr":"bl      __aeabi_dsub"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_FLOAT.S b/vm/mterp/armv5te_taint/OP_SUB_FLOAT.S
new file mode 100644
index 0000000..c25776e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"bl      __aeabi_fsub"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_FLOAT_2ADDR.S b/vm/mterp/armv5te_taint/OP_SUB_FLOAT_2ADDR.S
new file mode 100644
index 0000000..f731511
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"bl      __aeabi_fsub"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_INT.S b/vm/mterp/armv5te_taint/OP_SUB_INT.S
new file mode 100644
index 0000000..4e82c82
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"sub     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_SUB_INT_2ADDR.S
new file mode 100644
index 0000000..30dbbf2
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"sub     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_LONG.S b/vm/mterp/armv5te_taint/OP_SUB_LONG.S
new file mode 100644
index 0000000..095a00c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"preinstr":"subs    r0, r0, r2", "instr":"sbc     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_SUB_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_SUB_LONG_2ADDR.S
new file mode 100644
index 0000000..105c70f
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_SUB_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"preinstr":"subs    r0, r0, r2", "instr":"sbc     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_THROW.S b/vm/mterp/armv5te_taint/OP_THROW.S
new file mode 100644
index 0000000..c8c5c36
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_THROW.S
@@ -0,0 +1,15 @@
+%verify "executed"
+%verify "exception for null object"
+    /*
+     * Throw an exception object in the current thread.
+     */
+    /* throw vAA */
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    GET_VREG(r1, r2)                    @ r1<- vAA (exception object)
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    cmp     r1, #0                      @ null object?
+    beq     common_errNullObject        @ yes, throw an NPE instead
+    @ bypass dvmSetException, just store it
+    str     r1, [r0, #offThread_exception]  @ thread->exception<- obj
+    b       common_exceptionThrown
+
diff --git a/vm/mterp/armv5te_taint/OP_THROW_VERIFICATION_ERROR.S b/vm/mterp/armv5te_taint/OP_THROW_VERIFICATION_ERROR.S
new file mode 100644
index 0000000..0ed928b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_THROW_VERIFICATION_ERROR.S
@@ -0,0 +1,14 @@
+%verify executed
+    /*
+     * Handle a throw-verification-error instruction.  This throws an
+     * exception for an error discovered during verification.  The
+     * exception is indicated by AA, with some detail provided by BBBB.
+     */
+    /* op AA, ref@BBBB */
+    ldr     r0, [rGLUE, #offGlue_method]    @ r0<- glue->method
+    FETCH(r2, 1)                        @ r2<- BBBB
+    EXPORT_PC()                         @ export the PC
+    mov     r1, rINST, lsr #8           @ r1<- AA
+    bl      dvmThrowVerificationError   @ always throws
+    b       common_exceptionThrown      @ handle exception
+
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_3E.S b/vm/mterp/armv5te_taint/OP_UNUSED_3E.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_3E.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_3F.S b/vm/mterp/armv5te_taint/OP_UNUSED_3F.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_3F.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_40.S b/vm/mterp/armv5te_taint/OP_UNUSED_40.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_40.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_41.S b/vm/mterp/armv5te_taint/OP_UNUSED_41.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_41.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_42.S b/vm/mterp/armv5te_taint/OP_UNUSED_42.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_42.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_43.S b/vm/mterp/armv5te_taint/OP_UNUSED_43.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_43.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_73.S b/vm/mterp/armv5te_taint/OP_UNUSED_73.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_73.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_79.S b/vm/mterp/armv5te_taint/OP_UNUSED_79.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_79.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_7A.S b/vm/mterp/armv5te_taint/OP_UNUSED_7A.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_7A.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E3.S b/vm/mterp/armv5te_taint/OP_UNUSED_E3.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E3.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E4.S b/vm/mterp/armv5te_taint/OP_UNUSED_E4.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E4.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E5.S b/vm/mterp/armv5te_taint/OP_UNUSED_E5.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E5.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E6.S b/vm/mterp/armv5te_taint/OP_UNUSED_E6.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E6.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E7.S b/vm/mterp/armv5te_taint/OP_UNUSED_E7.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E7.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E8.S b/vm/mterp/armv5te_taint/OP_UNUSED_E8.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E8.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_E9.S b/vm/mterp/armv5te_taint/OP_UNUSED_E9.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_E9.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_EA.S b/vm/mterp/armv5te_taint/OP_UNUSED_EA.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_EA.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_EB.S b/vm/mterp/armv5te_taint/OP_UNUSED_EB.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_EB.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_EC.S b/vm/mterp/armv5te_taint/OP_UNUSED_EC.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_EC.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_EF.S b/vm/mterp/armv5te_taint/OP_UNUSED_EF.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_EF.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_F1.S b/vm/mterp/armv5te_taint/OP_UNUSED_F1.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_F1.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_FC.S b/vm/mterp/armv5te_taint/OP_UNUSED_FC.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_FC.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_FD.S b/vm/mterp/armv5te_taint/OP_UNUSED_FD.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_FD.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_FE.S b/vm/mterp/armv5te_taint/OP_UNUSED_FE.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_FE.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_UNUSED_FF.S b/vm/mterp/armv5te_taint/OP_UNUSED_FF.S
new file mode 100644
index 0000000..aa4635d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_UNUSED_FF.S
@@ -0,0 +1 @@
+%include "armv5te_taint/unused.S"
diff --git a/vm/mterp/armv5te_taint/OP_USHR_INT.S b/vm/mterp/armv5te_taint/OP_USHR_INT.S
new file mode 100644
index 0000000..3a2b5df
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_USHR_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, lsr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_USHR_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_USHR_INT_2ADDR.S
new file mode 100644
index 0000000..ef27d16
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_USHR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, lsr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_USHR_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_USHR_INT_LIT8.S
new file mode 100644
index 0000000..b66bac0
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_USHR_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, lsr r1"}
diff --git a/vm/mterp/armv5te_taint/OP_USHR_LONG.S b/vm/mterp/armv5te_taint/OP_USHR_LONG.S
new file mode 100644
index 0000000..aa105df
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_USHR_LONG.S
@@ -0,0 +1,50 @@
+%verify "executed"
+    /*
+     * Long integer shift.  This is different from the generic 32/64-bit
+     * binary operations because vAA/vBB are 64-bit but vCC (the shift
+     * distance) is 32-bit.  Also, Dalvik requires us to mask off the low
+     * 6 bits of the shift distance.
+     */
+    /* ushr-long vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r3, r0, #255                @ r3<- BB
+    mov     r0, r0, lsr #8              @ r0<- CC
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r0, r0, lsr r2              @  r0<- r2 >> r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r0, r0, r1, asl r3          @  r0<- r0 | (r1 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    movpl   r0, r1, lsr ip              @  if r2 >= 32, r0<-r1 >>> (r2-32)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r0<- r0 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_USHR_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_USHR_LONG_2ADDR.S
new file mode 100644
index 0000000..e145567
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_USHR_LONG_2ADDR.S
@@ -0,0 +1,46 @@
+%verify "executed"
+    /*
+     * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
+     * 32-bit shift distance.
+     */
+    /* ushr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+    GET_VREG(r2, r3)                    @ r2<- vB
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
+
+    mov     r0, r0, lsr r2              @  r0<- r2 >> r2
+    rsb     r3, r2, #32                 @  r3<- 32 - r2
+    orr     r0, r0, r1, asl r3          @  r0<- r0 | (r1 << (32-r2))
+    subs    ip, r2, #32                 @  ip<- r2 - 32
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    movpl   r0, r1, lsr ip              @  if r2 >= 32, r0<-r1 >>> (r2-32)
+    mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
+    b       .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/OP_XOR_INT.S b/vm/mterp/armv5te_taint/OP_XOR_INT.S
new file mode 100644
index 0000000..9b992c3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop.S" {"instr":"eor     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_XOR_INT_2ADDR.S b/vm/mterp/armv5te_taint/OP_XOR_INT_2ADDR.S
new file mode 100644
index 0000000..623a33d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binop2addr.S" {"instr":"eor     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_XOR_INT_LIT16.S b/vm/mterp/armv5te_taint/OP_XOR_INT_LIT16.S
new file mode 100644
index 0000000..e3e7556
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_INT_LIT16.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit16.S" {"instr":"eor     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_XOR_INT_LIT8.S b/vm/mterp/armv5te_taint/OP_XOR_INT_LIT8.S
new file mode 100644
index 0000000..8242c37
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_INT_LIT8.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopLit8.S" {"instr":"eor     r0, r0, r1"}
diff --git a/vm/mterp/armv5te_taint/OP_XOR_LONG.S b/vm/mterp/armv5te_taint/OP_XOR_LONG.S
new file mode 100644
index 0000000..7abf4f6
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_LONG.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide.S" {"preinstr":"eor     r0, r0, r2", "instr":"eor     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/OP_XOR_LONG_2ADDR.S b/vm/mterp/armv5te_taint/OP_XOR_LONG_2ADDR.S
new file mode 100644
index 0000000..b5e4f9e
--- /dev/null
+++ b/vm/mterp/armv5te_taint/OP_XOR_LONG_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv5te_taint/binopWide2addr.S" {"preinstr":"eor     r0, r0, r2", "instr":"eor     r1, r1, r3"}
diff --git a/vm/mterp/armv5te_taint/bincmp.S b/vm/mterp/armv5te_taint/bincmp.S
new file mode 100644
index 0000000..1f43918
--- /dev/null
+++ b/vm/mterp/armv5te_taint/bincmp.S
@@ -0,0 +1,32 @@
+%verify "branch taken"
+%verify "branch not taken"
+    /*
+     * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
+     * fragment that specifies the *reverse* comparison to perform, e.g.
+     * for "if-le" you would use "gt".
+     *
+     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le
+     */
+    /* if-cmp vA, vB, +CCCC */
+    mov     r0, rINST, lsr #8           @ r0<- A+
+    mov     r1, rINST, lsr #12          @ r1<- B
+    and     r0, r0, #15
+    GET_VREG(r3, r1)                    @ r3<- vB
+    GET_VREG(r2, r0)                    @ r2<- vA
+    mov     r9, #4                      @ r0<- BYTE branch dist for not-taken
+    cmp     r2, r3                      @ compare (vA, vB)
+    b${revcmp}  1f                      @ branch to 1 if comparison failed
+    FETCH_S(r9, 1)                      @ r9<- branch offset, in code units
+    movs    r9, r9, asl #1              @ convert to bytes, check sign
+    bmi     common_backwardBranch       @ yes, do periodic checks
+1:
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    b        common_testUpdateProfile
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
diff --git a/vm/mterp/armv5te_taint/binop.S b/vm/mterp/armv5te_taint/binop.S
new file mode 100644
index 0000000..5da1972
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binop.S
@@ -0,0 +1,48 @@
+%default {"preinstr":"", "result":"r0", "chkzero":"0"}
+    /*
+     * Generic 32-bit binary operation.  Provide an "instr" line that
+     * specifies an instruction that performs "result = r0 op r1".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.  Note that we
+     * *don't* check for (INT_MIN / -1) here, because the ARM math lib
+     * handles it correctly.
+     *
+     * For: add-int, sub-int, mul-int, div-int, rem-int, and-int, or-int,
+     *      xor-int, shl-int, shr-int, ushr-int, add-float, sub-float,
+     *      mul-float, div-float, rem-float
+     */
+    /* binop vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    mov     r3, r0, lsr #8              @ r3<- CC
+    and     r2, r0, #255                @ r2<- BB
+    GET_VREG(r1, r3)                    @ r1<- vCC
+    GET_VREG(r0, r2)                    @ r0<- vBB
+    .if $chkzero
+    cmp     r1, #0                      @ is second operand zero?
+    beq     common_errDivideByZero
+    .endif
+
+// begin WITH_TAINT_TRACKING
+	bl		.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ $result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG($result, r9)               @ vAA<- $result
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 11-14 instructions */
+
+%break
+
+.L${opcode}_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/binop2addr.S b/vm/mterp/armv5te_taint/binop2addr.S
new file mode 100644
index 0000000..a643742
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binop2addr.S
@@ -0,0 +1,47 @@
+%default {"preinstr":"", "result":"r0", "chkzero":"0"}
+    /*
+     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = r0 op r1".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,
+     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,
+     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,
+     *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr
+     */
+    /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+    GET_VREG(r1, r3)                    @ r1<- vB
+    GET_VREG(r0, r9)                    @ r0<- vA
+    .if $chkzero
+    cmp     r1, #0                      @ is second operand zero?
+    beq     common_errDivideByZero
+    .endif
+
+// begin WITH_TAINT_TRACKING
+	bl		.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ $result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG($result, r9)               @ vAA<- $result
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-13 instructions */
+
+%break
+
+.L${opcode}_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r9, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/binopLit16.S b/vm/mterp/armv5te_taint/binopLit16.S
new file mode 100644
index 0000000..6594f81
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binopLit16.S
@@ -0,0 +1,36 @@
+%default {"result":"r0", "chkzero":"0"}
+    /*
+     * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = r0 op r1".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * For: add-int/lit16, rsub-int, mul-int/lit16, div-int/lit16,
+     *      rem-int/lit16, and-int/lit16, or-int/lit16, xor-int/lit16
+     */
+    /* binop/lit16 vA, vB, #+CCCC */
+    FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
+    mov     r2, rINST, lsr #12          @ r2<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
+    .if $chkzero
+    cmp     r1, #0                      @ is second operand zero?
+    beq     common_errDivideByZero
+    .endif
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+
+    $instr                              @ $result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG($result, r9)               @ vAA<- $result
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-13 instructions */
+
diff --git a/vm/mterp/armv5te_taint/binopLit8.S b/vm/mterp/armv5te_taint/binopLit8.S
new file mode 100644
index 0000000..dfa68ad
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binopLit8.S
@@ -0,0 +1,38 @@
+%default {"preinstr":"", "result":"r0", "chkzero":"0"}
+    /*
+     * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = r0 op r1".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * For: add-int/lit8, rsub-int/lit8, mul-int/lit8, div-int/lit8,
+     *      rem-int/lit8, and-int/lit8, or-int/lit8, xor-int/lit8,
+     *      shl-int/lit8, shr-int/lit8, ushr-int/lit8
+     */
+    /* binop/lit8 vAA, vBB, #+CC */
+    FETCH_S(r3, 1)                      @ r3<- ssssCCBB (sign-extended for CC)
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r3, #255                @ r2<- BB
+    GET_VREG(r0, r2)                    @ r0<- vBB
+    movs    r1, r3, asr #8              @ r1<- ssssssCC (sign extended)
+    .if $chkzero
+    @cmp     r1, #0                      @ is second operand zero?
+    beq     common_errDivideByZero
+    .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ $result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG($result, r9)               @ vAA<- $result
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-12 instructions */
+
diff --git a/vm/mterp/armv5te_taint/binopWide.S b/vm/mterp/armv5te_taint/binopWide.S
new file mode 100644
index 0000000..b625b1d
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binopWide.S
@@ -0,0 +1,61 @@
+%default {"preinstr":"", "result0":"r0", "result1":"r1", "chkzero":"0"}
+    /*
+     * Generic 64-bit binary operation.  Provide an "instr" line that
+     * specifies an instruction that performs "result = r0-r1 op r2-r3".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * for: add-long, sub-long, div-long, rem-long, and-long, or-long,
+     *      xor-long, add-double, sub-double, mul-double, div-double,
+     *      rem-double
+     *
+     * IMPORTANT: you may specify "chkzero" or "preinstr" but not both.
+     */
+    /* binop vAA, vBB, vCC */
+    FETCH(r0, 1)                        @ r0<- CCBB
+    mov     r9, rINST, lsr #8           @ r9<- AA
+    and     r2, r0, #255                @ r2<- BB
+    mov     r3, r0, lsr #8              @ r3<- CC
+// begin WITH_TAINT_TRACKING
+    bl		.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    .if $chkzero
+    orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
+    beq     common_errDivideByZero
+    .endif
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {$result0,$result1}     @ vAA/vAA+1<- $result0/$result1
+    str		$result0, [r9, #0]
+    str		r10, [r9, #4]
+    str		$result1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 14-17 instructions */
+
+%break
+
+.L${opcode}_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/binopWide2addr.S b/vm/mterp/armv5te_taint/binopWide2addr.S
new file mode 100644
index 0000000..84b9eba
--- /dev/null
+++ b/vm/mterp/armv5te_taint/binopWide2addr.S
@@ -0,0 +1,58 @@
+%default {"preinstr":"", "result0":"r0", "result1":"r1", "chkzero":"0"}
+    /*
+     * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = r0-r1 op r2-r3".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * For: add-long/2addr, sub-long/2addr, div-long/2addr, rem-long/2addr,
+     *      and-long/2addr, or-long/2addr, xor-long/2addr, add-double/2addr,
+     *      sub-double/2addr, mul-double/2addr, div-double/2addr,
+     *      rem-double/2addr
+     */
+    /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r1, rINST, lsr #12          @ r1<- B
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.L${opcode}_taint_prop
+// end WITH_TAINT_TRACKING
+    .if $chkzero
+    orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
+    beq     common_errDivideByZero
+    .endif
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {$result0,$result1}     @ vAA/vAA+1<- $result0/$result1
+    str		$result0, [r9, #0]
+    str		r10, [r9, #4]
+    str		$result1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-15 instructions */
+
+%break
+
+.L${opcode}_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
diff --git a/vm/mterp/armv5te_taint/entry.S b/vm/mterp/armv5te_taint/entry.S
new file mode 100644
index 0000000..f9e01a3
--- /dev/null
+++ b/vm/mterp/armv5te_taint/entry.S
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * Interpreter entry point.
+ */
+
+/*
+ * We don't have formal stack frames, so gdb scans upward in the code
+ * to find the start of the function (a label with the %function type),
+ * and then looks at the next few instructions to figure out what
+ * got pushed onto the stack.  From this it figures out how to restore
+ * the registers, including PC, for the previous stack frame.  If gdb
+ * sees a non-function label, it stops scanning, so either we need to
+ * have nothing but assembler-local labels between the entry point and
+ * the break, or we need to fake it out.
+ *
+ * When this is defined, we add some stuff to make gdb less confused.
+ */
+#define ASSIST_DEBUGGER 1
+
+    .text
+    .align  2
+    .global dvmMterpStdRun
+    .type   dvmMterpStdRun, %function
+
+/*
+ * On entry:
+ *  r0  MterpGlue* glue
+ *
+ * This function returns a boolean "changeInterp" value.  The return comes
+ * via a call to dvmMterpStdBail().
+ */
+dvmMterpStdRun:
+#define MTERP_ENTRY1 \
+    .save {r4-r10,fp,lr}; \
+    stmfd   sp!, {r4-r10,fp,lr}         @ save 9 regs
+#define MTERP_ENTRY2 \
+    .pad    #4; \
+    sub     sp, sp, #4                  @ align 64
+
+    .fnstart
+    MTERP_ENTRY1
+    MTERP_ENTRY2
+
+    /* save stack pointer, add magic word for debuggerd */
+    str     sp, [r0, #offGlue_bailPtr]  @ save SP for eventual return
+
+    /* set up "named" registers, figure out entry point */
+    mov     rGLUE, r0                   @ set rGLUE
+    ldrb    r1, [r0, #offGlue_entryPoint]   @ InterpEntry enum is char
+    LOAD_PC_FP_FROM_GLUE()              @ load rPC and rFP from "glue"
+    adr     rIBASE, dvmAsmInstructionStart  @ set rIBASE
+    cmp     r1, #kInterpEntryInstr      @ usual case?
+    bne     .Lnot_instr                 @ no, handle it
+
+#if defined(WITH_JIT)
+.Lno_singleStep:
+    /* Entry is always a possible trace start */
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_INST()
+    cmp    r0,#0
+    bne    common_updateProfile
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+#else
+    /* start executing the instruction at rPC */
+    FETCH_INST()                        @ load rINST from rPC
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
+.Lnot_instr:
+    cmp     r1, #kInterpEntryReturn     @ were we returning from a method?
+    beq     common_returnFromMethod
+
+.Lnot_return:
+    cmp     r1, #kInterpEntryThrow      @ were we throwing an exception?
+    beq     common_exceptionThrown
+
+#if defined(WITH_JIT)
+.Lnot_throw:
+    ldr     r0,[rGLUE, #offGlue_jitResume]
+    ldr     r2,[rGLUE, #offGlue_jitResumePC]
+    cmp     r1, #kInterpEntryResume     @ resuming after Jit single-step?
+    bne     .Lbad_arg
+    cmp     rPC,r2
+    bne     .Lno_singleStep             @ must have branched, don't resume
+    mov     r1, #kInterpEntryInstr
+    strb    r1, [rGLUE, #offGlue_entryPoint]
+    ldr     rINST, .LdvmCompilerTemplate
+    bx      r0                          @ re-enter the translation
+.LdvmCompilerTemplate:
+    .word   dvmCompilerTemplateStart
+#endif
+
+.Lbad_arg:
+    ldr     r0, strBadEntryPoint
+    @ r1 holds value of entryPoint
+    bl      printf
+    bl      dvmAbort
+    .fnend
+
+
+    .global dvmMterpStdBail
+    .type   dvmMterpStdBail, %function
+
+/*
+ * Restore the stack pointer and PC from the save point established on entry.
+ * This is essentially the same as a longjmp, but should be cheaper.  The
+ * last instruction causes us to return to whoever called dvmMterpStdRun.
+ *
+ * We pushed some registers on the stack in dvmMterpStdRun, then saved
+ * SP and LR.  Here we restore SP, restore the registers, and then restore
+ * LR to PC.
+ *
+ * On entry:
+ *  r0  MterpGlue* glue
+ *  r1  bool changeInterp
+ */
+dvmMterpStdBail:
+    ldr     sp, [r0, #offGlue_bailPtr]      @ sp<- saved SP
+    mov     r0, r1                          @ return the changeInterp value
+    add     sp, sp, #4                      @ un-align 64
+    LDMFD_PC "r4-r10,fp"                    @ restore 9 regs and return
+
+
+/*
+ * String references.
+ */
+strBadEntryPoint:
+    .word   .LstrBadEntryPoint
+
diff --git a/vm/mterp/armv5te_taint/footer.S b/vm/mterp/armv5te_taint/footer.S
new file mode 100644
index 0000000..90e3750
--- /dev/null
+++ b/vm/mterp/armv5te_taint/footer.S
@@ -0,0 +1,981 @@
+
+/*
+ * ===========================================================================
+ *  Common subroutines and data
+ * ===========================================================================
+ */
+
+
+
+    .text
+    .align  2
+
+#if defined(WITH_JIT)
+/*
+ * Return from the translation cache to the interpreter when the compiler is
+ * having issues translating/executing a Dalvik instruction. We have to skip
+ * the code cache lookup otherwise it is possible to indefinitely bouce
+ * between the interpreter and the code cache if the instruction that fails
+ * to be compiled happens to be at a trace start.
+ */
+    .global dvmJitToInterpPunt
+dvmJitToInterpPunt:
+    mov    rPC, r0
+#ifdef EXIT_STATS
+    mov    r0,lr
+    bl     dvmBumpPunt;
+#endif
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    FETCH_INST()
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+
+/*
+ * Return to the interpreter to handle a single instruction.
+ * On entry:
+ *    r0 <= PC
+ *    r1 <= PC of resume instruction
+ *    lr <= resume point in translation
+ */
+    .global dvmJitToInterpSingleStep
+dvmJitToInterpSingleStep:
+    str    lr,[rGLUE,#offGlue_jitResume]
+    str    r1,[rGLUE,#offGlue_jitResumePC]
+    mov    r1,#kInterpEntryInstr
+    @ enum is 4 byte in aapcs-EABI
+    str    r1, [rGLUE, #offGlue_entryPoint]
+    mov    rPC,r0
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    mov    r2,#kJitSingleStep     @ Ask for single step and then revert
+    str    r2,[rGLUE,#offGlue_jitState]
+    mov    r1,#1                  @ set changeInterp to bail to debug interp
+    b      common_gotoBail
+
+
+/*
+ * Return from the translation cache and immediately request
+ * a translation for the exit target.  Commonly used following
+ * invokes.
+ */
+    .global dvmJitToTraceSelect
+dvmJitToTraceSelect:
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    beq    2f
+    mov    r1,rINST
+    bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
+    cmp    r0,#0                    @ successful chain?
+    bxne   r0                       @ continue native execution
+    b      toInterpreter            @ didn't chain - resume with interpreter
+
+/* No translation, so request one if profiling isn't disabled*/
+2:
+    adrl   rIBASE, dvmAsmInstructionStart
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_INST()
+    cmp    r0, #0
+    bne    common_selectTrace
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+
+/*
+ * Return from the translation cache to the interpreter.
+ * The return was done with a BLX from thumb mode, and
+ * the following 32-bit word contains the target rPC value.
+ * Note that lr (r14) will have its low-order bit set to denote
+ * its thumb-mode origin.
+ *
+ * We'll need to stash our lr origin away, recover the new
+ * target and then check to see if there is a translation available
+ * for our new target.  If so, we do a translation chain and
+ * go back to native execution.  Otherwise, it's back to the
+ * interpreter (after treating this entry as a potential
+ * trace start).
+ */
+    .global dvmJitToInterpNormal
+dvmJitToInterpNormal:
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
+#ifdef EXIT_STATS
+    bl     dvmBumpNormal
+#endif
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    beq    toInterpreter            @ go if not, otherwise do chain
+    mov    r1,rINST
+    bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
+    cmp    r0,#0                    @ successful chain?
+    bxne   r0                       @ continue native execution
+    b      toInterpreter            @ didn't chain - resume with interpreter
+
+/*
+ * Return from the translation cache to the interpreter to do method invocation.
+ * Check if translation exists for the callee, but don't chain to it.
+ */
+    .global dvmJitToInterpNoChain
+dvmJitToInterpNoChain:
+#ifdef EXIT_STATS
+    bl     dvmBumpNoChain
+#endif
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    bxne   r0                       @ continue native execution if so
+
+/*
+ * No translation, restore interpreter regs and start interpreting.
+ * rGLUE & rFP were preserved in the translated code, and rPC has
+ * already been restored by the time we get here.  We'll need to set
+ * up rIBASE & rINST, and load the address of the JitTable into r0.
+ */
+toInterpreter:
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    FETCH_INST()
+    GET_JIT_PROF_TABLE(r0)
+    @ NOTE: intended fallthrough
+/*
+ * Common code to update potential trace start counter, and initiate
+ * a trace-build if appropriate.  On entry, rPC should point to the
+ * next instruction to execute, and rINST should be already loaded with
+ * the next opcode word, and r0 holds a pointer to the jit profile
+ * table (pJitProfTable).
+ */
+common_testUpdateProfile:
+    cmp     r0,#0
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE_IFEQ(ip)       @ if not profiling, fallthrough otherwise */
+
+common_updateProfile:
+    eor     r3,rPC,rPC,lsr #12 @ cheap, but fast hash function
+    lsl     r3,r3,#23          @ shift out excess 511
+    ldrb    r1,[r0,r3,lsr #23] @ get counter
+    GET_INST_OPCODE(ip)
+    subs    r1,r1,#1           @ decrement counter
+    strb    r1,[r0,r3,lsr #23] @ and store it
+    GOTO_OPCODE_IFNE(ip)       @ if not threshold, fallthrough otherwise */
+
+/*
+ * Here, we switch to the debug interpreter to request
+ * trace selection.  First, though, check to see if there
+ * is already a native translation in place (and, if so,
+ * jump to it now).
+ */
+    mov     r1,#255
+    strb    r1,[r0,r3,lsr #23] @ reset counter
+    EXPORT_PC()
+    mov     r0,rPC
+    bl      dvmJitGetCodeAddr           @ r0<- dvmJitGetCodeAddr(rPC)
+    cmp     r0,#0
+    beq     common_selectTrace
+    bxne    r0                          @ jump to the translation
+common_selectTrace:
+    mov     r2,#kJitTSelectRequest      @ ask for trace selection
+    str     r2,[rGLUE,#offGlue_jitState]
+    mov     r1,#1                       @ set changeInterp
+    b       common_gotoBail
+
+#endif
+
+/*
+ * Common code when a backward branch is taken.
+ *
+ * On entry:
+ *  r9 is PC adjustment *in bytes*
+ */
+common_backwardBranch:
+    mov     r0, #kInterpEntryInstr
+    bl      common_periodicChecks
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
+
+/*
+ * Need to see if the thread needs to be suspended or debugger/profiler
+ * activity has begun.
+ *
+ * TODO: if JDWP isn't running, zero out pDebuggerActive pointer so we don't
+ * have to do the second ldr.
+ *
+ * TODO: reduce this so we're just checking a single location.
+ *
+ * On entry:
+ *  r0 is reentry type, e.g. kInterpEntryInstr
+ *  r9 is trampoline PC adjustment *in bytes*
+ */
+common_periodicChecks:
+    ldr     r3, [rGLUE, #offGlue_pSelfSuspendCount] @ r3<- &suspendCount
+
+#if defined(WITH_DEBUGGER)
+    ldr     r1, [rGLUE, #offGlue_pDebuggerActive]   @ r1<- &debuggerActive
+#endif
+#if defined(WITH_PROFILER)
+    ldr     r2, [rGLUE, #offGlue_pActiveProfilers]  @ r2<- &activeProfilers
+#endif
+
+    ldr     r3, [r3]                    @ r3<- suspendCount (int)
+
+#if defined(WITH_DEBUGGER)
+    ldrb    r1, [r1]                    @ r1<- debuggerActive (boolean)
+#endif
+#if defined (WITH_PROFILER)
+    ldr     r2, [r2]                    @ r2<- activeProfilers (int)
+#endif
+
+    cmp     r3, #0                      @ suspend pending?
+    bne     2f                          @ yes, do full suspension check
+
+#if defined(WITH_DEBUGGER) || defined(WITH_PROFILER)
+# if defined(WITH_DEBUGGER) && defined(WITH_PROFILER)
+    orrs    r1, r1, r2                  @ r1<- r1 | r2
+    cmp     r1, #0                      @ debugger attached or profiler started?
+# elif defined(WITH_DEBUGGER)
+    cmp     r1, #0                      @ debugger attached?
+# elif defined(WITH_PROFILER)
+    cmp     r2, #0                      @ profiler started?
+# endif
+    bne     3f                          @ debugger/profiler, switch interp
+#endif
+
+    bx      lr                          @ nothing to do, return
+
+2:  @ check suspend
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    EXPORT_PC()                         @ need for precise GC
+    b       dvmCheckSuspendPending      @ suspend if necessary, then return
+
+3:  @ debugger/profiler enabled, bail out
+    add     rPC, rPC, r9                @ update rPC
+    str     r0, [rGLUE, #offGlue_entryPoint]
+    mov     r1, #1                      @ "want switch" = true
+    b       common_gotoBail
+
+
+/*
+ * The equivalent of "goto bail", this calls through the "bail handler".
+ *
+ * State registers will be saved to the "glue" area before bailing.
+ *
+ * On entry:
+ *  r1 is "bool changeInterp", indicating if we want to switch to the
+ *     other interpreter or just bail all the way out
+ */
+common_gotoBail:
+    SAVE_PC_FP_TO_GLUE()                @ export state to "glue"
+    mov     r0, rGLUE                   @ r0<- glue ptr
+    b       dvmMterpStdBail             @ call(glue, changeInterp)
+
+    @add     r1, r1, #1                  @ using (boolean+1)
+    @add     r0, rGLUE, #offGlue_jmpBuf  @ r0<- &glue->jmpBuf
+    @bl      _longjmp                    @ does not return
+    @bl      common_abort
+
+
+/*
+ * Common code for method invocation with range.
+ *
+ * On entry:
+ *  r0 is "Method* methodToCall", the method we're trying to call
+ */
+common_invokeMethodRange:
+.LinvokeNewRange:
+    @ prepare to copy args to "outs" area of current frame
+    movs    r2, rINST, lsr #8           @ r2<- AA (arg count) -- test for zero
+    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
+    beq     .LinvokeArgsDone            @ if no args, skip the rest
+    FETCH(r1, 2)                        @ r1<- CCCC
+
+    @ r0=methodToCall, r1=CCCC, r2=count, r10=outs
+    @ (very few methods have > 10 args; could unroll for common cases)
+    add     r3, rFP, r1, lsl #2         @ r3<- &fp[CCCC]
+    sub     r10, r10, r2, lsl #2        @ r10<- "outs" area, for call args
+    ldrh    r9, [r0, #offMethod_registersSize]  @ r9<- methodToCall->regsSize
+1:  ldr     r1, [r3], #4                @ val = *fp++
+    subs    r2, r2, #1                  @ count--
+    str     r1, [r10], #4               @ *outs++ = val
+    bne     1b                          @ ...while count != 0
+    ldrh    r3, [r0, #offMethod_outsSize]   @ r3<- methodToCall->outsSize
+    b       .LinvokeArgsDone
+
+/*
+ * Common code for method invocation without range.
+ *
+ * On entry:
+ *  r0 is "Method* methodToCall", the method we're trying to call
+ */
+common_invokeMethodNoRange:
+.LinvokeNewNoRange:
+    @ prepare to copy args to "outs" area of current frame
+    movs    r2, rINST, lsr #12          @ r2<- B (arg count) -- test for zero
+    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
+    FETCH(r1, 2)                        @ r1<- GFED (load here to hide latency)
+    ldrh    r9, [r0, #offMethod_registersSize]  @ r9<- methodToCall->regsSize
+    ldrh    r3, [r0, #offMethod_outsSize]  @ r3<- methodToCall->outsSize
+    beq     .LinvokeArgsDone
+
+    @ r0=methodToCall, r1=GFED, r3=outSize, r2=count, r9=regSize, r10=outs
+.LinvokeNonRange:
+    rsb     r2, r2, #5                  @ r2<- 5-r2
+    add     pc, pc, r2, lsl #4          @ computed goto, 4 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+5:  and     ip, rINST, #0x0f00          @ isolate A
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vA (shift right 8, left 2)
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vA
+4:  and     ip, r1, #0xf000             @ isolate G
+    ldr     r2, [rFP, ip, lsr #10]      @ r2<- vG (shift right 12, left 2)
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vG
+3:  and     ip, r1, #0x0f00             @ isolate F
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vF
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vF
+2:  and     ip, r1, #0x00f0             @ isolate E
+    ldr     r2, [rFP, ip, lsr #2]       @ r2<- vE
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vE
+1:  and     ip, r1, #0x000f             @ isolate D
+    ldr     r2, [rFP, ip, lsl #2]       @ r2<- vD
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vD
+0:  @ fall through to .LinvokeArgsDone
+
+.LinvokeArgsDone: @ r0=methodToCall, r3=outSize, r9=regSize
+    ldr     r2, [r0, #offMethod_insns]  @ r2<- method->insns
+    ldr     rINST, [r0, #offMethod_clazz]  @ rINST<- method->clazz
+    @ find space for the new stack frame, check for overflow
+    SAVEAREA_FROM_FP(r1, rFP)           @ r1<- stack save area
+    sub     r1, r1, r9, lsl #2          @ r1<- newFp (old savearea - regsSize)
+    SAVEAREA_FROM_FP(r10, r1)           @ r10<- newSaveArea
+@    bl      common_dumpRegs
+    ldr     r9, [rGLUE, #offGlue_interpStackEnd]    @ r9<- interpStackEnd
+    sub     r3, r10, r3, lsl #2         @ r3<- bottom (newsave - outsSize)
+    cmp     r3, r9                      @ bottom < interpStackEnd?
+    ldr     r3, [r0, #offMethod_accessFlags] @ r3<- methodToCall->accessFlags
+    blt     .LstackOverflow             @ yes, this frame will overflow stack
+
+    @ set up newSaveArea
+#ifdef EASY_GDB
+    SAVEAREA_FROM_FP(ip, rFP)           @ ip<- stack save area
+    str     ip, [r10, #offStackSaveArea_prevSave]
+#endif
+    str     rFP, [r10, #offStackSaveArea_prevFrame]
+    str     rPC, [r10, #offStackSaveArea_savedPc]
+#if defined(WITH_JIT)
+    mov     r9, #0
+    str     r9, [r10, #offStackSaveArea_returnAddr]
+#endif
+    str     r0, [r10, #offStackSaveArea_method]
+    tst     r3, #ACC_NATIVE
+    bne     .LinvokeNative
+
+    /*
+    stmfd   sp!, {r0-r3}
+    bl      common_printNewline
+    mov     r0, rFP
+    mov     r1, #0
+    bl      dvmDumpFp
+    ldmfd   sp!, {r0-r3}
+    stmfd   sp!, {r0-r3}
+    mov     r0, r1
+    mov     r1, r10
+    bl      dvmDumpFp
+    bl      common_printNewline
+    ldmfd   sp!, {r0-r3}
+    */
+
+    ldrh    r9, [r2]                        @ r9 <- load INST from new PC
+    ldr     r3, [rINST, #offClassObject_pDvmDex] @ r3<- method->clazz->pDvmDex
+    mov     rPC, r2                         @ publish new rPC
+    ldr     r2, [rGLUE, #offGlue_self]      @ r2<- glue->self
+
+    @ Update "glue" values for the new method
+    @ r0=methodToCall, r1=newFp, r2=self, r3=newMethodClass, r9=newINST
+    str     r0, [rGLUE, #offGlue_method]    @ glue->method = methodToCall
+    str     r3, [rGLUE, #offGlue_methodClassDex] @ glue->methodClassDex = ...
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    mov     rFP, r1                         @ fp = newFp
+    GET_PREFETCHED_OPCODE(ip, r9)           @ extract prefetched opcode from r9
+    mov     rINST, r9                       @ publish new rINST
+    str     r1, [r2, #offThread_curFrame]   @ self->curFrame = newFp
+    cmp     r0,#0
+    bne     common_updateProfile
+    GOTO_OPCODE(ip)                         @ jump to next instruction
+#else
+    mov     rFP, r1                         @ fp = newFp
+    GET_PREFETCHED_OPCODE(ip, r9)           @ extract prefetched opcode from r9
+    mov     rINST, r9                       @ publish new rINST
+    str     r1, [r2, #offThread_curFrame]   @ self->curFrame = newFp
+    GOTO_OPCODE(ip)                         @ jump to next instruction
+#endif
+
+.LinvokeNative:
+    @ Prep for the native call
+    @ r0=methodToCall, r1=newFp, r10=newSaveArea
+    ldr     r3, [rGLUE, #offGlue_self]      @ r3<- glue->self
+    ldr     r9, [r3, #offThread_jniLocal_topCookie] @ r9<- thread->localRef->...
+    str     r1, [r3, #offThread_curFrame]   @ self->curFrame = newFp
+    str     r9, [r10, #offStackSaveArea_localRefCookie] @newFp->localRefCookie=top
+    mov     r9, r3                      @ r9<- glue->self (preserve)
+
+    mov     r2, r0                      @ r2<- methodToCall
+    mov     r0, r1                      @ r0<- newFp (points to args)
+    add     r1, rGLUE, #offGlue_retval  @ r1<- &retval
+
+#ifdef ASSIST_DEBUGGER
+    /* insert fake function header to help gdb find the stack frame */
+    b       .Lskip
+    .type   dalvik_mterp, %function
+dalvik_mterp:
+    .fnstart
+    MTERP_ENTRY1
+    MTERP_ENTRY2
+.Lskip:
+#endif
+
+    @mov     lr, pc                      @ set return addr
+    @ldr     pc, [r2, #offMethod_nativeFunc] @ pc<- methodToCall->nativeFunc
+    LDR_PC_LR "[r2, #offMethod_nativeFunc]"
+
+    @ native return; r9=self, r10=newSaveArea
+    @ equivalent to dvmPopJniLocals
+    ldr     r0, [r10, #offStackSaveArea_localRefCookie] @ r0<- saved top
+    ldr     r1, [r9, #offThread_exception] @ check for exception
+    str     rFP, [r9, #offThread_curFrame]  @ self->curFrame = fp
+    cmp     r1, #0                      @ null?
+    str     r0, [r9, #offThread_jniLocal_topCookie] @ new top <- old top
+    bne     common_exceptionThrown      @ no, handle exception
+
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LstackOverflow:
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- self
+    bl      dvmHandleStackOverflow
+    b       common_exceptionThrown
+#ifdef ASSIST_DEBUGGER
+    .fnend
+#endif
+
+
+    /*
+     * Common code for method invocation, calling through "glue code".
+     *
+     * TODO: now that we have range and non-range invoke handlers, this
+     *       needs to be split into two.  Maybe just create entry points
+     *       that set r9 and jump here?
+     *
+     * On entry:
+     *  r0 is "Method* methodToCall", the method we're trying to call
+     *  r9 is "bool methodCallRange", indicating if this is a /range variant
+     */
+     .if    0
+.LinvokeOld:
+    sub     sp, sp, #8                  @ space for args + pad
+    FETCH(ip, 2)                        @ ip<- FEDC or CCCC
+    mov     r2, r0                      @ A2<- methodToCall
+    mov     r0, rGLUE                   @ A0<- glue
+    SAVE_PC_FP_TO_GLUE()                @ export state to "glue"
+    mov     r1, r9                      @ A1<- methodCallRange
+    mov     r3, rINST, lsr #8           @ A3<- AA
+    str     ip, [sp, #0]                @ A4<- ip
+    bl      dvmMterp_invokeMethod       @ call the C invokeMethod
+    add     sp, sp, #8                  @ remove arg area
+    b       common_resumeAfterGlueCall  @ continue to next instruction
+    .endif
+
+
+
+/*
+ * Common code for handling a return instruction.
+ *
+ * This does not return.
+ */
+common_returnFromMethod:
+.LreturnNew:
+    mov     r0, #kInterpEntryReturn
+    mov     r9, #0
+    bl      common_periodicChecks
+
+    SAVEAREA_FROM_FP(r0, rFP)           @ r0<- saveArea (old)
+    ldr     rFP, [r0, #offStackSaveArea_prevFrame] @ fp = saveArea->prevFrame
+    ldr     r9, [r0, #offStackSaveArea_savedPc] @ r9 = saveArea->savedPc
+    ldr     r2, [rFP, #(offStackSaveArea_method - sizeofStackSaveArea)]
+                                        @ r2<- method we're returning to
+    ldr     r3, [rGLUE, #offGlue_self]  @ r3<- glue->self
+    cmp     r2, #0                      @ is this a break frame?
+    ldrne   r10, [r2, #offMethod_clazz] @ r10<- method->clazz
+    mov     r1, #0                      @ "want switch" = false
+    beq     common_gotoBail             @ break frame, bail out completely
+
+    PREFETCH_ADVANCE_INST(rINST, r9, 3) @ advance r9, update new rINST
+    str     r2, [rGLUE, #offGlue_method]@ glue->method = newSave->method
+    ldr     r1, [r10, #offClassObject_pDvmDex]   @ r1<- method->clazz->pDvmDex
+    str     rFP, [r3, #offThread_curFrame]  @ self->curFrame = fp
+#if defined(WITH_JIT)
+    ldr     r3, [r0, #offStackSaveArea_returnAddr] @ r3 = saveArea->returnAddr
+    GET_JIT_PROF_TABLE(r0)
+    mov     rPC, r9                     @ publish new rPC
+    str     r1, [rGLUE, #offGlue_methodClassDex]
+    cmp     r3, #0                      @ caller is compiled code
+    blxne   r3
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    mov     rPC, r9                     @ publish new rPC
+    str     r1, [rGLUE, #offGlue_methodClassDex]
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
+    /*
+     * Return handling, calls through "glue code".
+     */
+     .if    0
+.LreturnOld:
+    SAVE_PC_FP_TO_GLUE()                @ export state
+    mov     r0, rGLUE                   @ arg to function
+    bl      dvmMterp_returnFromMethod
+    b       common_resumeAfterGlueCall
+    .endif
+
+
+/*
+ * Somebody has thrown an exception.  Handle it.
+ *
+ * If the exception processing code returns to us (instead of falling
+ * out of the interpreter), continue with whatever the next instruction
+ * now happens to be.
+ *
+ * This does not return.
+ */
+     .global dvmMterpCommonExceptionThrown
+dvmMterpCommonExceptionThrown:
+common_exceptionThrown:
+.LexceptionNew:
+    mov     r0, #kInterpEntryThrow
+    mov     r9, #0
+    bl      common_periodicChecks
+
+#if defined(WITH_JIT)
+    mov     r2,#kJitTSelectAbort        @ abandon trace selection in progress
+    str     r2,[rGLUE,#offGlue_jitState]
+#endif
+
+    ldr     r10, [rGLUE, #offGlue_self] @ r10<- glue->self
+    ldr     r9, [r10, #offThread_exception] @ r9<- self->exception
+    mov     r1, r10                     @ r1<- self
+    mov     r0, r9                      @ r0<- exception
+    bl      dvmAddTrackedAlloc          @ don't let the exception be GCed
+    mov     r3, #0                      @ r3<- NULL
+    str     r3, [r10, #offThread_exception] @ self->exception = NULL
+
+    /* set up args and a local for "&fp" */
+    /* (str sp, [sp, #-4]!  would be perfect here, but is discouraged) */
+    str     rFP, [sp, #-4]!             @ *--sp = fp
+    mov     ip, sp                      @ ip<- &fp
+    mov     r3, #0                      @ r3<- false
+    str     ip, [sp, #-4]!              @ *--sp = &fp
+    ldr     r1, [rGLUE, #offGlue_method] @ r1<- glue->method
+    mov     r0, r10                     @ r0<- self
+    ldr     r1, [r1, #offMethod_insns]  @ r1<- method->insns
+    mov     r2, r9                      @ r2<- exception
+    sub     r1, rPC, r1                 @ r1<- pc - method->insns
+    mov     r1, r1, asr #1              @ r1<- offset in code units
+
+    /* call, r0 gets catchRelPc (a code-unit offset) */
+    bl      dvmFindCatchBlock           @ call(self, relPc, exc, scan?, &fp)
+
+    /* fix earlier stack overflow if necessary; may trash rFP */
+    ldrb    r1, [r10, #offThread_stackOverflowed]
+    cmp     r1, #0                      @ did we overflow earlier?
+    beq     1f                          @ no, skip ahead
+    mov     rFP, r0                     @ save relPc result in rFP
+    mov     r0, r10                     @ r0<- self
+    bl      dvmCleanupStackOverflow     @ call(self)
+    mov     r0, rFP                     @ restore result
+1:
+
+    /* update frame pointer and check result from dvmFindCatchBlock */
+    ldr     rFP, [sp, #4]               @ retrieve the updated rFP
+    cmp     r0, #0                      @ is catchRelPc < 0?
+    add     sp, sp, #8                  @ restore stack
+    bmi     .LnotCaughtLocally
+
+    /* adjust locals to match self->curFrame and updated PC */
+    SAVEAREA_FROM_FP(r1, rFP)           @ r1<- new save area
+    ldr     r1, [r1, #offStackSaveArea_method] @ r1<- new method
+    str     r1, [rGLUE, #offGlue_method]    @ glue->method = new method
+    ldr     r2, [r1, #offMethod_clazz]      @ r2<- method->clazz
+    ldr     r3, [r1, #offMethod_insns]      @ r3<- method->insns
+    ldr     r2, [r2, #offClassObject_pDvmDex] @ r2<- method->clazz->pDvmDex
+    add     rPC, r3, r0, asl #1             @ rPC<- method->insns + catchRelPc
+    str     r2, [rGLUE, #offGlue_methodClassDex] @ glue->pDvmDex = meth...
+
+    /* release the tracked alloc on the exception */
+    mov     r0, r9                      @ r0<- exception
+    mov     r1, r10                     @ r1<- self
+    bl      dvmReleaseTrackedAlloc      @ release the exception
+
+    /* restore the exception if the handler wants it */
+    FETCH_INST()                        @ load rINST from rPC
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    cmp     ip, #OP_MOVE_EXCEPTION      @ is it "move-exception"?
+    streq   r9, [r10, #offThread_exception] @ yes, restore the exception
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LnotCaughtLocally: @ r9=exception, r10=self
+    /* fix stack overflow if necessary */
+    ldrb    r1, [r10, #offThread_stackOverflowed]
+    cmp     r1, #0                      @ did we overflow earlier?
+    movne   r0, r10                     @ if yes: r0<- self
+    blne    dvmCleanupStackOverflow     @ if yes: call(self)
+
+    @ may want to show "not caught locally" debug messages here
+#if DVM_SHOW_EXCEPTION >= 2
+    /* call __android_log_print(prio, tag, format, ...) */
+    /* "Exception %s from %s:%d not caught locally" */
+    @ dvmLineNumFromPC(method, pc - method->insns)
+    ldr     r0, [rGLUE, #offGlue_method]
+    ldr     r1, [r0, #offMethod_insns]
+    sub     r1, rPC, r1
+    asr     r1, r1, #1
+    bl      dvmLineNumFromPC
+    str     r0, [sp, #-4]!
+    @ dvmGetMethodSourceFile(method)
+    ldr     r0, [rGLUE, #offGlue_method]
+    bl      dvmGetMethodSourceFile
+    str     r0, [sp, #-4]!
+    @ exception->clazz->descriptor
+    ldr     r3, [r9, #offObject_clazz]
+    ldr     r3, [r3, #offClassObject_descriptor]
+    @
+    ldr     r2, strExceptionNotCaughtLocally
+    ldr     r1, strLogTag
+    mov     r0, #3                      @ LOG_DEBUG
+    bl      __android_log_print
+#endif
+    str     r9, [r10, #offThread_exception] @ restore exception
+    mov     r0, r9                      @ r0<- exception
+    mov     r1, r10                     @ r1<- self
+    bl      dvmReleaseTrackedAlloc      @ release the exception
+    mov     r1, #0                      @ "want switch" = false
+    b       common_gotoBail             @ bail out
+
+
+    /*
+     * Exception handling, calls through "glue code".
+     */
+    .if     0
+.LexceptionOld:
+    SAVE_PC_FP_TO_GLUE()                @ export state
+    mov     r0, rGLUE                   @ arg to function
+    bl      dvmMterp_exceptionThrown
+    b       common_resumeAfterGlueCall
+    .endif
+
+
+/*
+ * After returning from a "glued" function, pull out the updated
+ * values and start executing at the next instruction.
+ */
+common_resumeAfterGlueCall:
+    LOAD_PC_FP_FROM_GLUE()              @ pull rPC and rFP out of glue
+    FETCH_INST()                        @ load rINST from rPC
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/*
+ * Invalid array index.
+ */
+common_errArrayIndex:
+    EXPORT_PC()
+    ldr     r0, strArrayIndexException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Invalid array value.
+ */
+common_errArrayStore:
+    EXPORT_PC()
+    ldr     r0, strArrayStoreException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Integer divide or mod by zero.
+ */
+common_errDivideByZero:
+    EXPORT_PC()
+    ldr     r0, strArithmeticException
+    ldr     r1, strDivideByZero
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Attempt to allocate an array with a negative size.
+ */
+common_errNegativeArraySize:
+    EXPORT_PC()
+    ldr     r0, strNegativeArraySizeException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Invocation of a non-existent method.
+ */
+common_errNoSuchMethod:
+    EXPORT_PC()
+    ldr     r0, strNoSuchMethodError
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * We encountered a null object when we weren't expecting one.  We
+ * export the PC, throw a NullPointerException, and goto the exception
+ * processing code.
+ */
+common_errNullObject:
+    EXPORT_PC()
+    ldr     r0, strNullPointerException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * For debugging, cause an immediate fault.  The source address will
+ * be in lr (use a bl instruction to jump here).
+ */
+common_abort:
+    ldr     pc, .LdeadFood
+.LdeadFood:
+    .word   0xdeadf00d
+
+/*
+ * Spit out a "we were here", preserving all registers.  (The attempt
+ * to save ip won't work, but we need to save an even number of
+ * registers for EABI 64-bit stack alignment.)
+ */
+    .macro  SQUEAK num
+common_squeak\num:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    ldr     r0, strSqueak
+    mov     r1, #\num
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+    .endm
+
+    SQUEAK  0
+    SQUEAK  1
+    SQUEAK  2
+    SQUEAK  3
+    SQUEAK  4
+    SQUEAK  5
+
+/*
+ * Spit out the number in r0, preserving registers.
+ */
+common_printNum:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r1, r0
+    ldr     r0, strSqueak
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print a newline, preserving registers.
+ */
+common_printNewline:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    ldr     r0, strNewline
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+    /*
+     * Print the 32-bit quantity in r0 as a hex value, preserving registers.
+     */
+common_printHex:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r1, r0
+    ldr     r0, strPrintHex
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print the 64-bit quantity in r0-r1, preserving registers.
+ */
+common_printLong:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r3, r1
+    mov     r2, r0
+    ldr     r0, strPrintLong
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print full method info.  Pass the Method* in r0.  Preserves regs.
+ */
+common_printMethod:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bl      dvmMterpPrintMethod
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Call a C helper function that dumps regs and possibly some
+ * additional info.  Requires the C function to be compiled in.
+ */
+    .if     0
+common_dumpRegs:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bl      dvmMterpDumpArmRegs
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+    .endif
+
+#if 0
+/*
+ * Experiment on VFP mode.
+ *
+ * uint32_t setFPSCR(uint32_t val, uint32_t mask)
+ *
+ * Updates the bits specified by "mask", setting them to the values in "val".
+ */
+setFPSCR:
+    and     r0, r0, r1                  @ make sure no stray bits are set
+    fmrx    r2, fpscr                   @ get VFP reg
+    mvn     r1, r1                      @ bit-invert mask
+    and     r2, r2, r1                  @ clear masked bits
+    orr     r2, r2, r0                  @ set specified bits
+    fmxr    fpscr, r2                   @ set VFP reg
+    mov     r0, r2                      @ return new value
+    bx      lr
+
+    .align  2
+    .global dvmConfigureFP
+    .type   dvmConfigureFP, %function
+dvmConfigureFP:
+    stmfd   sp!, {ip, lr}
+    /* 0x03000000 sets DN/FZ */
+    /* 0x00009f00 clears the six exception enable flags */
+    bl      common_squeak0
+    mov     r0, #0x03000000             @ r0<- 0x03000000
+    add     r1, r0, #0x9f00             @ r1<- 0x03009f00
+    bl      setFPSCR
+    ldmfd   sp!, {ip, pc}
+#endif
+
+
+/*
+ * String references, must be close to the code that uses them.
+ */
+    .align  2
+strArithmeticException:
+    .word   .LstrArithmeticException
+strArrayIndexException:
+    .word   .LstrArrayIndexException
+strArrayStoreException:
+    .word   .LstrArrayStoreException
+strDivideByZero:
+    .word   .LstrDivideByZero
+strNegativeArraySizeException:
+    .word   .LstrNegativeArraySizeException
+strNoSuchMethodError:
+    .word   .LstrNoSuchMethodError
+strNullPointerException:
+    .word   .LstrNullPointerException
+
+strLogTag:
+    .word   .LstrLogTag
+strExceptionNotCaughtLocally:
+    .word   .LstrExceptionNotCaughtLocally
+
+strNewline:
+    .word   .LstrNewline
+strSqueak:
+    .word   .LstrSqueak
+strPrintHex:
+    .word   .LstrPrintHex
+strPrintLong:
+    .word   .LstrPrintLong
+
+/*
+ * Zero-terminated ASCII string data.
+ *
+ * On ARM we have two choices: do like gcc does, and LDR from a .word
+ * with the address, or use an ADR pseudo-op to get the address
+ * directly.  ADR saves 4 bytes and an indirection, but it's using a
+ * PC-relative addressing mode and hence has a limited range, which
+ * makes it not work well with mergeable string sections.
+ */
+    .section .rodata.str1.4,"aMS",%progbits,1
+
+.LstrBadEntryPoint:
+    .asciz  "Bad entry point %d\n"
+.LstrArithmeticException:
+    .asciz  "Ljava/lang/ArithmeticException;"
+.LstrArrayIndexException:
+    .asciz  "Ljava/lang/ArrayIndexOutOfBoundsException;"
+.LstrArrayStoreException:
+    .asciz  "Ljava/lang/ArrayStoreException;"
+.LstrClassCastException:
+    .asciz  "Ljava/lang/ClassCastException;"
+.LstrDivideByZero:
+    .asciz  "divide by zero"
+.LstrFilledNewArrayNotImpl:
+    .asciz  "filled-new-array only implemented for objects and 'int'"
+.LstrInternalError:
+    .asciz  "Ljava/lang/InternalError;"
+.LstrInstantiationError:
+    .asciz  "Ljava/lang/InstantiationError;"
+.LstrNegativeArraySizeException:
+    .asciz  "Ljava/lang/NegativeArraySizeException;"
+.LstrNoSuchMethodError:
+    .asciz  "Ljava/lang/NoSuchMethodError;"
+.LstrNullPointerException:
+    .asciz  "Ljava/lang/NullPointerException;"
+
+.LstrLogTag:
+    .asciz  "mterp"
+.LstrExceptionNotCaughtLocally:
+    .asciz  "Exception %s from %s:%d not caught locally\n"
+
+.LstrNewline:
+    .asciz  "\n"
+.LstrSqueak:
+    .asciz  "<%d>"
+.LstrPrintHex:
+    .asciz  "<0x%x>"
+.LstrPrintLong:
+    .asciz  "<%lld>"
+
diff --git a/vm/mterp/armv5te_taint/footer.S~ b/vm/mterp/armv5te_taint/footer.S~
new file mode 100644
index 0000000..555a075
--- /dev/null
+++ b/vm/mterp/armv5te_taint/footer.S~
@@ -0,0 +1,985 @@
+
+/*
+ * ===========================================================================
+ *  Common subroutines and data
+ * ===========================================================================
+ */
+
+
+
+    .text
+    .align  2
+
+#if defined(WITH_JIT)
+/*
+ * Return from the translation cache to the interpreter when the compiler is
+ * having issues translating/executing a Dalvik instruction. We have to skip
+ * the code cache lookup otherwise it is possible to indefinitely bouce
+ * between the interpreter and the code cache if the instruction that fails
+ * to be compiled happens to be at a trace start.
+ */
+    .global dvmJitToInterpPunt
+dvmJitToInterpPunt:
+    mov    rPC, r0
+#ifdef EXIT_STATS
+    mov    r0,lr
+    bl     dvmBumpPunt;
+#endif
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    FETCH_INST()
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+
+/*
+ * Return to the interpreter to handle a single instruction.
+ * On entry:
+ *    r0 <= PC
+ *    r1 <= PC of resume instruction
+ *    lr <= resume point in translation
+ */
+    .global dvmJitToInterpSingleStep
+dvmJitToInterpSingleStep:
+    str    lr,[rGLUE,#offGlue_jitResume]
+    str    r1,[rGLUE,#offGlue_jitResumePC]
+    mov    r1,#kInterpEntryInstr
+    @ enum is 4 byte in aapcs-EABI
+    str    r1, [rGLUE, #offGlue_entryPoint]
+    mov    rPC,r0
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    mov    r2,#kJitSingleStep     @ Ask for single step and then revert
+    str    r2,[rGLUE,#offGlue_jitState]
+    mov    r1,#1                  @ set changeInterp to bail to debug interp
+    b      common_gotoBail
+
+
+/*
+ * Return from the translation cache and immediately request
+ * a translation for the exit target.  Commonly used following
+ * invokes.
+ */
+    .global dvmJitToTraceSelect
+dvmJitToTraceSelect:
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    beq    2f
+    mov    r1,rINST
+    bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
+    cmp    r0,#0                    @ successful chain?
+    bxne   r0                       @ continue native execution
+    b      toInterpreter            @ didn't chain - resume with interpreter
+
+/* No translation, so request one if profiling isn't disabled*/
+2:
+    adrl   rIBASE, dvmAsmInstructionStart
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_INST()
+    cmp    r0, #0
+    bne    common_selectTrace
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+
+/*
+ * Return from the translation cache to the interpreter.
+ * The return was done with a BLX from thumb mode, and
+ * the following 32-bit word contains the target rPC value.
+ * Note that lr (r14) will have its low-order bit set to denote
+ * its thumb-mode origin.
+ *
+ * We'll need to stash our lr origin away, recover the new
+ * target and then check to see if there is a translation available
+ * for our new target.  If so, we do a translation chain and
+ * go back to native execution.  Otherwise, it's back to the
+ * interpreter (after treating this entry as a potential
+ * trace start).
+ */
+    .global dvmJitToInterpNormal
+dvmJitToInterpNormal:
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
+#ifdef EXIT_STATS
+    bl     dvmBumpNormal
+#endif
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    beq    toInterpreter            @ go if not, otherwise do chain
+    mov    r1,rINST
+    bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
+    cmp    r0,#0                    @ successful chain?
+    bxne   r0                       @ continue native execution
+    b      toInterpreter            @ didn't chain - resume with interpreter
+
+/*
+ * Return from the translation cache to the interpreter to do method invocation.
+ * Check if translation exists for the callee, but don't chain to it.
+ */
+    .global dvmJitToInterpNoChain
+dvmJitToInterpNoChain:
+#ifdef EXIT_STATS
+    bl     dvmBumpNoChain
+#endif
+    mov    r0,rPC
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
+    cmp    r0,#0
+    bxne   r0                       @ continue native execution if so
+
+/*
+ * No translation, restore interpreter regs and start interpreting.
+ * rGLUE & rFP were preserved in the translated code, and rPC has
+ * already been restored by the time we get here.  We'll need to set
+ * up rIBASE & rINST, and load the address of the JitTable into r0.
+ */
+toInterpreter:
+    EXPORT_PC()
+    adrl   rIBASE, dvmAsmInstructionStart
+    FETCH_INST()
+    GET_JIT_PROF_TABLE(r0)
+    @ NOTE: intended fallthrough
+/*
+ * Common code to update potential trace start counter, and initiate
+ * a trace-build if appropriate.  On entry, rPC should point to the
+ * next instruction to execute, and rINST should be already loaded with
+ * the next opcode word, and r0 holds a pointer to the jit profile
+ * table (pJitProfTable).
+ */
+common_testUpdateProfile:
+    cmp     r0,#0
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE_IFEQ(ip)       @ if not profiling, fallthrough otherwise */
+
+common_updateProfile:
+    eor     r3,rPC,rPC,lsr #12 @ cheap, but fast hash function
+    lsl     r3,r3,#23          @ shift out excess 511
+    ldrb    r1,[r0,r3,lsr #23] @ get counter
+    GET_INST_OPCODE(ip)
+    subs    r1,r1,#1           @ decrement counter
+    strb    r1,[r0,r3,lsr #23] @ and store it
+    GOTO_OPCODE_IFNE(ip)       @ if not threshold, fallthrough otherwise */
+
+/*
+ * Here, we switch to the debug interpreter to request
+ * trace selection.  First, though, check to see if there
+ * is already a native translation in place (and, if so,
+ * jump to it now).
+ */
+    mov     r1,#255
+    strb    r1,[r0,r3,lsr #23] @ reset counter
+    EXPORT_PC()
+    mov     r0,rPC
+    bl      dvmJitGetCodeAddr           @ r0<- dvmJitGetCodeAddr(rPC)
+    cmp     r0,#0
+    beq     common_selectTrace
+    bxne    r0                          @ jump to the translation
+common_selectTrace:
+    mov     r2,#kJitTSelectRequest      @ ask for trace selection
+    str     r2,[rGLUE,#offGlue_jitState]
+    mov     r1,#1                       @ set changeInterp
+    b       common_gotoBail
+
+#endif
+
+/*
+ * Common code when a backward branch is taken.
+ *
+ * On entry:
+ *  r9 is PC adjustment *in bytes*
+ */
+common_backwardBranch:
+    mov     r0, #kInterpEntryInstr
+    bl      common_periodicChecks
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)
+    GOTO_OPCODE(ip)
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
+
+/*
+ * Need to see if the thread needs to be suspended or debugger/profiler
+ * activity has begun.
+ *
+ * TODO: if JDWP isn't running, zero out pDebuggerActive pointer so we don't
+ * have to do the second ldr.
+ *
+ * TODO: reduce this so we're just checking a single location.
+ *
+ * On entry:
+ *  r0 is reentry type, e.g. kInterpEntryInstr
+ *  r9 is trampoline PC adjustment *in bytes*
+ */
+common_periodicChecks:
+    ldr     r3, [rGLUE, #offGlue_pSelfSuspendCount] @ r3<- &suspendCount
+
+#if defined(WITH_DEBUGGER)
+    ldr     r1, [rGLUE, #offGlue_pDebuggerActive]   @ r1<- &debuggerActive
+#endif
+#if defined(WITH_PROFILER)
+    ldr     r2, [rGLUE, #offGlue_pActiveProfilers]  @ r2<- &activeProfilers
+#endif
+
+    ldr     r3, [r3]                    @ r3<- suspendCount (int)
+
+#if defined(WITH_DEBUGGER)
+    ldrb    r1, [r1]                    @ r1<- debuggerActive (boolean)
+#endif
+#if defined (WITH_PROFILER)
+    ldr     r2, [r2]                    @ r2<- activeProfilers (int)
+#endif
+
+    cmp     r3, #0                      @ suspend pending?
+    bne     2f                          @ yes, do full suspension check
+
+#if defined(WITH_DEBUGGER) || defined(WITH_PROFILER)
+# if defined(WITH_DEBUGGER) && defined(WITH_PROFILER)
+    orrs    r1, r1, r2                  @ r1<- r1 | r2
+    cmp     r1, #0                      @ debugger attached or profiler started?
+# elif defined(WITH_DEBUGGER)
+    cmp     r1, #0                      @ debugger attached?
+# elif defined(WITH_PROFILER)
+    cmp     r2, #0                      @ profiler started?
+# endif
+    bne     3f                          @ debugger/profiler, switch interp
+#endif
+
+    bx      lr                          @ nothing to do, return
+
+2:  @ check suspend
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
+    EXPORT_PC()                         @ need for precise GC
+    b       dvmCheckSuspendPending      @ suspend if necessary, then return
+
+3:  @ debugger/profiler enabled, bail out
+    add     rPC, rPC, r9                @ update rPC
+    str     r0, [rGLUE, #offGlue_entryPoint]
+    mov     r1, #1                      @ "want switch" = true
+    b       common_gotoBail
+
+
+/*
+ * The equivalent of "goto bail", this calls through the "bail handler".
+ *
+ * State registers will be saved to the "glue" area before bailing.
+ *
+ * On entry:
+ *  r1 is "bool changeInterp", indicating if we want to switch to the
+ *     other interpreter or just bail all the way out
+ */
+common_gotoBail:
+    SAVE_PC_FP_TO_GLUE()                @ export state to "glue"
+    mov     r0, rGLUE                   @ r0<- glue ptr
+    b       dvmMterpStdBail             @ call(glue, changeInterp)
+
+    @add     r1, r1, #1                  @ using (boolean+1)
+    @add     r0, rGLUE, #offGlue_jmpBuf  @ r0<- &glue->jmpBuf
+    @bl      _longjmp                    @ does not return
+    @bl      common_abort
+
+
+/*
+ * Common code for method invocation with range.
+ *
+ * On entry:
+ *  r0 is "Method* methodToCall", the method we're trying to call
+ */
+common_invokeMethodRange:
+.LinvokeNewRange:
+    @ prepare to copy args to "outs" area of current frame
+    movs    r2, rINST, lsr #8           @ r2<- AA (arg count) -- test for zero
+    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
+    beq     .LinvokeArgsDone            @ if no args, skip the rest
+    FETCH(r1, 2)                        @ r1<- CCCC
+
+    @ r0=methodToCall, r1=CCCC, r2=count, r10=outs
+    @ (very few methods have > 10 args; could unroll for common cases)
+    add     r3, rFP, r1, lsl #2         @ r3<- &fp[CCCC]
+    sub     r10, r10, r2, lsl #2        @ r10<- "outs" area, for call args
+    ldrh    r9, [r0, #offMethod_registersSize]  @ r9<- methodToCall->regsSize
+1:  ldr     r1, [r3], #4                @ val = *fp++
+    subs    r2, r2, #1                  @ count--
+    str     r1, [r10], #4               @ *outs++ = val
+    bne     1b                          @ ...while count != 0
+    ldrh    r3, [r0, #offMethod_outsSize]   @ r3<- methodToCall->outsSize
+    b       .LinvokeArgsDone
+
+/*
+ * Common code for method invocation without range.
+ *
+ * On entry:
+ *  r0 is "Method* methodToCall", the method we're trying to call
+ */
+common_invokeMethodNoRange:
+.LinvokeNewNoRange:
+    @ prepare to copy args to "outs" area of current frame
+    movs    r2, rINST, lsr #12          @ r2<- B (arg count) -- test for zero
+    SAVEAREA_FROM_FP(r10, rFP)          @ r10<- stack save area
+    FETCH(r1, 2)                        @ r1<- GFED (load here to hide latency)
+    ldrh    r9, [r0, #offMethod_registersSize]  @ r9<- methodToCall->regsSize
+    ldrh    r3, [r0, #offMethod_outsSize]  @ r3<- methodToCall->outsSize
+    beq     .LinvokeArgsDone
+
+    @ r0=methodToCall, r1=GFED, r3=outSize, r2=count, r9=regSize, r10=outs
+.LinvokeNonRange:
+    rsb     r2, r2, #5                  @ r2<- 5-r2
+    add     pc, pc, r2, lsl #4          @ computed goto, 4 instrs each
+    bl      common_abort                @ (skipped due to ARM prefetch)
+5:  and     ip, rINST, #0x0f00          @ isolate A
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vA (shift right 8, left 2)
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vA
+4:  and     ip, r1, #0xf000             @ isolate G
+    ldr     r2, [rFP, ip, lsr #10]      @ r2<- vG (shift right 12, left 2)
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vG
+3:  and     ip, r1, #0x0f00             @ isolate F
+    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vF
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vF
+2:  and     ip, r1, #0x00f0             @ isolate E
+    ldr     r2, [rFP, ip, lsr #2]       @ r2<- vE
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vE
+1:  and     ip, r1, #0x000f             @ isolate D
+    ldr     r2, [rFP, ip, lsl #2]       @ r2<- vD
+    mov     r0, r0                      @ nop
+    str     r2, [r10, #-4]!             @ *--outs = vD
+0:  @ fall through to .LinvokeArgsDone
+
+.LinvokeArgsDone: @ r0=methodToCall, r3=outSize, r9=regSize
+    ldr     r2, [r0, #offMethod_insns]  @ r2<- method->insns
+    ldr     rINST, [r0, #offMethod_clazz]  @ rINST<- method->clazz
+    @ find space for the new stack frame, check for overflow
+    SAVEAREA_FROM_FP(r1, rFP)           @ r1<- stack save area
+    sub     r1, r1, r9, lsl #2          @ r1<- newFp (old savearea - regsSize)
+    SAVEAREA_FROM_FP(r10, r1)           @ r10<- newSaveArea
+@    bl      common_dumpRegs
+    ldr     r9, [rGLUE, #offGlue_interpStackEnd]    @ r9<- interpStackEnd
+    sub     r3, r10, r3, lsl #2         @ r3<- bottom (newsave - outsSize)
+    cmp     r3, r9                      @ bottom < interpStackEnd?
+    ldr     r3, [r0, #offMethod_accessFlags] @ r3<- methodToCall->accessFlags
+    blt     .LstackOverflow             @ yes, this frame will overflow stack
+
+    @ set up newSaveArea
+#ifdef EASY_GDB
+    SAVEAREA_FROM_FP(ip, rFP)           @ ip<- stack save area
+    str     ip, [r10, #offStackSaveArea_prevSave]
+#endif
+    str     rFP, [r10, #offStackSaveArea_prevFrame]
+    str     rPC, [r10, #offStackSaveArea_savedPc]
+#if defined(WITH_JIT)
+    mov     r9, #0
+    str     r9, [r10, #offStackSaveArea_returnAddr]
+#endif
+    str     r0, [r10, #offStackSaveArea_method]
+    tst     r3, #ACC_NATIVE
+    bne     .LinvokeNative
+
+    /*
+    stmfd   sp!, {r0-r3}
+    bl      common_printNewline
+    mov     r0, rFP
+    mov     r1, #0
+    bl      dvmDumpFp
+    ldmfd   sp!, {r0-r3}
+    stmfd   sp!, {r0-r3}
+    mov     r0, r1
+    mov     r1, r10
+    bl      dvmDumpFp
+    bl      common_printNewline
+    ldmfd   sp!, {r0-r3}
+    */
+
+    ldrh    r9, [r2]                        @ r9 <- load INST from new PC
+    ldr     r3, [rINST, #offClassObject_pDvmDex] @ r3<- method->clazz->pDvmDex
+    mov     rPC, r2                         @ publish new rPC
+    ldr     r2, [rGLUE, #offGlue_self]      @ r2<- glue->self
+
+    @ Update "glue" values for the new method
+    @ r0=methodToCall, r1=newFp, r2=self, r3=newMethodClass, r9=newINST
+    str     r0, [rGLUE, #offGlue_method]    @ glue->method = methodToCall
+    str     r3, [rGLUE, #offGlue_methodClassDex] @ glue->methodClassDex = ...
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    mov     rFP, r1                         @ fp = newFp
+    GET_PREFETCHED_OPCODE(ip, r9)           @ extract prefetched opcode from r9
+    mov     rINST, r9                       @ publish new rINST
+    str     r1, [r2, #offThread_curFrame]   @ self->curFrame = newFp
+    cmp     r0,#0
+    bne     common_updateProfile
+    GOTO_OPCODE(ip)                         @ jump to next instruction
+#else
+    mov     rFP, r1                         @ fp = newFp
+    GET_PREFETCHED_OPCODE(ip, r9)           @ extract prefetched opcode from r9
+    mov     rINST, r9                       @ publish new rINST
+    str     r1, [r2, #offThread_curFrame]   @ self->curFrame = newFp
+    GOTO_OPCODE(ip)                         @ jump to next instruction
+#endif
+
+.LinvokeNative:
+    @ Prep for the native call
+    @ r0=methodToCall, r1=newFp, r10=newSaveArea
+    ldr     r3, [rGLUE, #offGlue_self]      @ r3<- glue->self
+    ldr     r9, [r3, #offThread_jniLocal_topCookie] @ r9<- thread->localRef->...
+    str     r1, [r3, #offThread_curFrame]   @ self->curFrame = newFp
+    str     r9, [r10, #offStackSaveArea_localRefCookie] @newFp->localRefCookie=top
+    mov     r9, r3                      @ r9<- glue->self (preserve)
+
+    mov     r2, r0                      @ r2<- methodToCall
+    mov     r0, r1                      @ r0<- newFp (points to args)
+    add     r1, rGLUE, #offGlue_retval  @ r1<- &retval
+
+#ifdef ASSIST_DEBUGGER
+    /* insert fake function header to help gdb find the stack frame */
+    b       .Lskip
+    .type   dalvik_mterp, %function
+dalvik_mterp:
+    .fnstart
+    MTERP_ENTRY1
+    MTERP_ENTRY2
+.Lskip:
+#endif
+
+    @mov     lr, pc                      @ set return addr
+    @ldr     pc, [r2, #offMethod_nativeFunc] @ pc<- methodToCall->nativeFunc
+    LDR_PC_LR "[r2, #offMethod_nativeFunc]"
+
+    @ native return; r9=self, r10=newSaveArea
+    @ equivalent to dvmPopJniLocals
+    ldr     r0, [r10, #offStackSaveArea_localRefCookie] @ r0<- saved top
+    ldr     r1, [r9, #offThread_exception] @ check for exception
+    str     rFP, [r9, #offThread_curFrame]  @ self->curFrame = fp
+    cmp     r1, #0                      @ null?
+    str     r0, [r9, #offThread_jniLocal_topCookie] @ new top <- old top
+    bne     common_exceptionThrown      @ no, handle exception
+
+    FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LstackOverflow:
+    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- self
+    bl      dvmHandleStackOverflow
+    b       common_exceptionThrown
+#ifdef ASSIST_DEBUGGER
+    .fnend
+#endif
+
+
+    /*
+     * Common code for method invocation, calling through "glue code".
+     *
+     * TODO: now that we have range and non-range invoke handlers, this
+     *       needs to be split into two.  Maybe just create entry points
+     *       that set r9 and jump here?
+     *
+     * On entry:
+     *  r0 is "Method* methodToCall", the method we're trying to call
+     *  r9 is "bool methodCallRange", indicating if this is a /range variant
+     */
+     .if    0
+.LinvokeOld:
+    sub     sp, sp, #8                  @ space for args + pad
+    FETCH(ip, 2)                        @ ip<- FEDC or CCCC
+    mov     r2, r0                      @ A2<- methodToCall
+    mov     r0, rGLUE                   @ A0<- glue
+    SAVE_PC_FP_TO_GLUE()                @ export state to "glue"
+    mov     r1, r9                      @ A1<- methodCallRange
+    mov     r3, rINST, lsr #8           @ A3<- AA
+    str     ip, [sp, #0]                @ A4<- ip
+    bl      dvmMterp_invokeMethod       @ call the C invokeMethod
+    add     sp, sp, #8                  @ remove arg area
+    b       common_resumeAfterGlueCall  @ continue to next instruction
+    .endif
+
+
+
+/*
+ * Common code for handling a return instruction.
+ *
+ * This does not return.
+ */
+common_returnFromMethod:
+.LreturnNew:
+    mov     r0, #kInterpEntryReturn
+    mov     r9, #0
+    bl      common_periodicChecks
+
+    SAVEAREA_FROM_FP(r0, rFP)           @ r0<- saveArea (old)
+    ldr     rFP, [r0, #offStackSaveArea_prevFrame] @ fp = saveArea->prevFrame
+    ldr     r9, [r0, #offStackSaveArea_savedPc] @ r9 = saveArea->savedPc
+    ldr     r2, [rFP, #(offStackSaveArea_method - sizeofStackSaveArea)]
+                                        @ r2<- method we're returning to
+    ldr     r3, [rGLUE, #offGlue_self]  @ r3<- glue->self
+    cmp     r2, #0                      @ is this a break frame?
+    ldrne   r10, [r2, #offMethod_clazz] @ r10<- method->clazz
+    mov     r1, #0                      @ "want switch" = false
+    beq     common_gotoBail             @ break frame, bail out completely
+
+    PREFETCH_ADVANCE_INST(rINST, r9, 3) @ advance r9, update new rINST
+    str     r2, [rGLUE, #offGlue_method]@ glue->method = newSave->method
+    ldr     r1, [r10, #offClassObject_pDvmDex]   @ r1<- method->clazz->pDvmDex
+    str     rFP, [r3, #offThread_curFrame]  @ self->curFrame = fp
+#if defined(WITH_JIT)
+    ldr     r3, [r0, #offStackSaveArea_returnAddr] @ r3 = saveArea->returnAddr
+    GET_JIT_PROF_TABLE(r0)
+    mov     rPC, r9                     @ publish new rPC
+    str     r1, [rGLUE, #offGlue_methodClassDex]
+    cmp     r3, #0                      @ caller is compiled code
+    blxne   r3
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    mov     rPC, r9                     @ publish new rPC
+    str     r1, [rGLUE, #offGlue_methodClassDex]
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
+    /*
+     * Return handling, calls through "glue code".
+     */
+     .if    0
+.LreturnOld:
+    SAVE_PC_FP_TO_GLUE()                @ export state
+    mov     r0, rGLUE                   @ arg to function
+    bl      dvmMterp_returnFromMethod
+    b       common_resumeAfterGlueCall
+    .endif
+
+
+/*
+ * Somebody has thrown an exception.  Handle it.
+ *
+ * If the exception processing code returns to us (instead of falling
+ * out of the interpreter), continue with whatever the next instruction
+ * now happens to be.
+ *
+ * This does not return.
+ */
+     .global dvmMterpCommonExceptionThrown
+dvmMterpCommonExceptionThrown:
+common_exceptionThrown:
+.LexceptionNew:
+    mov     r0, #kInterpEntryThrow
+    mov     r9, #0
+    bl      common_periodicChecks
+
+#if defined(WITH_JIT)
+    mov     r2,#kJitTSelectAbort        @ abandon trace selection in progress
+    str     r2,[rGLUE,#offGlue_jitState]
+#endif
+
+    ldr     r10, [rGLUE, #offGlue_self] @ r10<- glue->self
+    ldr     r9, [r10, #offThread_exception] @ r9<- self->exception
+    mov     r1, r10                     @ r1<- self
+    mov     r0, r9                      @ r0<- exception
+    bl      dvmAddTrackedAlloc          @ don't let the exception be GCed
+    mov     r3, #0                      @ r3<- NULL
+    str     r3, [r10, #offThread_exception] @ self->exception = NULL
+
+    /* set up args and a local for "&fp" */
+    /* (str sp, [sp, #-4]!  would be perfect here, but is discouraged) */
+    str     rFP, [sp, #-4]!             @ *--sp = fp
+    mov     ip, sp                      @ ip<- &fp
+    mov     r3, #0                      @ r3<- false
+    str     ip, [sp, #-4]!              @ *--sp = &fp
+    ldr     r1, [rGLUE, #offGlue_method] @ r1<- glue->method
+    mov     r0, r10                     @ r0<- self
+    ldr     r1, [r1, #offMethod_insns]  @ r1<- method->insns
+    mov     r2, r9                      @ r2<- exception
+    sub     r1, rPC, r1                 @ r1<- pc - method->insns
+    mov     r1, r1, asr #1              @ r1<- offset in code units
+
+    /* call, r0 gets catchRelPc (a code-unit offset) */
+    bl      dvmFindCatchBlock           @ call(self, relPc, exc, scan?, &fp)
+
+    /* fix earlier stack overflow if necessary; may trash rFP */
+    ldrb    r1, [r10, #offThread_stackOverflowed]
+    cmp     r1, #0                      @ did we overflow earlier?
+    beq     1f                          @ no, skip ahead
+    mov     rFP, r0                     @ save relPc result in rFP
+    mov     r0, r10                     @ r0<- self
+    bl      dvmCleanupStackOverflow     @ call(self)
+    mov     r0, rFP                     @ restore result
+1:
+
+    /* update frame pointer and check result from dvmFindCatchBlock */
+    ldr     rFP, [sp, #4]               @ retrieve the updated rFP
+    cmp     r0, #0                      @ is catchRelPc < 0?
+    add     sp, sp, #8                  @ restore stack
+    bmi     .LnotCaughtLocally
+
+    /* adjust locals to match self->curFrame and updated PC */
+    SAVEAREA_FROM_FP(r1, rFP)           @ r1<- new save area
+    ldr     r1, [r1, #offStackSaveArea_method] @ r1<- new method
+    str     r1, [rGLUE, #offGlue_method]    @ glue->method = new method
+    ldr     r2, [r1, #offMethod_clazz]      @ r2<- method->clazz
+    ldr     r3, [r1, #offMethod_insns]      @ r3<- method->insns
+    ldr     r2, [r2, #offClassObject_pDvmDex] @ r2<- method->clazz->pDvmDex
+    add     rPC, r3, r0, asl #1             @ rPC<- method->insns + catchRelPc
+    str     r2, [rGLUE, #offGlue_methodClassDex] @ glue->pDvmDex = meth...
+
+    /* release the tracked alloc on the exception */
+    mov     r0, r9                      @ r0<- exception
+    mov     r1, r10                     @ r1<- self
+    bl      dvmReleaseTrackedAlloc      @ release the exception
+
+    /* restore the exception if the handler wants it */
+    FETCH_INST()                        @ load rINST from rPC
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    cmp     ip, #OP_MOVE_EXCEPTION      @ is it "move-exception"?
+    streq   r9, [r10, #offThread_exception] @ yes, restore the exception
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LnotCaughtLocally: @ r9=exception, r10=self
+    /* fix stack overflow if necessary */
+    ldrb    r1, [r10, #offThread_stackOverflowed]
+    cmp     r1, #0                      @ did we overflow earlier?
+    movne   r0, r10                     @ if yes: r0<- self
+    blne    dvmCleanupStackOverflow     @ if yes: call(self)
+
+    @ may want to show "not caught locally" debug messages here
+#if DVM_SHOW_EXCEPTION >= 2
+    /* call __android_log_print(prio, tag, format, ...) */
+    /* "Exception %s from %s:%d not caught locally" */
+    @ dvmLineNumFromPC(method, pc - method->insns)
+    ldr     r0, [rGLUE, #offGlue_method]
+    ldr     r1, [r0, #offMethod_insns]
+    sub     r1, rPC, r1
+    asr     r1, r1, #1
+    bl      dvmLineNumFromPC
+    str     r0, [sp, #-4]!
+    @ dvmGetMethodSourceFile(method)
+    ldr     r0, [rGLUE, #offGlue_method]
+    bl      dvmGetMethodSourceFile
+    str     r0, [sp, #-4]!
+    @ exception->clazz->descriptor
+    ldr     r3, [r9, #offObject_clazz]
+    ldr     r3, [r3, #offClassObject_descriptor]
+    @
+    ldr     r2, strExceptionNotCaughtLocally
+    ldr     r1, strLogTag
+    mov     r0, #3                      @ LOG_DEBUG
+    bl      __android_log_print
+#endif
+    str     r9, [r10, #offThread_exception] @ restore exception
+    mov     r0, r9                      @ r0<- exception
+    mov     r1, r10                     @ r1<- self
+    bl      dvmReleaseTrackedAlloc      @ release the exception
+    mov     r1, #0                      @ "want switch" = false
+    b       common_gotoBail             @ bail out
+
+
+    /*
+     * Exception handling, calls through "glue code".
+     */
+    .if     0
+.LexceptionOld:
+    SAVE_PC_FP_TO_GLUE()                @ export state
+    mov     r0, rGLUE                   @ arg to function
+    bl      dvmMterp_exceptionThrown
+    b       common_resumeAfterGlueCall
+    .endif
+
+
+/*
+ * After returning from a "glued" function, pull out the updated
+ * values and start executing at the next instruction.
+ */
+common_resumeAfterGlueCall:
+    LOAD_PC_FP_FROM_GLUE()              @ pull rPC and rFP out of glue
+    FETCH_INST()                        @ load rINST from rPC
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/*
+ * Invalid array index.
+ */
+common_errArrayIndex:
+    EXPORT_PC()
+    ldr     r0, strArrayIndexException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Invalid array value.
+ */
+common_errArrayStore:
+    EXPORT_PC()
+    ldr     r0, strArrayStoreException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Integer divide or mod by zero.
+ */
+common_errDivideByZero:
+    EXPORT_PC()
+    ldr     r0, strArithmeticException
+    ldr     r1, strDivideByZero
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Attempt to allocate an array with a negative size.
+ */
+common_errNegativeArraySize:
+    EXPORT_PC()
+    ldr     r0, strNegativeArraySizeException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * Invocation of a non-existent method.
+ */
+common_errNoSuchMethod:
+    EXPORT_PC()
+    ldr     r0, strNoSuchMethodError
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * We encountered a null object when we weren't expecting one.  We
+ * export the PC, throw a NullPointerException, and goto the exception
+ * processing code.
+ */
+common_errNullObject:
+    EXPORT_PC()
+    ldr     r0, strNullPointerException
+    mov     r1, #0
+    bl      dvmThrowException
+    b       common_exceptionThrown
+
+/*
+ * For debugging, cause an immediate fault.  The source address will
+ * be in lr (use a bl instruction to jump here).
+ */
+common_abort:
+    ldr     pc, .LdeadFood
+.LdeadFood:
+    .word   0xdeadf00d
+
+/*
+ * Spit out a "we were here", preserving all registers.  (The attempt
+ * to save ip won't work, but we need to save an even number of
+ * registers for EABI 64-bit stack alignment.)
+ */
+    .macro  SQUEAK num
+common_squeak\num:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    ldr     r0, strSqueak
+    mov     r1, #\num
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+    .endm
+
+    SQUEAK  0
+    SQUEAK  1
+    SQUEAK  2
+    SQUEAK  3
+    SQUEAK  4
+    SQUEAK  5
+
+/*
+ * Spit out the number in r0, preserving registers.
+ */
+common_printNum:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r1, r0
+    ldr     r0, strSqueak
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print a newline, preserving registers.
+ */
+common_printNewline:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    ldr     r0, strNewline
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+    /*
+     * Print the 32-bit quantity in r0 as a hex value, preserving registers.
+     */
+common_printHex:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r1, r0
+    ldr     r0, strPrintHex
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print the 64-bit quantity in r0-r1, preserving registers.
+ */
+common_printLong:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    mov     r3, r1
+    mov     r2, r0
+    ldr     r0, strPrintLong
+    bl      printf
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Print full method info.  Pass the Method* in r0.  Preserves regs.
+ */
+common_printMethod:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bl      dvmMterpPrintMethod
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+
+/*
+ * Call a C helper function that dumps regs and possibly some
+ * additional info.  Requires the C function to be compiled in.
+ */
+    .if     0
+common_dumpRegs:
+    stmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bl      dvmMterpDumpArmRegs
+    ldmfd   sp!, {r0, r1, r2, r3, ip, lr}
+    bx      lr
+    .endif
+
+#if 0
+/*
+ * Experiment on VFP mode.
+ *
+ * uint32_t setFPSCR(uint32_t val, uint32_t mask)
+ *
+ * Updates the bits specified by "mask", setting them to the values in "val".
+ */
+setFPSCR:
+    and     r0, r0, r1                  @ make sure no stray bits are set
+    fmrx    r2, fpscr                   @ get VFP reg
+    mvn     r1, r1                      @ bit-invert mask
+    and     r2, r2, r1                  @ clear masked bits
+    orr     r2, r2, r0                  @ set specified bits
+    fmxr    fpscr, r2                   @ set VFP reg
+    mov     r0, r2                      @ return new value
+    bx      lr
+
+    .align  2
+    .global dvmConfigureFP
+    .type   dvmConfigureFP, %function
+dvmConfigureFP:
+    stmfd   sp!, {ip, lr}
+    /* 0x03000000 sets DN/FZ */
+    /* 0x00009f00 clears the six exception enable flags */
+    bl      common_squeak0
+    mov     r0, #0x03000000             @ r0<- 0x03000000
+    add     r1, r0, #0x9f00             @ r1<- 0x03009f00
+    bl      setFPSCR
+    ldmfd   sp!, {ip, pc}
+#endif
+
+
+/*
+ * String references, must be close to the code that uses them.
+ */
+    .align  2
+strArithmeticException:
+    .word   .LstrArithmeticException
+strArrayIndexException:
+    .word   .LstrArrayIndexException
+strArrayStoreException:
+    .word   .LstrArrayStoreException
+strDivideByZero:
+    .word   .LstrDivideByZero
+strNegativeArraySizeException:
+    .word   .LstrNegativeArraySizeException
+strNoSuchMethodError:
+    .word   .LstrNoSuchMethodError
+strNullPointerException:
+    .word   .LstrNullPointerException
+
+strLogTag:
+    .word   .LstrLogTag
+strExceptionNotCaughtLocally:
+    .word   .LstrExceptionNotCaughtLocally
+
+strNewline:
+    .word   .LstrNewline
+strSqueak:
+    .word   .LstrSqueak
+strPrintHex:
+    .word   .LstrPrintHex
+strPrintLong:
+    .word   .LstrPrintLong
+
+/*
+ * Zero-terminated ASCII string data.
+ *
+ * On ARM we have two choices: do like gcc does, and LDR from a .word
+ * with the address, or use an ADR pseudo-op to get the address
+ * directly.  ADR saves 4 bytes and an indirection, but it's using a
+ * PC-relative addressing mode and hence has a limited range, which
+ * makes it not work well with mergeable string sections.
+ */
+    .section .rodata.str1.4,"aMS",%progbits,1
+
+.LstrBadEntryPoint:
+    .asciz  "Bad entry point %d\n"
+.LstrArithmeticException:
+    .asciz  "Ljava/lang/ArithmeticException;"
+.LstrArrayIndexException:
+    .asciz  "Ljava/lang/ArrayIndexOutOfBoundsException;"
+.LstrArrayStoreException:
+    .asciz  "Ljava/lang/ArrayStoreException;"
+.LstrClassCastException:
+    .asciz  "Ljava/lang/ClassCastException;"
+.LstrDivideByZero:
+    .asciz  "divide by zero"
+.LstrFilledNewArrayNotImpl:
+    .asciz  "filled-new-array only implemented for objects and 'int'"
+.LstrInternalError:
+    .asciz  "Ljava/lang/InternalError;"
+.LstrInstantiationError:
+    .asciz  "Ljava/lang/InstantiationError;"
+.LstrNegativeArraySizeException:
+    .asciz  "Ljava/lang/NegativeArraySizeException;"
+.LstrNoSuchMethodError:
+    .asciz  "Ljava/lang/NoSuchMethodError;"
+.LstrNullPointerException:
+    .asciz  "Ljava/lang/NullPointerException;"
+
+.LstrLogTag:
+    .asciz  "mterp"
+.LstrExceptionNotCaughtLocally:
+    .asciz  "Exception %s from %s:%d not caught locally\n"
+
+.LstrNewline:
+    .asciz  "\n"
+.LstrSqueak:
+    .asciz  "<%d>"
+.LstrPrintHex:
+    .asciz  "<0x%x>"
+.LstrPrintLong:
+    .asciz  "<%lld>"
+
+.Lstr_gettaint:
+    .asciz  "get_taint:<%d>"
+.Lstr_settaint:
+    .asciz  "set_taint:<%d>"
diff --git a/vm/mterp/armv5te_taint/header.S b/vm/mterp/armv5te_taint/header.S
new file mode 100644
index 0000000..76bc76c
--- /dev/null
+++ b/vm/mterp/armv5te_taint/header.S
@@ -0,0 +1,210 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/*
+ * ARMv5 definitions and declarations.
+ */
+
+/*
+ARM EABI general notes:
+
+r0-r3 hold first 4 args to a method; they are not preserved across method calls
+r4-r8 are available for general use
+r9 is given special treatment in some situations, but not for us
+r10 (sl) seems to be generally available
+r11 (fp) is used by gcc (unless -fomit-frame-pointer is set)
+r12 (ip) is scratch -- not preserved across method calls
+r13 (sp) should be managed carefully in case a signal arrives
+r14 (lr) must be preserved
+r15 (pc) can be tinkered with directly
+
+r0 holds returns of <= 4 bytes
+r0-r1 hold returns of 8 bytes, low word in r0
+
+Callee must save/restore r4+ (except r12) if it modifies them.  If VFP
+is present, registers s16-s31 (a/k/a d8-d15, a/k/a q4-q7) must be preserved,
+s0-s15 (d0-d7, q0-a3) do not need to be.
+
+Stack is "full descending".  Only the arguments that don't fit in the first 4
+registers are placed on the stack.  "sp" points at the first stacked argument
+(i.e. the 5th arg).
+
+VFP: single-precision results in s0, double-precision results in d0.
+
+In the EABI, "sp" must be 64-bit aligned on entry to a function, and any
+64-bit quantities (long long, double) must be 64-bit aligned.
+*/
+
+/*
+Mterp and ARM notes:
+
+The following registers have fixed assignments:
+
+  reg nick      purpose
+  r4  rPC       interpreted program counter, used for fetching instructions
+  r5  rFP       interpreted frame pointer, used for accessing locals and args
+  r6  rGLUE     MterpGlue pointer
+  r7  rINST     first 16-bit code unit of current instruction
+  r8  rIBASE    interpreted instruction base pointer, used for computed goto
+
+Macros are provided for common operations.  Each macro MUST emit only
+one instruction to make instruction-counting easier.  They MUST NOT alter
+unspecified registers or condition codes.
+*/
+
+/* single-purpose registers, given names for clarity */
+#define rPC     r4
+#define rFP     r5
+#define rGLUE   r6
+#define rINST   r7
+#define rIBASE  r8
+
+/* save/restore the PC and/or FP from the glue struct */
+#define LOAD_PC_FROM_GLUE()     ldr     rPC, [rGLUE, #offGlue_pc]
+#define SAVE_PC_TO_GLUE()       str     rPC, [rGLUE, #offGlue_pc]
+#define LOAD_FP_FROM_GLUE()     ldr     rFP, [rGLUE, #offGlue_fp]
+#define SAVE_FP_TO_GLUE()       str     rFP, [rGLUE, #offGlue_fp]
+#define LOAD_PC_FP_FROM_GLUE()  ldmia   rGLUE, {rPC, rFP}
+#define SAVE_PC_FP_TO_GLUE()    stmia   rGLUE, {rPC, rFP}
+
+/*
+ * "export" the PC to the stack frame, f/b/o future exception objects.  Must
+ * be done *before* something calls dvmThrowException.
+ *
+ * In C this is "SAVEAREA_FROM_FP(fp)->xtra.currentPc = pc", i.e.
+ * fp - sizeof(StackSaveArea) + offsetof(SaveArea, xtra.currentPc)
+ *
+ * It's okay to do this more than once.
+ */
+#define EXPORT_PC() \
+    str     rPC, [rFP, #(-sizeofStackSaveArea + offStackSaveArea_currentPc)]
+
+/*
+ * Given a frame pointer, find the stack save area.
+ *
+ * In C this is "((StackSaveArea*)(_fp) -1)".
+ */
+#define SAVEAREA_FROM_FP(_reg, _fpreg) \
+    sub     _reg, _fpreg, #sizeofStackSaveArea
+
+/*
+ * Fetch the next instruction from rPC into rINST.  Does not advance rPC.
+ */
+#define FETCH_INST()            ldrh    rINST, [rPC]
+
+/*
+ * Fetch the next instruction from the specified offset.  Advances rPC
+ * to point to the next instruction.  "_count" is in 16-bit code units.
+ *
+ * Because of the limited size of immediate constants on ARM, this is only
+ * suitable for small forward movements (i.e. don't try to implement "goto"
+ * with this).
+ *
+ * This must come AFTER anything that can throw an exception, or the
+ * exception catch may miss.  (This also implies that it must come after
+ * EXPORT_PC().)
+ */
+#define FETCH_ADVANCE_INST(_count) ldrh    rINST, [rPC, #(_count*2)]!
+
+/*
+ * The operation performed here is similar to FETCH_ADVANCE_INST, except the
+ * src and dest registers are parameterized (not hard-wired to rPC and rINST).
+ */
+#define PREFETCH_ADVANCE_INST(_dreg, _sreg, _count) \
+        ldrh    _dreg, [_sreg, #(_count*2)]!
+
+/*
+ * Fetch the next instruction from an offset specified by _reg.  Updates
+ * rPC to point to the next instruction.  "_reg" must specify the distance
+ * in bytes, *not* 16-bit code units, and may be a signed value.
+ *
+ * We want to write "ldrh rINST, [rPC, _reg, lsl #2]!", but some of the
+ * bits that hold the shift distance are used for the half/byte/sign flags.
+ * In some cases we can pre-double _reg for free, so we require a byte offset
+ * here.
+ */
+#define FETCH_ADVANCE_INST_RB(_reg) ldrh    rINST, [rPC, _reg]!
+
+/*
+ * Fetch a half-word code unit from an offset past the current PC.  The
+ * "_count" value is in 16-bit code units.  Does not advance rPC.
+ *
+ * The "_S" variant works the same but treats the value as signed.
+ */
+#define FETCH(_reg, _count)     ldrh    _reg, [rPC, #(_count*2)]
+#define FETCH_S(_reg, _count)   ldrsh   _reg, [rPC, #(_count*2)]
+
+/*
+ * Fetch one byte from an offset past the current PC.  Pass in the same
+ * "_count" as you would for FETCH, and an additional 0/1 indicating which
+ * byte of the halfword you want (lo/hi).
+ */
+#define FETCH_B(_reg, _count, _byte) ldrb     _reg, [rPC, #(_count*2+_byte)]
+
+/*
+ * Put the instruction's opcode field into the specified register.
+ */
+#define GET_INST_OPCODE(_reg)   and     _reg, rINST, #255
+
+/*
+ * Put the prefetched instruction's opcode field into the specified register.
+ */
+#define GET_PREFETCHED_OPCODE(_oreg, _ireg)   and     _oreg, _ireg, #255
+
+/*
+ * Begin executing the opcode in _reg.  Because this only jumps within the
+ * interpreter, we don't have to worry about pre-ARMv5 THUMB interwork.
+ */
+#define GOTO_OPCODE(_reg)       add     pc, rIBASE, _reg, lsl #${handler_size_bits}
+#define GOTO_OPCODE_IFEQ(_reg)  addeq   pc, rIBASE, _reg, lsl #${handler_size_bits}
+#define GOTO_OPCODE_IFNE(_reg)  addne   pc, rIBASE, _reg, lsl #${handler_size_bits}
+
+/*
+ * Get/set the 32-bit value from a Dalvik register.
+ */
+#ifdef WITH_TAINT_TRACKING
+#define SET_TAINT_FP(_reg)		add		_reg, rFP, #4
+#define SET_TAINT_CLEAR(_reg)	mov		_reg, #0
+#define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #3]
+#define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #3]
+#define GET_VREG_TAINT(_reg, _vreg, _rFP)	ldr	_reg, [_rFP, _vreg, lsl #3]
+#define SET_VREG_TAINT(_reg, _vreg, _rFP)	str _reg, [_rFP, _vreg, lsl #3]
+#else
+#define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #2]
+#define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #2]
+#endif /*WITH_TAINT_TRACKING*/
+
+#if defined(WITH_JIT)
+#define GET_JIT_ENABLED(_reg)       ldr     _reg,[rGLUE,#offGlue_jitEnabled]
+#define GET_JIT_PROF_TABLE(_reg)    ldr     _reg,[rGLUE,#offGlue_pJitProfTable]
+#endif
+
+/*
+ * Convert a virtual register index into an address.
+ */
+#ifdef WITH_TAINT_TRACKING
+#define VREG_INDEX_TO_ADDR(_reg, _vreg) \
+        add     _reg, rFP, _vreg, lsl #3
+#else
+#define VREG_INDEX_TO_ADDR(_reg, _vreg) \
+        add     _reg, rFP, _vreg, lsl #2
+#endif /*WITH_TAINT_TRACKING*/
+
+/*
+ * This is a #include, not a %include, because we want the C pre-processor
+ * to expand the macros into assembler assignment statements.
+ */
+#include "../common/asm-constants.h"
+
diff --git a/vm/mterp/armv5te_taint/unop.S b/vm/mterp/armv5te_taint/unop.S
new file mode 100644
index 0000000..1786a45
--- /dev/null
+++ b/vm/mterp/armv5te_taint/unop.S
@@ -0,0 +1,26 @@
+%default {"preinstr":""}
+    /*
+     * Generic 32-bit unary operation.  Provide an "instr" line that
+     * specifies an instruction that performs "result = op r0".
+     * This could be an ARM instruction or a function call.
+     *
+     * for: neg-int, not-int, neg-float, int-to-float, float-to-int,
+     *      int-to-byte, int-to-char, int-to-short
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    GET_VREG(r0, r3)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
+    $preinstr                           @ optional op; may set condition codes
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    $instr                              @ r0<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 9-10 instructions */
diff --git a/vm/mterp/armv5te_taint/unopNarrower.S b/vm/mterp/armv5te_taint/unopNarrower.S
new file mode 100644
index 0000000..1583f59
--- /dev/null
+++ b/vm/mterp/armv5te_taint/unopNarrower.S
@@ -0,0 +1,33 @@
+%default {"preinstr":""}
+    /*
+     * Generic 64bit-to-32bit unary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = op r0/r1", where
+     * "result" is a 32-bit quantity in r0.
+     *
+     * For: long-to-float, double-to-int, double-to-float
+     *
+     * (This would work for long-to-int, but that instruction is actually
+     * an exact match for OP_MOVE.)
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    mov     r9, rINST, lsr #8           @ r9<- A+
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    and     r9, r9, #15
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1
+	ldr		r0, [r3, #0]
+	ldr		r10, [r3, #4]
+	ldr		r1, [r3, #8]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ r0<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    SET_VREG(r0, r9)                    @ vA<- r0
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r10, r9, r1)
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
diff --git a/vm/mterp/armv5te_taint/unopWide.S b/vm/mterp/armv5te_taint/unopWide.S
new file mode 100644
index 0000000..42889fb
--- /dev/null
+++ b/vm/mterp/armv5te_taint/unopWide.S
@@ -0,0 +1,37 @@
+%default {"preinstr":""}
+    /*
+     * Generic 64-bit unary operation.  Provide an "instr" line that
+     * specifies an instruction that performs "result = op r0/r1".
+     * This could be an ARM instruction or a function call.
+     *
+     * For: neg-long, not-long, neg-double, long-to-double, double-to-long
+     */
+    /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ r0/r1<- op, r2-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
diff --git a/vm/mterp/armv5te_taint/unopWider.S b/vm/mterp/armv5te_taint/unopWider.S
new file mode 100644
index 0000000..d8eb89b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/unopWider.S
@@ -0,0 +1,35 @@
+%default {"preinstr":""}
+    /*
+     * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = op r0", where
+     * "result" is a 64-bit quantity in r0/r1.
+     *
+     * For: int-to-long, int-to-double, float-to-long, float-to-double
+     */
+    /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
+    mov     r3, rINST, lsr #12          @ r3<- B
+    and     r9, r9, #15
+    GET_VREG(r0, r3)                    @ r0<- vB
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r3, r2)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+// end WITH_TAINT_TRACKING
+    $preinstr                           @ optional op; may set condition codes
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    $instr                              @ r0<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+	b     .L${opcode}_finish
+%break
+
+.L${opcode}_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
diff --git a/vm/mterp/armv5te_taint/unused.S b/vm/mterp/armv5te_taint/unused.S
new file mode 100644
index 0000000..1c82919
--- /dev/null
+++ b/vm/mterp/armv5te_taint/unused.S
@@ -0,0 +1,2 @@
+    bl      common_abort
+
diff --git a/vm/mterp/armv5te_taint/zcmp.S b/vm/mterp/armv5te_taint/zcmp.S
new file mode 100644
index 0000000..861ca5b
--- /dev/null
+++ b/vm/mterp/armv5te_taint/zcmp.S
@@ -0,0 +1,32 @@
+%verify "branch taken"
+%verify "branch not taken"
+    /*
+     * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
+     * fragment that specifies the *reverse* comparison to perform, e.g.
+     * for "if-le" you would use "gt".
+     *
+     * for: if-eqz, if-nez, if-ltz, if-gez, if-gtz, if-lez
+     */
+    /* if-cmp vAA, +BBBB */
+    mov     r0, rINST, lsr #8           @ r0<- AA
+    GET_VREG(r2, r0)                    @ r2<- vAA
+    mov     r9, #4                      @ r0<- BYTE branch dist for not-taken
+    cmp     r2, #0                      @ compare (vA, 0)
+    b${revcmp}  1f                      @ branch to 1 if comparison failed
+    FETCH_S(r9, 1)                      @ r9<- branch offset, in code units
+    movs    r9, r9, asl #1              @ convert to bytes, check sign
+    bmi     common_backwardBranch       @ backward branch, do periodic checks
+1:
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    cmp     r0,#0
+    bne     common_updateProfile
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
diff --git a/vm/mterp/armv6t2_taint/OP_ADD_FLOAT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_ADD_FLOAT_2ADDR.S
new file mode 100644
index 0000000..cb00780
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_ADD_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      __aeabi_fadd"}
diff --git a/vm/mterp/armv6t2_taint/OP_ADD_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_ADD_INT_2ADDR.S
new file mode 100644
index 0000000..8be2cec
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_ADD_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"add     r0, r0, r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_AND_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_AND_INT_2ADDR.S
new file mode 100644
index 0000000..67ca617
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_AND_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"and     r0, r0, r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_DIV_FLOAT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_DIV_FLOAT_2ADDR.S
new file mode 100644
index 0000000..4d2e989
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_DIV_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      __aeabi_fdiv"}
diff --git a/vm/mterp/armv6t2_taint/OP_DIV_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_DIV_INT_2ADDR.S
new file mode 100644
index 0000000..5f9bc0a
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_DIV_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl     __aeabi_idiv","chkzero":"1"}
diff --git a/vm/mterp/armv6t2_taint/OP_FLOAT_TO_INT.S b/vm/mterp/armv6t2_taint/OP_FLOAT_TO_INT.S
new file mode 100644
index 0000000..86cbd74
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_FLOAT_TO_INT.S
@@ -0,0 +1,41 @@
+%verify "executed"
+/* EABI appears to have Java-style conversions of +inf/-inf/NaN */
+%include "armv6t2_taint/unop.S" {"instr":"bl      __aeabi_f2iz"}
+
+#if 0
+@include "armv6t2/unop.S" {"instr":"bl      f2i_doconv"}
+@break
+/*
+ * Convert the float in r0 to an int in r0.
+ *
+ * We have to clip values to int min/max per the specification.  The
+ * expected common case is a "reasonable" value that converts directly
+ * to modest integer.  The EABI convert function isn't doing this for us.
+ */
+f2i_doconv:
+    stmfd   sp!, {r4, lr}
+    mov     r1, #0x4f000000             @ (float)maxint
+    mov     r4, r0
+    bl      __aeabi_fcmpge              @ is arg >= maxint?
+    cmp     r0, #0                      @ nonzero == yes
+    mvnne   r0, #0x80000000             @ return maxint (7fffffff)
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, #0xcf000000             @ (float)minint
+    bl      __aeabi_fcmple              @ is arg <= minint?
+    cmp     r0, #0                      @ nonzero == yes
+    movne   r0, #0x80000000             @ return minint (80000000)
+    ldmnefd sp!, {r4, pc}
+
+    mov     r0, r4                      @ recover arg
+    mov     r1, r4
+    bl      __aeabi_fcmpeq              @ is arg == self?
+    cmp     r0, #0                      @ zero == no
+    ldmeqfd sp!, {r4, pc}               @ return zero for NaN
+
+    mov     r0, r4                      @ recover arg
+    bl      __aeabi_f2iz                @ convert float to int
+    ldmfd   sp!, {r4, pc}
+#endif
+
diff --git a/vm/mterp/armv6t2_taint/OP_IF_EQ.S b/vm/mterp/armv6t2_taint/OP_IF_EQ.S
new file mode 100644
index 0000000..d33125d
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_EQ.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"ne" }
diff --git a/vm/mterp/armv6t2_taint/OP_IF_GE.S b/vm/mterp/armv6t2_taint/OP_IF_GE.S
new file mode 100644
index 0000000..2fd973c
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_GE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"lt" }
diff --git a/vm/mterp/armv6t2_taint/OP_IF_GT.S b/vm/mterp/armv6t2_taint/OP_IF_GT.S
new file mode 100644
index 0000000..819e4c8
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_GT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"le" }
diff --git a/vm/mterp/armv6t2_taint/OP_IF_LE.S b/vm/mterp/armv6t2_taint/OP_IF_LE.S
new file mode 100644
index 0000000..95fa0a9
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_LE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"gt" }
diff --git a/vm/mterp/armv6t2_taint/OP_IF_LT.S b/vm/mterp/armv6t2_taint/OP_IF_LT.S
new file mode 100644
index 0000000..3e6616e
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_LT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"ge" }
diff --git a/vm/mterp/armv6t2_taint/OP_IF_NE.S b/vm/mterp/armv6t2_taint/OP_IF_NE.S
new file mode 100644
index 0000000..21ec275
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IF_NE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/bincmp.S" { "revcmp":"eq" }
diff --git a/vm/mterp/armv6t2_taint/OP_IGET.S b/vm/mterp/armv6t2_taint/OP_IGET.S
new file mode 100644
index 0000000..537c534
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IGET.S
@@ -0,0 +1,46 @@
+%default { "load":"ldr", "sqnum":"0" }
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit instance field get.
+     *
+     * for: iget, iget-object, iget-boolean, iget-byte, iget-char, iget-short
+     */
+    /* op vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0
+    bne     .L${opcode}_finish
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    @bl      common_squeak${sqnum}
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    $load   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IGET_QUICK.S b/vm/mterp/armv6t2_taint/OP_IGET_QUICK.S
new file mode 100644
index 0000000..83714d5
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IGET_QUICK.S
@@ -0,0 +1,16 @@
+%verify "executed"
+%verify "null object"
+    /* For: iget-quick, iget-object-quick */
+    /* op vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    GET_VREG(r3, r2)                    @ r3<- object we're operating on
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    cmp     r3, #0                      @ check object for null
+    beq     common_errNullObject        @ object was null
+    ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r2)                    @ fp[A]<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IGET_WIDE.S b/vm/mterp/armv6t2_taint/OP_IGET_WIDE.S
new file mode 100644
index 0000000..948d53d
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IGET_WIDE.S
@@ -0,0 +1,43 @@
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * Wide 32-bit instance field get.
+     */
+    /* iget-wide vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0
+    bne     .L${opcode}_finish
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    beq     common_errNullObject        @ object was null
+    ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IGET_WIDE_QUICK.S b/vm/mterp/armv6t2_taint/OP_IGET_WIDE_QUICK.S
new file mode 100644
index 0000000..129f424
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IGET_WIDE_QUICK.S
@@ -0,0 +1,16 @@
+%verify "executed"
+%verify "null object"
+    /* iget-wide-quick vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    GET_VREG(r3, r2)                    @ r3<- object we're operating on
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    cmp     r3, #0                      @ check object for null
+    beq     common_errNullObject        @ object was null
+    ldrd    r0, [r3, r1]                @ r0<- obj.field (64 bits, aligned)
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_INT_TO_BYTE.S b/vm/mterp/armv6t2_taint/OP_INT_TO_BYTE.S
new file mode 100644
index 0000000..ec31b79
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_INT_TO_BYTE.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"sxtb    r0, r0"}
diff --git a/vm/mterp/armv6t2_taint/OP_INT_TO_CHAR.S b/vm/mterp/armv6t2_taint/OP_INT_TO_CHAR.S
new file mode 100644
index 0000000..22d41f4
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_INT_TO_CHAR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"uxth    r0, r0"}
diff --git a/vm/mterp/armv6t2_taint/OP_INT_TO_FLOAT.S b/vm/mterp/armv6t2_taint/OP_INT_TO_FLOAT.S
new file mode 100644
index 0000000..913b21a
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_INT_TO_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"bl      __aeabi_i2f"}
diff --git a/vm/mterp/armv6t2_taint/OP_INT_TO_SHORT.S b/vm/mterp/armv6t2_taint/OP_INT_TO_SHORT.S
new file mode 100644
index 0000000..012e420
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_INT_TO_SHORT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"sxth    r0, r0"}
diff --git a/vm/mterp/armv6t2_taint/OP_IPUT.S b/vm/mterp/armv6t2_taint/OP_IPUT.S
new file mode 100644
index 0000000..10eea24
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IPUT.S
@@ -0,0 +1,46 @@
+%default { "store":"str", "sqnum":"0" }
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /*
+     * General 32-bit instance field put.
+     *
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
+     */
+    /* op vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish up
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    @bl      common_squeak${sqnum}
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    ubfx    r1, rINST, #8, #4           @ r1<- A
+    cmp     r9, #0                      @ check object for null
+    GET_VREG(r0, r1)                    @ r0<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    $store  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IPUT_QUICK.S b/vm/mterp/armv6t2_taint/OP_IPUT_QUICK.S
new file mode 100644
index 0000000..0b6d61c
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IPUT_QUICK.S
@@ -0,0 +1,16 @@
+%verify "executed"
+%verify "null object"
+    /* For: iput-quick, iput-object-quick */
+    /* op vA, vB, offset@CCCC */
+    mov     r2, rINST, lsr #12          @ r2<- B
+    FETCH(r1, 1)                        @ r1<- field byte offset
+    GET_VREG(r3, r2)                    @ r3<- fp[B], the object pointer
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    cmp     r3, #0                      @ check object for null
+    beq     common_errNullObject        @ object was null
+    GET_VREG(r0, r2)                    @ r0<- fp[A]
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IPUT_WIDE.S b/vm/mterp/armv6t2_taint/OP_IPUT_WIDE.S
new file mode 100644
index 0000000..5c1ab97
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IPUT_WIDE.S
@@ -0,0 +1,40 @@
+%verify "executed"
+%verify "null object"
+%verify "field already resolved"
+%verify "field not yet resolved"
+%verify "field cannot be resolved"
+    /* iput-wide vA, vB, field@CCCC */
+    mov     r0, rINST, lsr #12          @ r0<- B
+    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
+    FETCH(r1, 1)                        @ r1<- field ref CCCC
+    ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ is resolved entry null?
+    bne     .L${opcode}_finish          @ no, already resolved
+8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveInstField         @ r0<- resolved InstField ptr
+    cmp     r0, #0                      @ success?
+    bne     .L${opcode}_finish          @ yes, finish up
+    b       common_exceptionThrown
+%break
+
+    /*
+     * Currently:
+     *  r0 holds resolved field
+     *  r9 holds object
+     */
+.L${opcode}_finish:
+    ubfx    r2, rINST, #8, #4           @ r2<- A
+    cmp     r9, #0                      @ check object for null
+    ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
+    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_IPUT_WIDE_QUICK.S b/vm/mterp/armv6t2_taint/OP_IPUT_WIDE_QUICK.S
new file mode 100644
index 0000000..5cf4798
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_IPUT_WIDE_QUICK.S
@@ -0,0 +1,16 @@
+%verify "executed"
+%verify "null object"
+    /* iput-wide-quick vA, vB, offset@CCCC */
+    mov     r1, rINST, lsr #12          @ r1<- B
+    ubfx    r0, rINST, #8, #4           @ r0<- A
+    GET_VREG(r2, r1)                    @ r2<- fp[B], the object pointer
+    add     r3, rFP, r0, lsl #2         @ r3<- &fp[A]
+    cmp     r2, #0                      @ check object for null
+    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+    beq     common_errNullObject        @ object was null
+    FETCH(r3, 1)                        @ r3<- field byte offset
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    strd    r0, [r2, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
diff --git a/vm/mterp/armv6t2_taint/OP_MUL_FLOAT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_MUL_FLOAT_2ADDR.S
new file mode 100644
index 0000000..248a878
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_MUL_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      __aeabi_fmul"}
diff --git a/vm/mterp/armv6t2_taint/OP_MUL_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_MUL_INT_2ADDR.S
new file mode 100644
index 0000000..b7ecd0f
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_MUL_INT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
+%include "armv6t2_taint/binop2addr.S" {"instr":"mul     r0, r1, r0"}
diff --git a/vm/mterp/armv6t2_taint/OP_NEG_FLOAT.S b/vm/mterp/armv6t2_taint/OP_NEG_FLOAT.S
new file mode 100644
index 0000000..55a2f9c
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_NEG_FLOAT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"add     r0, r0, #0x80000000"}
diff --git a/vm/mterp/armv6t2_taint/OP_NEG_INT.S b/vm/mterp/armv6t2_taint/OP_NEG_INT.S
new file mode 100644
index 0000000..fdaa2b1
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_NEG_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"rsb     r0, r0, #0"}
diff --git a/vm/mterp/armv6t2_taint/OP_NOT_INT.S b/vm/mterp/armv6t2_taint/OP_NOT_INT.S
new file mode 100644
index 0000000..1cdf86b
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_NOT_INT.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/unop.S" {"instr":"mvn     r0, r0"}
diff --git a/vm/mterp/armv6t2_taint/OP_OR_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_OR_INT_2ADDR.S
new file mode 100644
index 0000000..eef1c59
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_OR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"orr     r0, r0, r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_REM_FLOAT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_REM_FLOAT_2ADDR.S
new file mode 100644
index 0000000..ba71069
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_REM_FLOAT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* EABI doesn't define a float remainder function, but libm does */
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      fmodf"}
diff --git a/vm/mterp/armv6t2_taint/OP_REM_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_REM_INT_2ADDR.S
new file mode 100644
index 0000000..10f055b
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_REM_INT_2ADDR.S
@@ -0,0 +1,3 @@
+%verify "executed"
+/* idivmod returns quotient in r0 and remainder in r1 */
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      __aeabi_idivmod", "result":"r1", "chkzero":"1"}
diff --git a/vm/mterp/armv6t2_taint/OP_SHL_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_SHL_INT_2ADDR.S
new file mode 100644
index 0000000..eed4d96
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_SHL_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asl r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_SHR_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_SHR_INT_2ADDR.S
new file mode 100644
index 0000000..b3e4517
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_SHR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, asr r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_SUB_FLOAT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_SUB_FLOAT_2ADDR.S
new file mode 100644
index 0000000..c785f88
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_SUB_FLOAT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"bl      __aeabi_fsub"}
diff --git a/vm/mterp/armv6t2_taint/OP_SUB_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_SUB_INT_2ADDR.S
new file mode 100644
index 0000000..25446b1
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_SUB_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"sub     r0, r0, r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_USHR_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_USHR_INT_2ADDR.S
new file mode 100644
index 0000000..3ea64bd
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_USHR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"preinstr":"and     r1, r1, #31", "instr":"mov     r0, r0, lsr r1"}
diff --git a/vm/mterp/armv6t2_taint/OP_XOR_INT_2ADDR.S b/vm/mterp/armv6t2_taint/OP_XOR_INT_2ADDR.S
new file mode 100644
index 0000000..bfa3726
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/OP_XOR_INT_2ADDR.S
@@ -0,0 +1,2 @@
+%verify "executed"
+%include "armv6t2_taint/binop2addr.S" {"instr":"eor     r0, r0, r1"}
diff --git a/vm/mterp/armv6t2_taint/bincmp.S b/vm/mterp/armv6t2_taint/bincmp.S
new file mode 100644
index 0000000..f3b81b0
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/bincmp.S
@@ -0,0 +1,31 @@
+%verify "branch taken"
+%verify "branch not taken"
+    /*
+     * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
+     * fragment that specifies the *reverse* comparison to perform, e.g.
+     * for "if-le" you would use "gt".
+     *
+     * For: if-eq, if-ne, if-lt, if-ge, if-gt, if-le
+     */
+    /* if-cmp vA, vB, +CCCC */
+    mov     r1, rINST, lsr #12          @ r1<- B
+    ubfx    r0, rINST, #8, #4           @ r0<- A
+    GET_VREG(r3, r1)                    @ r3<- vB
+    GET_VREG(r2, r0)                    @ r2<- vA
+    mov     r9, #4                      @ r0<- BYTE branch dist for not-taken
+    cmp     r2, r3                      @ compare (vA, vB)
+    b${revcmp}  1f                      @ branch to 1 if comparison failed
+    FETCH_S(r9, 1)                      @ r9<- branch offset, in code units
+    movs    r9, r9, asl #1              @ convert to bytes, check sign
+    bmi     common_backwardBranch       @ yes, do periodic checks
+1:
+#if defined(WITH_JIT)
+    GET_JIT_PROF_TABLE(r0)
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    b        common_testUpdateProfile
+#else
+    FETCH_ADVANCE_INST_RB(r9)           @ update rPC, load rINST
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+#endif
+
diff --git a/vm/mterp/armv6t2_taint/binop2addr.S b/vm/mterp/armv6t2_taint/binop2addr.S
new file mode 100644
index 0000000..7df9ea5
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/binop2addr.S
@@ -0,0 +1,44 @@
+%default {"preinstr":"", "result":"r0", "chkzero":"0"}
+    /*
+     * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
+     * that specifies an instruction that performs "result = r0 op r1".
+     * This could be an ARM instruction or a function call.  (If the result
+     * comes back in a register other than r0, you can override "result".)
+     *
+     * If "chkzero" is set to 1, we perform a divide-by-zero check on
+     * vCC (r1).  Useful for integer division and modulus.
+     *
+     * For: add-int/2addr, sub-int/2addr, mul-int/2addr, div-int/2addr,
+     *      rem-int/2addr, and-int/2addr, or-int/2addr, xor-int/2addr,
+     *      shl-int/2addr, shr-int/2addr, ushr-int/2addr, add-float/2addr,
+     *      sub-float/2addr, mul-float/2addr, div-float/2addr, rem-float/2addr
+     */
+    /* binop/2addr vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    ubfx    r9, rINST, #8, #4           @ r9<- A
+    GET_VREG(r1, r3)                    @ r1<- vB
+    GET_VREG(r0, r9)                    @ r0<- vA
+    .if $chkzero
+    cmp     r1, #0                      @ is second operand zero?
+    beq     common_errDivideByZero
+    .endif
+
+	bl		.L${opcode}_taint_prop
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+
+    $preinstr                           @ optional op; may set condition codes
+    $instr                              @ $result<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG($result, r9)               @ vAA<- $result
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-13 instructions */
+
+%break
+
+.L${opcode}_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
diff --git a/vm/mterp/armv6t2_taint/unop.S b/vm/mterp/armv6t2_taint/unop.S
new file mode 100644
index 0000000..eeae4a8
--- /dev/null
+++ b/vm/mterp/armv6t2_taint/unop.S
@@ -0,0 +1,25 @@
+%default {"preinstr":""}
+    /*
+     * Generic 32-bit unary operation.  Provide an "instr" line that
+     * specifies an instruction that performs "result = op r0".
+     * This could be an ARM instruction or a function call.
+     *
+     * for: neg-int, not-int, neg-float, int-to-float, float-to-int,
+     *      int-to-byte, int-to-char, int-to-short
+     */
+    /* unop vA, vB */
+    mov     r3, rINST, lsr #12          @ r3<- B
+    ubfx    r9, rINST, #8, #4           @ r9<- A
+    GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
+    $preinstr                           @ optional op; may set condition codes
+    FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
+    $instr                              @ r0<- op, r0-r3 changed
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    SET_VREG(r0, r9)                    @ vAA<- r0
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 8-9 instructions */
diff --git a/vm/mterp/c/OP_APUT_OBJECT.c b/vm/mterp/c/OP_APUT_OBJECT.c
index cc87f5d..616ebef 100644
--- a/vm/mterp/c/OP_APUT_OBJECT.c
+++ b/vm/mterp/c/OP_APUT_OBJECT.c
@@ -34,6 +34,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));
         ((u4*) arrayObj->contents)[GET_REGISTER(vsrc2)] =
             GET_REGISTER(vdst);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_ARRAY_LENGTH.c b/vm/mterp/c/OP_ARRAY_LENGTH.c
index 0d5a933..06f05bb 100644
--- a/vm/mterp/c/OP_ARRAY_LENGTH.c
+++ b/vm/mterp/c/OP_ARRAY_LENGTH.c
@@ -10,6 +10,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_CONST.c b/vm/mterp/c/OP_CONST.c
index e281a51..af7904e 100644
--- a/vm/mterp/c/OP_CONST.c
+++ b/vm/mterp/c/OP_CONST.c
@@ -7,6 +7,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_16.c b/vm/mterp/c/OP_CONST_16.c
index f58f50c..a8c85c2 100644
--- a/vm/mterp/c/OP_CONST_16.c
+++ b/vm/mterp/c/OP_CONST_16.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_4.c b/vm/mterp/c/OP_CONST_4.c
index 800ef9a..a5c2630 100644
--- a/vm/mterp/c/OP_CONST_4.c
+++ b/vm/mterp/c/OP_CONST_4.c
@@ -6,6 +6,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_CLASS.c b/vm/mterp/c/OP_CONST_CLASS.c
index 9c60a27..180afcf 100644
--- a/vm/mterp/c/OP_CONST_CLASS.c
+++ b/vm/mterp/c/OP_CONST_CLASS.c
@@ -13,6 +13,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_HIGH16.c b/vm/mterp/c/OP_CONST_HIGH16.c
index 26b22f4..a3e530a 100644
--- a/vm/mterp/c/OP_CONST_HIGH16.c
+++ b/vm/mterp/c/OP_CONST_HIGH16.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_STRING.c b/vm/mterp/c/OP_CONST_STRING.c
index 748119a..1f5d905 100644
--- a/vm/mterp/c/OP_CONST_STRING.c
+++ b/vm/mterp/c/OP_CONST_STRING.c
@@ -13,6 +13,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_STRING_JUMBO.c b/vm/mterp/c/OP_CONST_STRING_JUMBO.c
index 435b34c..ac4f87a 100644
--- a/vm/mterp/c/OP_CONST_STRING_JUMBO.c
+++ b/vm/mterp/c/OP_CONST_STRING_JUMBO.c
@@ -15,6 +15,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_WIDE.c b/vm/mterp/c/OP_CONST_WIDE.c
index ccb3955..ab0215b 100644
--- a/vm/mterp/c/OP_CONST_WIDE.c
+++ b/vm/mterp/c/OP_CONST_WIDE.c
@@ -9,6 +9,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_WIDE_16.c b/vm/mterp/c/OP_CONST_WIDE_16.c
index da69f37..ca5efbf 100644
--- a/vm/mterp/c/OP_CONST_WIDE_16.c
+++ b/vm/mterp/c/OP_CONST_WIDE_16.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_WIDE_32.c b/vm/mterp/c/OP_CONST_WIDE_32.c
index ad4acbb..5b27752 100644
--- a/vm/mterp/c/OP_CONST_WIDE_32.c
+++ b/vm/mterp/c/OP_CONST_WIDE_32.c
@@ -7,6 +7,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
diff --git a/vm/mterp/c/OP_CONST_WIDE_HIGH16.c b/vm/mterp/c/OP_CONST_WIDE_HIGH16.c
index bcc0664..fcab504 100644
--- a/vm/mterp/c/OP_CONST_WIDE_HIGH16.c
+++ b/vm/mterp/c/OP_CONST_WIDE_HIGH16.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_INSTANCE_OF.c b/vm/mterp/c/OP_INSTANCE_OF.c
index 8b8f9d3..ebf2b7b 100644
--- a/vm/mterp/c/OP_INSTANCE_OF.c
+++ b/vm/mterp/c/OP_INSTANCE_OF.c
@@ -24,6 +24,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
diff --git a/vm/mterp/c/OP_MOVE.c b/vm/mterp/c/OP_MOVE.c
index 6666199..8d93d43 100644
--- a/vm/mterp/c/OP_MOVE.c
+++ b/vm/mterp/c/OP_MOVE.c
@@ -5,5 +5,8 @@ HANDLE_OPCODE($opcode /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_16.c b/vm/mterp/c/OP_MOVE_16.c
index 53af5d5..97fc0e9 100644
--- a/vm/mterp/c/OP_MOVE_16.c
+++ b/vm/mterp/c/OP_MOVE_16.c
@@ -5,5 +5,8 @@ HANDLE_OPCODE($opcode /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_EXCEPTION.c b/vm/mterp/c/OP_MOVE_EXCEPTION.c
index 86587ca..776f618 100644
--- a/vm/mterp/c/OP_MOVE_EXCEPTION.c
+++ b/vm/mterp/c/OP_MOVE_EXCEPTION.c
@@ -3,6 +3,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_FROM16.c b/vm/mterp/c/OP_MOVE_FROM16.c
index 59fc285..296f865 100644
--- a/vm/mterp/c/OP_MOVE_FROM16.c
+++ b/vm/mterp/c/OP_MOVE_FROM16.c
@@ -5,5 +5,8 @@ HANDLE_OPCODE($opcode /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_RESULT.c b/vm/mterp/c/OP_MOVE_RESULT.c
index ddf535b..9d49287 100644
--- a/vm/mterp/c/OP_MOVE_RESULT.c
+++ b/vm/mterp/c/OP_MOVE_RESULT.c
@@ -4,5 +4,8 @@ HANDLE_OPCODE($opcode /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_RESULT_WIDE.c b/vm/mterp/c/OP_MOVE_RESULT_WIDE.c
index f6ec8d9..0f488d4 100644
--- a/vm/mterp/c/OP_MOVE_RESULT_WIDE.c
+++ b/vm/mterp/c/OP_MOVE_RESULT_WIDE.c
@@ -2,5 +2,8 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_WIDE.c b/vm/mterp/c/OP_MOVE_WIDE.c
index 9ee323d..ace1812 100644
--- a/vm/mterp/c/OP_MOVE_WIDE.c
+++ b/vm/mterp/c/OP_MOVE_WIDE.c
@@ -6,5 +6,8 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_WIDE_16.c b/vm/mterp/c/OP_MOVE_WIDE_16.c
index e3d0e16..361de26 100644
--- a/vm/mterp/c/OP_MOVE_WIDE_16.c
+++ b/vm/mterp/c/OP_MOVE_WIDE_16.c
@@ -4,5 +4,8 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
diff --git a/vm/mterp/c/OP_MOVE_WIDE_FROM16.c b/vm/mterp/c/OP_MOVE_WIDE_FROM16.c
index cdbaa2e..a7190fc 100644
--- a/vm/mterp/c/OP_MOVE_WIDE_FROM16.c
+++ b/vm/mterp/c/OP_MOVE_WIDE_FROM16.c
@@ -4,5 +4,8 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_NEW_ARRAY.c b/vm/mterp/c/OP_NEW_ARRAY.c
index 22af516..eaa0fc3 100644
--- a/vm/mterp/c/OP_NEW_ARRAY.c
+++ b/vm/mterp/c/OP_NEW_ARRAY.c
@@ -30,6 +30,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_NEW_INSTANCE.c b/vm/mterp/c/OP_NEW_INSTANCE.c
index ce04286..9e506ba 100644
--- a/vm/mterp/c/OP_NEW_INSTANCE.c
+++ b/vm/mterp/c/OP_NEW_INSTANCE.c
@@ -30,6 +30,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_REM_DOUBLE.c b/vm/mterp/c/OP_REM_DOUBLE.c
index 343e25e..62d5350 100644
--- a/vm/mterp/c/OP_REM_DOUBLE.c
+++ b/vm/mterp/c/OP_REM_DOUBLE.c
@@ -8,6 +8,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_REM_DOUBLE_2ADDR.c b/vm/mterp/c/OP_REM_DOUBLE_2ADDR.c
index 392eacf..2ca5f1c 100644
--- a/vm/mterp/c/OP_REM_DOUBLE_2ADDR.c
+++ b/vm/mterp/c/OP_REM_DOUBLE_2ADDR.c
@@ -4,5 +4,9 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_REM_FLOAT.c b/vm/mterp/c/OP_REM_FLOAT.c
index 9604b30..7d13bdc 100644
--- a/vm/mterp/c/OP_REM_FLOAT.c
+++ b/vm/mterp/c/OP_REM_FLOAT.c
@@ -8,6 +8,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_REM_FLOAT_2ADDR.c b/vm/mterp/c/OP_REM_FLOAT_2ADDR.c
index 87bb31e..630be69 100644
--- a/vm/mterp/c/OP_REM_FLOAT_2ADDR.c
+++ b/vm/mterp/c/OP_REM_FLOAT_2ADDR.c
@@ -4,5 +4,9 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
diff --git a/vm/mterp/c/OP_RETURN.c b/vm/mterp/c/OP_RETURN.c
index 89d3b3b..dbad4c1 100644
--- a/vm/mterp/c/OP_RETURN.c
+++ b/vm/mterp/c/OP_RETURN.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE($opcode /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
diff --git a/vm/mterp/c/OP_RETURN_VOID.c b/vm/mterp/c/OP_RETURN_VOID.c
index 7431f60..4323fa1 100644
--- a/vm/mterp/c/OP_RETURN_VOID.c
+++ b/vm/mterp/c/OP_RETURN_VOID.c
@@ -3,5 +3,8 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
diff --git a/vm/mterp/c/OP_RETURN_WIDE.c b/vm/mterp/c/OP_RETURN_WIDE.c
index a27bfd4..acc53a1 100644
--- a/vm/mterp/c/OP_RETURN_WIDE.c
+++ b/vm/mterp/c/OP_RETURN_WIDE.c
@@ -2,5 +2,8 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
diff --git a/vm/mterp/c/OP_RSUB_INT.c b/vm/mterp/c/OP_RSUB_INT.c
index 336ca55..3cf5e9d 100644
--- a/vm/mterp/c/OP_RSUB_INT.c
+++ b/vm/mterp/c/OP_RSUB_INT.c
@@ -5,6 +5,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/OP_RSUB_INT_LIT8.c b/vm/mterp/c/OP_RSUB_INT_LIT8.c
index 742854b..25d77a5 100644
--- a/vm/mterp/c/OP_RSUB_INT_LIT8.c
+++ b/vm/mterp/c/OP_RSUB_INT_LIT8.c
@@ -7,6 +7,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/gotoTargets.c b/vm/mterp/c/gotoTargets.c
index 5b93583..403b568 100644
--- a/vm/mterp/c/gotoTargets.c
+++ b/vm/mterp/c/gotoTargets.c
@@ -96,6 +96,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -730,6 +733,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -740,8 +746,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -760,9 +789,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -777,6 +853,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -798,13 +875,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
@@ -826,8 +913,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -891,6 +985,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
             if (gDvm.debuggerActive) {
diff --git a/vm/mterp/c/header.c b/vm/mterp/c/header.c
index 174c226..1063ca8 100644
--- a/vm/mterp/c/header.c
+++ b/vm/mterp/c/header.c
@@ -156,6 +156,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -175,6 +200,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -192,6 +231,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -211,6 +264,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -228,6 +295,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -236,6 +317,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -279,6 +409,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
diff --git a/vm/mterp/c/opcommon.c b/vm/mterp/c/opcommon.c
index 28d03c9..c5c4d93 100644
--- a/vm/mterp/c/opcommon.c
+++ b/vm/mterp/c/opcommon.c
@@ -31,6 +31,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -56,6 +60,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -65,6 +73,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -91,6 +102,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -132,6 +146,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -167,6 +184,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -181,6 +202,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -214,6 +239,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -248,6 +276,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -263,6 +294,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -294,6 +328,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -303,6 +341,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -339,6 +381,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -353,6 +399,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -386,6 +436,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -395,6 +449,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -408,6 +466,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -422,6 +484,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -432,6 +498,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -441,6 +511,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -466,6 +540,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -492,6 +570,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -536,6 +619,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -554,6 +642,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -581,6 +676,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -599,6 +698,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -620,6 +725,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -641,6 +749,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
diff --git a/vm/mterp/common/asm-constants.h b/vm/mterp/common/asm-constants.h
index a69247e..232984a 100644
--- a/vm/mterp/common/asm-constants.h
+++ b/vm/mterp/common/asm-constants.h
@@ -91,6 +91,55 @@ MTERP_SIZEOF(sizeofGlobal_activeProfilers, gDvm.activeProfilers, 4)
 MTERP_OFFSET(offGlue_pc,                MterpGlue, pc, 0)
 MTERP_OFFSET(offGlue_fp,                MterpGlue, fp, 4)
 MTERP_OFFSET(offGlue_retval,            MterpGlue, retval, 8)
+/*-----------------------------------------------------------------*/
+#ifdef WITH_TAINT_TRACKING
+/* Adjustements required for InterpState.rtaint */
+MTERP_OFFSET(offGlue_rtaint,		MterpGlue, rtaint, 16)
+MTERP_OFFSET(offGlue_method,            MterpGlue, method, 20)
+MTERP_OFFSET(offGlue_methodClassDex,    MterpGlue, methodClassDex, 24)
+MTERP_OFFSET(offGlue_self,              MterpGlue, self, 28)
+MTERP_OFFSET(offGlue_bailPtr,           MterpGlue, bailPtr, 32)
+MTERP_OFFSET(offGlue_interpStackEnd,    MterpGlue, interpStackEnd, 36)
+MTERP_OFFSET(offGlue_pSelfSuspendCount, MterpGlue, pSelfSuspendCount, 40)
+#if defined(WITH_DEBUGGER) && defined(WITH_PROFILER)
+MTERP_OFFSET(offGlue_pDebuggerActive,   MterpGlue, pDebuggerActive, 44)
+MTERP_OFFSET(offGlue_pActiveProfilers,  MterpGlue, pActiveProfilers, 48)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 52)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 60)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 64)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 68)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 72)
+#endif
+#elif defined(WITH_DEBUGGER)
+MTERP_OFFSET(offGlue_pDebuggerActive,   MterpGlue, pDebuggerActive, 44)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 48)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 56)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 60)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 64)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 68)
+#endif
+#elif defined(WITH_PROFILER)
+MTERP_OFFSET(offGlue_pActiveProfilers,  MterpGlue, pActiveProfilers, 44)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 48)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 56)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 60)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 64)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 68)
+#endif
+#else
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 44)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 52)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 56)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 60)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 64)
+#endif
+#endif
+/*-----------------------------------------------------------------*/
+#else /* ndef WITH_TAINT_TRACKING */
 MTERP_OFFSET(offGlue_method,            MterpGlue, method, 16)
 MTERP_OFFSET(offGlue_methodClassDex,    MterpGlue, methodClassDex, 20)
 MTERP_OFFSET(offGlue_self,              MterpGlue, self, 24)
@@ -134,6 +183,8 @@ MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 56)
 MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 60)
 #endif
 #endif
+#endif /* ndef WITH_TAINT_TRACKING */
+/*-----------------------------------------------------------------*/
 /* make sure all JValue union members are stored at the same offset */
 MTERP_OFFSET(offGlue_retval_z,          MterpGlue, retval.z, 8)
 MTERP_OFFSET(offGlue_retval_i,          MterpGlue, retval.i, 8)
@@ -177,10 +228,20 @@ MTERP_OFFSET(offInstField_byteOffset,   InstField, byteOffset, 16)
 #endif
 
 /* StaticField fields */
+#ifdef WITH_TAINT_TRACKING
 #ifdef PROFILE_FIELD_ACCESS
 MTERP_OFFSET(offStaticField_value,      StaticField, value, 24)
+MTERP_OFFSET(offStaticField_taint,		StaticField, taint, 32)
 #else
 MTERP_OFFSET(offStaticField_value,      StaticField, value, 16)
+MTERP_OFFSET(offStaticField_taint,		StaticField, taint, 24)
+#endif
+#else
+#ifdef PROFILE_FIELD_ACCESS
+MTERP_OFFSET(offStaticField_value,      StaticField, value, 24)
+#else
+MTERP_OFFSET(offStaticField_value,      StaticField, value, 16)
+#endif
 #endif
 
 /* Method fields */
@@ -213,11 +274,28 @@ MTERP_OFFSET(offObject_clazz,           Object, clazz, 0)
 
 /* ArrayObject fields */
 MTERP_OFFSET(offArrayObject_length,     ArrayObject, length, 8)
+#ifdef WITH_TAINT_TRACKING
+MTERP_OFFSET(offArrayObject_taint,	ArrayObject, taint, 12)
+#endif
+
+#ifdef WITH_TAINT_TRACKING
+/*-----------------------------------------------------------------*/
+/* The extra 4 bytes for the taint tag makes these the same */
+#ifdef MTERP_NO_UNALIGN_64
+MTERP_OFFSET(offArrayObject_contents,   ArrayObject, contents, 16)
+#else
+MTERP_OFFSET(offArrayObject_contents,   ArrayObject, contents, 16)
+#endif
+/*-----------------------------------------------------------------*/
+#else /* ndef WITH_TAINT_TRACKING */
+/*-----------------------------------------------------------------*/
 #ifdef MTERP_NO_UNALIGN_64
 MTERP_OFFSET(offArrayObject_contents,   ArrayObject, contents, 16)
 #else
 MTERP_OFFSET(offArrayObject_contents,   ArrayObject, contents, 12)
 #endif
+/*-----------------------------------------------------------------*/
+#endif /* WITH_TAINT_TRACKING */
 
 /* ClassObject fields */
 MTERP_OFFSET(offClassObject_descriptor, ClassObject, descriptor, 24)
diff --git a/vm/mterp/config-armv7-a b/vm/mterp/config-armv7-a
index 9193632..483e6ad 100644
--- a/vm/mterp/config-armv7-a
+++ b/vm/mterp/config-armv7-a
@@ -28,7 +28,7 @@ asm-stub armv5te/stub.S
 
 # file header and basic definitions
 import c/header.c
-import armv5te/header.S
+import armv5te_taint/header.S
 
 # C pre-processor defines for stub C instructions
 import cstubs/stubdefs.c
@@ -40,128 +40,116 @@ import armv5te/platform.S
 import c/opcommon.c
 
 # arch-specific entry point to interpreter
-import armv5te/entry.S
+import armv5te_taint/entry.S
 
 # opcode list; argument to op-start is default directory
-op-start armv5te
-    # handlers that take advantage of >= ARMv6T2 instructions
-    op OP_ADD_DOUBLE_2ADDR armv6t2
-    op OP_ADD_FLOAT_2ADDR armv6t2
-    op OP_ADD_INT_2ADDR armv6t2
-    op OP_ADD_INT_LIT16 armv6t2
-    op OP_ADD_LONG_2ADDR armv6t2
-    op OP_AND_INT_2ADDR armv6t2
-    op OP_AND_INT_LIT16 armv6t2
-    op OP_AND_LONG_2ADDR armv6t2
-    op OP_ARRAY_LENGTH armv6t2
-    op OP_CONST_4 armv6t2
-    op OP_DIV_DOUBLE_2ADDR armv6t2
-    op OP_DIV_FLOAT_2ADDR armv6t2
-    op OP_DIV_INT_2ADDR armv6t2
-    op OP_DIV_INT_LIT16 armv6t2
-    op OP_DIV_LONG_2ADDR armv6t2
-    op OP_DOUBLE_TO_FLOAT armv6t2
-    op OP_DOUBLE_TO_INT armv6t2
-    op OP_DOUBLE_TO_LONG armv6t2
-    op OP_FLOAT_TO_DOUBLE armv6t2
-    op OP_FLOAT_TO_INT armv6t2
-    op OP_FLOAT_TO_LONG armv6t2
-    op OP_IF_EQ armv6t2
-    op OP_IF_GE armv6t2
-    op OP_IF_GT armv6t2
-    op OP_IF_LE armv6t2
-    op OP_IF_LT armv6t2
-    op OP_IF_NE armv6t2
-    op OP_IGET armv6t2
-    op OP_IGET_QUICK armv6t2
-    op OP_IGET_WIDE armv6t2
-    op OP_IGET_WIDE_QUICK armv6t2
-    op OP_INT_TO_BYTE armv6t2
-    op OP_INT_TO_CHAR armv6t2
-    op OP_INT_TO_DOUBLE armv6t2
-    op OP_INT_TO_FLOAT armv6t2
-    op OP_INT_TO_LONG armv6t2
-    op OP_INT_TO_SHORT armv6t2
-    op OP_IPUT armv6t2
-    op OP_IPUT_QUICK armv6t2
-    op OP_IPUT_WIDE armv6t2
-    op OP_IPUT_WIDE_QUICK armv6t2
-    op OP_LONG_TO_DOUBLE armv6t2
-    op OP_LONG_TO_FLOAT armv6t2
-    op OP_MOVE armv6t2
-    op OP_MOVE_WIDE armv6t2
-    op OP_MUL_DOUBLE_2ADDR armv6t2
-    op OP_MUL_FLOAT_2ADDR armv6t2
-    op OP_MUL_INT_2ADDR armv6t2
-    op OP_MUL_INT_LIT16 armv6t2
-    op OP_MUL_LONG_2ADDR armv6t2
-    op OP_NEG_DOUBLE armv6t2
-    op OP_NEG_FLOAT armv6t2
-    op OP_NEG_INT armv6t2
-    op OP_NEG_LONG armv6t2
-    op OP_NOT_INT armv6t2
-    op OP_NOT_LONG armv6t2
-    op OP_OR_INT_2ADDR armv6t2
-    op OP_OR_INT_LIT16 armv6t2
-    op OP_OR_LONG_2ADDR armv6t2
-    op OP_REM_DOUBLE_2ADDR armv6t2
-    op OP_REM_FLOAT_2ADDR armv6t2
-    op OP_REM_INT_2ADDR armv6t2
-    op OP_REM_INT_LIT16 armv6t2
-    op OP_REM_LONG_2ADDR armv6t2
-    op OP_RSUB_INT armv6t2
-    op OP_SHL_INT_2ADDR armv6t2
-    op OP_SHL_LONG_2ADDR armv6t2
-    op OP_SHR_INT_2ADDR armv6t2
-    op OP_SHR_LONG_2ADDR armv6t2
-    op OP_SUB_DOUBLE_2ADDR armv6t2
-    op OP_SUB_FLOAT_2ADDR armv6t2
-    op OP_SUB_INT_2ADDR armv6t2
-    op OP_SUB_LONG_2ADDR armv6t2
-    op OP_USHR_INT_2ADDR armv6t2
-    op OP_USHR_LONG_2ADDR armv6t2
-    op OP_XOR_INT_2ADDR armv6t2
-    op OP_XOR_INT_LIT16 armv6t2
-    op OP_XOR_LONG_2ADDR armv6t2
-
-    # floating point handlers that use VFP
-    # these override the handlers specified earlier
-    op OP_ADD_DOUBLE arm-vfp
-    op OP_ADD_DOUBLE_2ADDR arm-vfp
-    op OP_ADD_FLOAT arm-vfp
-    op OP_ADD_FLOAT_2ADDR arm-vfp
-    op OP_CMPG_DOUBLE arm-vfp
-    op OP_CMPG_FLOAT arm-vfp
-    op OP_CMPL_DOUBLE arm-vfp
-    op OP_CMPL_FLOAT arm-vfp
-    op OP_DIV_DOUBLE arm-vfp
-    op OP_DIV_DOUBLE_2ADDR arm-vfp
-    op OP_DIV_FLOAT arm-vfp
-    op OP_DIV_FLOAT_2ADDR arm-vfp
-    op OP_DOUBLE_TO_FLOAT arm-vfp
-    op OP_DOUBLE_TO_INT arm-vfp
-    op OP_FLOAT_TO_DOUBLE arm-vfp
-    op OP_FLOAT_TO_INT arm-vfp
-    op OP_INT_TO_DOUBLE arm-vfp
-    op OP_INT_TO_FLOAT arm-vfp
-    op OP_MUL_DOUBLE arm-vfp
-    op OP_MUL_DOUBLE_2ADDR arm-vfp
-    op OP_MUL_FLOAT arm-vfp
-    op OP_MUL_FLOAT_2ADDR arm-vfp
-    op OP_SUB_DOUBLE arm-vfp
-    op OP_SUB_DOUBLE_2ADDR arm-vfp
-    op OP_SUB_FLOAT arm-vfp
-    op OP_SUB_FLOAT_2ADDR arm-vfp
+op-start armv5te_taint
+	# bincmp.S (unmodified)
+	op OP_IF_EQ armv6t2_taint
+	op OP_IF_GE armv6t2_taint
+	op OP_IF_GT armv6t2_taint
+	op OP_IF_LE armv6t2_taint
+	op OP_IF_LT armv6t2_taint
+	op OP_IF_NE armv6t2_taint
+    
+	# binop2addr.S
+	op OP_ADD_FLOAT_2ADDR armv6t2_taint    
+	op OP_ADD_INT_2ADDR armv6t2_taint
+	op OP_AND_INT_2ADDR armv6t2_taint
+	op OP_DIV_FLOAT_2ADDR armv6t2_taint
+	op OP_DIV_INT_2ADDR armv6t2_taint
+	op OP_MUL_FLOAT_2ADDR armv6t2_taint
+	op OP_MUL_INT_2ADDR armv6t2_taint
+	op OP_OR_INT_2ADDR armv6t2_taint
+	op OP_REM_FLOAT_2ADDR armv6t2_taint
+	op OP_REM_INT_2ADDR armv6t2_taint
+	op OP_SHL_INT_2ADDR armv6t2_taint
+	op OP_SHR_INT_2ADDR armv6t2_taint
+	op OP_SUB_FLOAT_2ADDR armv6t2_taint
+	op OP_SUB_INT_2ADDR armv6t2_taint
+	op OP_USHR_INT_2ADDR armv6t2_taint
+	op OP_XOR_INT_2ADDR armv6t2_taint
+
+	# unop.S
+	op OP_FLOAT_TO_INT armv6t2_taint
+	op OP_INT_TO_BYTE armv6t2_taint
+	op OP_INT_TO_CHAR armv6t2_taint
+	op OP_INT_TO_FLOAT armv6t2_taint
+	op OP_INT_TO_SHORT armv6t2_taint
+	op OP_NEG_FLOAT armv6t2_taint
+	op OP_NEG_INT armv6t2_taint
+	op OP_NOT_INT armv6t2_taint
+
+
+	# arm-vfp_taint
+		
+	# fbinop.S
+	op OP_ADD_FLOAT arm-vfp_taint
+	op OP_DIV_FLOAT arm-vfp_taint
+	op OP_MUL_FLOAT arm-vfp_taint
+	op OP_SUB_FLOAT arm-vfp_taint
+	
+	# funops.S
+	op OP_FLOAT_TO_INT arm-vfp_taint
+	op OP_INT_TO_FLOAT arm-vfp_taint
+	
+	# fbinop2addr.S
+	op OP_ADD_FLOAT_2ADDR arm-vfp_taint
+	op OP_DIV_FLOAT_2ADDR arm-vfp_taint
+	op OP_MUL_FLOAT_2ADDR arm-vfp_taint
+	op OP_SUB_FLOAT_2ADDR arm-vfp_taint
+	
+	# fbinopWide.S
+	op OP_ADD_DOUBLE arm-vfp_taint
+	op OP_DIV_DOUBLE arm-vfp_taint
+	op OP_MUL_DOUBLE arm-vfp_taint
+	op OP_SUB_DOUBLE arm-vfp_taint	
+
+	# fbinopWide2addr.S
+	op OP_ADD_DOUBLE_2ADDR arm-vfp_taint
+	op OP_DIV_DOUBLE_2ADDR arm-vfp_taint
+	op OP_MUL_DOUBLE_2ADDR arm-vfp_taint
+	op OP_SUB_DOUBLE_2ADDR arm-vfp_taint
+	
+	# funopNarrower.S
+	op OP_DOUBLE_TO_INT arm-vfp_taint
+	op OP_DOUBLE_TO_FLOAT arm-vfp_taint
+	
+	# funopWider.S
+	op OP_INT_TO_DOUBLE arm-vfp_taint
+	op OP_FLOAT_TO_DOUBLE arm-vfp_taint	
+
+	# cmp
+	op OP_CMPG_DOUBLE arm-vfp_taint
+	op OP_CMPG_FLOAT arm-vfp_taint
+	op OP_CMPL_DOUBLE arm-vfp_taint
+	op OP_CMPL_FLOAT arm-vfp_taint
+
+	# still using c versions for invoking native code
+	op OP_INVOKE_DIRECT_RANGE c
+	op OP_INVOKE_DIRECT c
+	op OP_INVOKE_INTERFACE_RANGE c
+	op OP_INVOKE_INTERFACE c
+	op OP_INVOKE_STATIC_RANGE c
+	op OP_INVOKE_STATIC c
+	op OP_INVOKE_SUPER_QUICK_RANGE c
+	op OP_INVOKE_SUPER_QUICK c
+	op OP_INVOKE_SUPER_RANGE c
+	op OP_INVOKE_SUPER c
+	op OP_INVOKE_VIRTUAL_QUICK_RANGE c
+	op OP_INVOKE_VIRTUAL_QUICK c
+	op OP_INVOKE_VIRTUAL_RANGE c
+	op OP_INVOKE_VIRTUAL c
 op-end
 
 # "helper" code for C; include if you use any of the C stubs (this generates
 # object code, so it's normally excluded)
-##import c/gotoTargets.c
+import c/gotoTargets.c
 
 # end of defs; include this when cstubs/stubdefs.c is included
 import cstubs/enddefs.c
 
 # common subroutines for asm
-import armv5te/footer.S
+import armv5te_taint/footer.S
 import armv5te/debug.c
 
diff --git a/vm/mterp/config-armv7-a.notaint b/vm/mterp/config-armv7-a.notaint
new file mode 100644
index 0000000..9193632
--- /dev/null
+++ b/vm/mterp/config-armv7-a.notaint
@@ -0,0 +1,167 @@
+# Copyright (C) 2009 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#
+# Configuration for ARMv7-A targets.
+#
+# This target includes Thumb-2 and Thumb2-EE support, as well as VFPLite.
+#
+# The difference in performance between this and ARMv5TE appears to be
+# negligible on a Cortex-A8 CPU, so this is really just an experiment.
+#
+
+handler-size 64
+
+# source for the instruction table stub
+asm-stub armv5te/stub.S
+
+# file header and basic definitions
+import c/header.c
+import armv5te/header.S
+
+# C pre-processor defines for stub C instructions
+import cstubs/stubdefs.c
+
+# highly-platform-specific defs
+import armv5te/platform.S
+
+# common defs for the C helpers; include this before the instruction handlers
+import c/opcommon.c
+
+# arch-specific entry point to interpreter
+import armv5te/entry.S
+
+# opcode list; argument to op-start is default directory
+op-start armv5te
+    # handlers that take advantage of >= ARMv6T2 instructions
+    op OP_ADD_DOUBLE_2ADDR armv6t2
+    op OP_ADD_FLOAT_2ADDR armv6t2
+    op OP_ADD_INT_2ADDR armv6t2
+    op OP_ADD_INT_LIT16 armv6t2
+    op OP_ADD_LONG_2ADDR armv6t2
+    op OP_AND_INT_2ADDR armv6t2
+    op OP_AND_INT_LIT16 armv6t2
+    op OP_AND_LONG_2ADDR armv6t2
+    op OP_ARRAY_LENGTH armv6t2
+    op OP_CONST_4 armv6t2
+    op OP_DIV_DOUBLE_2ADDR armv6t2
+    op OP_DIV_FLOAT_2ADDR armv6t2
+    op OP_DIV_INT_2ADDR armv6t2
+    op OP_DIV_INT_LIT16 armv6t2
+    op OP_DIV_LONG_2ADDR armv6t2
+    op OP_DOUBLE_TO_FLOAT armv6t2
+    op OP_DOUBLE_TO_INT armv6t2
+    op OP_DOUBLE_TO_LONG armv6t2
+    op OP_FLOAT_TO_DOUBLE armv6t2
+    op OP_FLOAT_TO_INT armv6t2
+    op OP_FLOAT_TO_LONG armv6t2
+    op OP_IF_EQ armv6t2
+    op OP_IF_GE armv6t2
+    op OP_IF_GT armv6t2
+    op OP_IF_LE armv6t2
+    op OP_IF_LT armv6t2
+    op OP_IF_NE armv6t2
+    op OP_IGET armv6t2
+    op OP_IGET_QUICK armv6t2
+    op OP_IGET_WIDE armv6t2
+    op OP_IGET_WIDE_QUICK armv6t2
+    op OP_INT_TO_BYTE armv6t2
+    op OP_INT_TO_CHAR armv6t2
+    op OP_INT_TO_DOUBLE armv6t2
+    op OP_INT_TO_FLOAT armv6t2
+    op OP_INT_TO_LONG armv6t2
+    op OP_INT_TO_SHORT armv6t2
+    op OP_IPUT armv6t2
+    op OP_IPUT_QUICK armv6t2
+    op OP_IPUT_WIDE armv6t2
+    op OP_IPUT_WIDE_QUICK armv6t2
+    op OP_LONG_TO_DOUBLE armv6t2
+    op OP_LONG_TO_FLOAT armv6t2
+    op OP_MOVE armv6t2
+    op OP_MOVE_WIDE armv6t2
+    op OP_MUL_DOUBLE_2ADDR armv6t2
+    op OP_MUL_FLOAT_2ADDR armv6t2
+    op OP_MUL_INT_2ADDR armv6t2
+    op OP_MUL_INT_LIT16 armv6t2
+    op OP_MUL_LONG_2ADDR armv6t2
+    op OP_NEG_DOUBLE armv6t2
+    op OP_NEG_FLOAT armv6t2
+    op OP_NEG_INT armv6t2
+    op OP_NEG_LONG armv6t2
+    op OP_NOT_INT armv6t2
+    op OP_NOT_LONG armv6t2
+    op OP_OR_INT_2ADDR armv6t2
+    op OP_OR_INT_LIT16 armv6t2
+    op OP_OR_LONG_2ADDR armv6t2
+    op OP_REM_DOUBLE_2ADDR armv6t2
+    op OP_REM_FLOAT_2ADDR armv6t2
+    op OP_REM_INT_2ADDR armv6t2
+    op OP_REM_INT_LIT16 armv6t2
+    op OP_REM_LONG_2ADDR armv6t2
+    op OP_RSUB_INT armv6t2
+    op OP_SHL_INT_2ADDR armv6t2
+    op OP_SHL_LONG_2ADDR armv6t2
+    op OP_SHR_INT_2ADDR armv6t2
+    op OP_SHR_LONG_2ADDR armv6t2
+    op OP_SUB_DOUBLE_2ADDR armv6t2
+    op OP_SUB_FLOAT_2ADDR armv6t2
+    op OP_SUB_INT_2ADDR armv6t2
+    op OP_SUB_LONG_2ADDR armv6t2
+    op OP_USHR_INT_2ADDR armv6t2
+    op OP_USHR_LONG_2ADDR armv6t2
+    op OP_XOR_INT_2ADDR armv6t2
+    op OP_XOR_INT_LIT16 armv6t2
+    op OP_XOR_LONG_2ADDR armv6t2
+
+    # floating point handlers that use VFP
+    # these override the handlers specified earlier
+    op OP_ADD_DOUBLE arm-vfp
+    op OP_ADD_DOUBLE_2ADDR arm-vfp
+    op OP_ADD_FLOAT arm-vfp
+    op OP_ADD_FLOAT_2ADDR arm-vfp
+    op OP_CMPG_DOUBLE arm-vfp
+    op OP_CMPG_FLOAT arm-vfp
+    op OP_CMPL_DOUBLE arm-vfp
+    op OP_CMPL_FLOAT arm-vfp
+    op OP_DIV_DOUBLE arm-vfp
+    op OP_DIV_DOUBLE_2ADDR arm-vfp
+    op OP_DIV_FLOAT arm-vfp
+    op OP_DIV_FLOAT_2ADDR arm-vfp
+    op OP_DOUBLE_TO_FLOAT arm-vfp
+    op OP_DOUBLE_TO_INT arm-vfp
+    op OP_FLOAT_TO_DOUBLE arm-vfp
+    op OP_FLOAT_TO_INT arm-vfp
+    op OP_INT_TO_DOUBLE arm-vfp
+    op OP_INT_TO_FLOAT arm-vfp
+    op OP_MUL_DOUBLE arm-vfp
+    op OP_MUL_DOUBLE_2ADDR arm-vfp
+    op OP_MUL_FLOAT arm-vfp
+    op OP_MUL_FLOAT_2ADDR arm-vfp
+    op OP_SUB_DOUBLE arm-vfp
+    op OP_SUB_DOUBLE_2ADDR arm-vfp
+    op OP_SUB_FLOAT arm-vfp
+    op OP_SUB_FLOAT_2ADDR arm-vfp
+op-end
+
+# "helper" code for C; include if you use any of the C stubs (this generates
+# object code, so it's normally excluded)
+##import c/gotoTargets.c
+
+# end of defs; include this when cstubs/stubdefs.c is included
+import cstubs/enddefs.c
+
+# common subroutines for asm
+import armv5te/footer.S
+import armv5te/debug.c
+
diff --git a/vm/mterp/cstubs/enddefs.c b/vm/mterp/cstubs/enddefs.c
index cac74bf..003b3fc 100644
--- a/vm/mterp/cstubs/enddefs.c
+++ b/vm/mterp/cstubs/enddefs.c
@@ -7,3 +7,7 @@
 #undef methodClassDex
 #undef self
 #undef debugTrackedRefStart
+
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
diff --git a/vm/mterp/cstubs/stubdefs.c b/vm/mterp/cstubs/stubdefs.c
index 8699f05..26dc858 100644
--- a/vm/mterp/cstubs/stubdefs.c
+++ b/vm/mterp/cstubs/stubdefs.c
@@ -32,6 +32,10 @@
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
diff --git a/vm/mterp/out/InterpAsm-armv7-a.S b/vm/mterp/out/InterpAsm-armv7-a.S
index 8d018c1..1660264 100644
--- a/vm/mterp/out/InterpAsm-armv7-a.S
+++ b/vm/mterp/out/InterpAsm-armv7-a.S
@@ -4,7 +4,7 @@
  * --> DO NOT EDIT <--
  */
 
-/* File: armv5te/header.S */
+/* File: armv5te_taint/header.S */
 /*
  * Copyright (C) 2008 The Android Open Source Project
  *
@@ -181,8 +181,17 @@ unspecified registers or condition codes.
 /*
  * Get/set the 32-bit value from a Dalvik register.
  */
+#ifdef WITH_TAINT_TRACKING
+#define SET_TAINT_FP(_reg)		add		_reg, rFP, #4
+#define SET_TAINT_CLEAR(_reg)	mov		_reg, #0
+#define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #3]
+#define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #3]
+#define GET_VREG_TAINT(_reg, _vreg, _rFP)	ldr	_reg, [_rFP, _vreg, lsl #3]
+#define SET_VREG_TAINT(_reg, _vreg, _rFP)	str _reg, [_rFP, _vreg, lsl #3]
+#else
 #define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #2]
 #define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #2]
+#endif /*WITH_TAINT_TRACKING*/
 
 #if defined(WITH_JIT)
 #define GET_JIT_ENABLED(_reg)       ldr     _reg,[rGLUE,#offGlue_jitEnabled]
@@ -192,8 +201,13 @@ unspecified registers or condition codes.
 /*
  * Convert a virtual register index into an address.
  */
+#ifdef WITH_TAINT_TRACKING
+#define VREG_INDEX_TO_ADDR(_reg, _vreg) \
+        add     _reg, rFP, _vreg, lsl #3
+#else
 #define VREG_INDEX_TO_ADDR(_reg, _vreg) \
         add     _reg, rFP, _vreg, lsl #2
+#endif /*WITH_TAINT_TRACKING*/
 
 /*
  * This is a #include, not a %include, because we want the C pre-processor
@@ -240,7 +254,7 @@ unspecified registers or condition codes.
 .endm
 
 
-/* File: armv5te/entry.S */
+/* File: armv5te_taint/entry.S */
 /*
  * Copyright (C) 2008 The Android Open Source Project
  *
@@ -396,7 +410,7 @@ dvmAsmInstructionStart = .L_OP_NOP
 /* ------------------------------ */
     .balign 64
 .L_OP_NOP: /* 0x00 */
-/* File: armv5te/OP_NOP.S */
+/* File: armv5te_taint/OP_NOP.S */
     FETCH_ADVANCE_INST(1)               @ advance to next instr, load rINST
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     GOTO_OPCODE(ip)                     @ execute it
@@ -415,13 +429,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE: /* 0x01 */
-/* File: armv6t2/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
-    ubfx    r0, rINST, #8, #4           @ r0<- A from 11:8
+    mov     r0, rINST, lsr #8           @ r0<- A from 11:8
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -430,13 +450,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_FROM16: /* 0x02 */
-/* File: armv5te/OP_MOVE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_FROM16.S */
     /* for: move/from16, move-object/from16 */
     /* op vAA, vBBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     mov     r0, rINST, lsr #8           @ r0<- AA
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -445,13 +470,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_16: /* 0x03 */
-/* File: armv5te/OP_MOVE_16.S */
+/* File: armv5te_taint/OP_MOVE_16.S */
     /* for: move/16, move-object/16 */
     /* op vAAAA, vBBBB */
     FETCH(r1, 2)                        @ r1<- BBBB
     FETCH(r0, 1)                        @ r0<- AAAA
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AAAA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -460,59 +490,72 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE: /* 0x04 */
-/* File: armv6t2/OP_MOVE_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_WIDE.S */
     /* move-wide vA, vB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r2, rINST, #8, #4           @ r2<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[B]
+    and     r2, r2, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[A]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[B]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[A]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_FROM16: /* 0x05 */
-/* File: armv5te/OP_MOVE_WIDE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_FROM16.S */
     /* move-wide/from16 vAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 1)                        @ r3<- BBBB
     mov     r2, rINST, lsr #8           @ r2<- AA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_16: /* 0x06 */
-/* File: armv5te/OP_MOVE_WIDE_16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_16.S */
     /* move-wide/16 vAAAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 2)                        @ r3<- BBBB
     FETCH(r2, 1)                        @ r2<- AAAA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AAAA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AAAA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AAAA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AAAA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT: /* 0x07 */
-/* File: armv5te/OP_MOVE_OBJECT.S */
-/* File: armv5te/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
@@ -520,6 +563,11 @@ dalvik_inst:
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
     and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -529,14 +577,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT_FROM16: /* 0x08 */
-/* File: armv5te/OP_MOVE_OBJECT_FROM16.S */
-/* File: armv5te/OP_MOVE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_FROM16.S */
     /* for: move/from16, move-object/from16 */
     /* op vAA, vBBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     mov     r0, rINST, lsr #8           @ r0<- AA
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -546,14 +599,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT_16: /* 0x09 */
-/* File: armv5te/OP_MOVE_OBJECT_16.S */
-/* File: armv5te/OP_MOVE_16.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT_16.S */
+/* File: armv5te_taint/OP_MOVE_16.S */
     /* for: move/16, move-object/16 */
     /* op vAAAA, vBBBB */
     FETCH(r1, 2)                        @ r1<- BBBB
     FETCH(r0, 1)                        @ r0<- AAAA
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AAAA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -563,7 +621,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT: /* 0x0a */
-/* File: armv5te/OP_MOVE_RESULT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT.S */
     /* for: move-result, move-result-object */
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -571,29 +629,43 @@ dalvik_inst:
     ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_WIDE: /* 0x0b */
-/* File: armv5te/OP_MOVE_RESULT_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_WIDE.S */
     /* move-result-wide vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
     ldmia   r3, {r0-r1}                 @ r0/r1<- retval.j
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+	ldr r3, [rGLUE, #offGlue_rtaint]
+	str	r0, [r2, #0]
+	str r3, [r2, #4]
+	str r1, [r2, #8]
+	str r3, [r2, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_OBJECT: /* 0x0c */
-/* File: armv5te/OP_MOVE_RESULT_OBJECT.S */
-/* File: armv5te/OP_MOVE_RESULT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT.S */
     /* for: move-result, move-result-object */
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -601,6 +673,11 @@ dalvik_inst:
     ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -608,7 +685,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_EXCEPTION: /* 0x0d */
-/* File: armv5te/OP_MOVE_EXCEPTION.S */
+/* File: armv5te_taint/OP_MOVE_EXCEPTION.S */
     /* move-exception vAA */
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -616,6 +693,11 @@ dalvik_inst:
     mov     r1, #0                      @ r1<- 0
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     SET_VREG(r3, r2)                    @ fp[AA]<- exception obj
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	SET_TAINT_CLEAR(r9)
+	SET_VREG_TAINT(r9, r2, r3)
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offThread_exception]  @ dvmClearException bypass
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -624,14 +706,16 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_VOID: /* 0x0e */
-/* File: armv5te/OP_RETURN_VOID.S */
+/* File: armv5te_taint/OP_RETURN_VOID.S */
+	SET_TAINT_CLEAR(r1)
+	str		r1, [rGLUE, #offGlue_rtaint]
     b       common_returnFromMethod
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN: /* 0x0f */
-/* File: armv5te/OP_RETURN.S */
+/* File: armv5te_taint/OP_RETURN.S */
     /*
      * Return a 32-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
@@ -641,6 +725,11 @@ dalvik_inst:
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     GET_VREG(r0, r2)                    @ r0<- vAA
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r3, r2, r1)
+	str		r3, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     str     r0, [rGLUE, #offGlue_retval] @ retval.i <- vAA
     b       common_returnFromMethod
 
@@ -648,16 +737,24 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_WIDE: /* 0x10 */
-/* File: armv5te/OP_RETURN_WIDE.S */
+/* File: armv5te_taint/OP_RETURN_WIDE.S */
     /*
      * Return a 64-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
      */
     /* return-wide vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
     add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
-    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r9, [r2, #4]
+	str		r9, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     stmia   r3, {r0-r1}                 @ retval<- r0/r1
     b       common_returnFromMethod
 
@@ -665,8 +762,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_OBJECT: /* 0x11 */
-/* File: armv5te/OP_RETURN_OBJECT.S */
-/* File: armv5te/OP_RETURN.S */
+/* File: armv5te_taint/OP_RETURN_OBJECT.S */
+/* File: armv5te_taint/OP_RETURN.S */
     /*
      * Return a 32-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
@@ -676,6 +773,11 @@ dalvik_inst:
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     GET_VREG(r0, r2)                    @ r0<- vAA
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r3, r2, r1)
+	str		r3, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     str     r0, [rGLUE, #offGlue_retval] @ retval.i <- vAA
     b       common_returnFromMethod
 
@@ -684,12 +786,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_4: /* 0x12 */
-/* File: armv6t2/OP_CONST_4.S */
+/* File: armv5te_taint/OP_CONST_4.S */
     /* const/4 vA, #+B */
     mov     r1, rINST, lsl #16          @ r1<- Bxxx0000
-    ubfx    r0, rINST, #8, #4           @ r0<- A
+    mov     r0, rINST, lsr #8           @ r0<- A+
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mov     r1, r1, asr #28             @ r1<- sssssssB (sign-extended)
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r0, r2)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r1, r0)                    @ fp[A]<- r1
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -698,10 +806,15 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_16: /* 0x13 */
-/* File: armv5te/OP_CONST_16.S */
+/* File: armv5te_taint/OP_CONST_16.S */
     /* const/16 vAA, #+BBBB */
     FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r2)
+    SET_VREG_TAINT(r2, r3, r1)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -711,13 +824,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST: /* 0x14 */
-/* File: armv5te/OP_CONST.S */
+/* File: armv5te_taint/OP_CONST.S */
     /* const vAA, #+BBBBbbbb */
     mov     r3, rINST, lsr #8           @ r3<- AA
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (high)
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -726,11 +844,16 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_HIGH16: /* 0x15 */
-/* File: armv5te/OP_CONST_HIGH16.S */
+/* File: armv5te_taint/OP_CONST_HIGH16.S */
     /* const/high16 vAA, #+BBBB0000 */
     FETCH(r0, 1)                        @ r0<- 0000BBBB (zero-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
     mov     r0, r0, lsl #16             @ r0<- BBBB0000
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -740,39 +863,53 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_16: /* 0x16 */
-/* File: armv5te/OP_CONST_WIDE_16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_16.S */
     /* const-wide/16 vAA, #+BBBB */
     FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    mov     r2, r0, asr #31             @ r1<- ssssssss
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_32: /* 0x17 */
-/* File: armv5te/OP_CONST_WIDE_32.S */
+/* File: armv5te_taint/OP_CONST_WIDE_32.S */
     /* const-wide/32 vAA, #+BBBBbbbb */
     FETCH(r0, 1)                        @ r0<- 0000bbbb (low)
     mov     r3, rINST, lsr #8           @ r3<- AA
     FETCH_S(r2, 2)                      @ r2<- ssssBBBB (high)
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     orr     r0, r0, r2, lsl #16         @ r0<- BBBBbbbb
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r9<- &fp[AA]
+    mov     r2, r0, asr #31             @ r2<- ssssssss
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE: /* 0x18 */
-/* File: armv5te/OP_CONST_WIDE.S */
+/* File: armv5te_taint/OP_CONST_WIDE.S */
     /* const-wide vAA, #+HHHHhhhhBBBBbbbb */
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (low middle)
@@ -780,34 +917,50 @@ dalvik_inst:
     orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb (low word)
     FETCH(r3, 4)                        @ r3<- HHHH (high)
     mov     r9, rINST, lsr #8           @ r9<- AA
-    orr     r1, r2, r3, lsl #16         @ r1<- HHHHhhhh (high word)
+// begin WITH_TAINT_TRACKING
+    orr     r2, r2, r3, lsl #16         @ r2<- HHHHhhhh (high word)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_HIGH16: /* 0x19 */
-/* File: armv5te/OP_CONST_WIDE_HIGH16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_HIGH16.S */
     /* const-wide/high16 vAA, #+BBBB000000000000 */
     FETCH(r1, 1)                        @ r1<- 0000BBBB (zero-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
     mov     r0, #0                      @ r0<- 00000000
-    mov     r1, r1, lsl #16             @ r1<- BBBB0000
+// begin WITH_TAINT_TRACKING
+    mov     r2, r1, lsl #16             @ r1<- BBBB0000
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_STRING: /* 0x1a */
-/* File: armv5te/OP_CONST_STRING.S */
+/* File: armv5te_taint/OP_CONST_STRING.S */
     /* const/string vAA, String@BBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
@@ -816,6 +969,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
     cmp     r0, #0                      @ not yet resolved?
     beq     .LOP_CONST_STRING_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -824,7 +982,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_STRING_JUMBO: /* 0x1b */
-/* File: armv5te/OP_CONST_STRING_JUMBO.S */
+/* File: armv5te_taint/OP_CONST_STRING_JUMBO.S */
     /* const/string vAA, String@BBBBBBBB */
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (high)
@@ -835,6 +993,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
     cmp     r0, #0
     beq     .LOP_CONST_STRING_JUMBO_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -843,7 +1006,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_CLASS: /* 0x1c */
-/* File: armv5te/OP_CONST_CLASS.S */
+/* File: armv5te_taint/OP_CONST_CLASS.S */
     /* const/class vAA, Class@BBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
@@ -852,6 +1015,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResClasses[BBBB]
     cmp     r0, #0                      @ not yet resolved?
     beq     .LOP_CONST_CLASS_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -860,7 +1028,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MONITOR_ENTER: /* 0x1d */
-/* File: armv5te/OP_MONITOR_ENTER.S */
+/* File: armv5te_taint/OP_MONITOR_ENTER.S */
     /*
      * Synchronize on an object.
      */
@@ -886,7 +1054,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MONITOR_EXIT: /* 0x1e */
-/* File: armv5te/OP_MONITOR_EXIT.S */
+/* File: armv5te_taint/OP_MONITOR_EXIT.S */
     /*
      * Unlock an object.
      *
@@ -912,7 +1080,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CHECK_CAST: /* 0x1f */
-/* File: armv5te/OP_CHECK_CAST.S */
+/* File: armv5te_taint/OP_CHECK_CAST.S */
     /*
      * Check to see if a cast from one class to another is allowed.
      */
@@ -939,7 +1107,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INSTANCE_OF: /* 0x20 */
-/* File: armv5te/OP_INSTANCE_OF.S */
+/* File: armv5te_taint/OP_INSTANCE_OF.S */
     /*
      * Check to see if an object reference is an instance of a class.
      *
@@ -968,15 +1136,21 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ARRAY_LENGTH: /* 0x21 */
-/* File: armv6t2/OP_ARRAY_LENGTH.S */
+/* File: armv5te_taint/OP_ARRAY_LENGTH.S */
     /*
      * Return the length of an array.
      */
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    mov     r2, rINST, lsr #8           @ r2<- A+
     GET_VREG(r0, r1)                    @ r0<- vB (object ref)
+    and     r2, r2, #15                 @ r2<- A
     cmp     r0, #0                      @ is object null?
     beq     common_errNullObject        @ yup, fail
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- array length
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -987,7 +1161,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEW_INSTANCE: /* 0x22 */
-/* File: armv5te/OP_NEW_INSTANCE.S */
+/* File: armv5te_taint/OP_NEW_INSTANCE.S */
     /*
      * Create a new instance of a class.
      */
@@ -1011,7 +1185,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEW_ARRAY: /* 0x23 */
-/* File: armv5te/OP_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_NEW_ARRAY.S */
     /*
      * Allocate an array of objects, specified with the array class
      * and a count.
@@ -1036,7 +1210,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILLED_NEW_ARRAY: /* 0x24 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY.S */
     /*
      * Create a new array with elements filled from registers.
      *
@@ -1063,8 +1237,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY_RANGE.S */
-/* File: armv5te/OP_FILLED_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY_RANGE.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY.S */
     /*
      * Create a new array with elements filled from registers.
      *
@@ -1092,7 +1266,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILL_ARRAY_DATA: /* 0x26 */
-/* File: armv5te/OP_FILL_ARRAY_DATA.S */
+/* File: armv5te_taint/OP_FILL_ARRAY_DATA.S */
     /* fill-array-data vAA, +BBBBBBBB */
     FETCH(r0, 1)                        @ r0<- bbbb (lo)
     FETCH(r1, 2)                        @ r1<- BBBB (hi)
@@ -1111,7 +1285,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_THROW: /* 0x27 */
-/* File: armv5te/OP_THROW.S */
+/* File: armv5te_taint/OP_THROW.S */
     /*
      * Throw an exception object in the current thread.
      */
@@ -1129,7 +1303,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO: /* 0x28 */
-/* File: armv5te/OP_GOTO.S */
+/* File: armv5te_taint/OP_GOTO.S */
     /*
      * Unconditional branch, 8-bit offset.
      *
@@ -1157,7 +1331,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO_16: /* 0x29 */
-/* File: armv5te/OP_GOTO_16.S */
+/* File: armv5te_taint/OP_GOTO_16.S */
     /*
      * Unconditional branch, 16-bit offset.
      *
@@ -1185,7 +1359,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO_32: /* 0x2a */
-/* File: armv5te/OP_GOTO_32.S */
+/* File: armv5te_taint/OP_GOTO_32.S */
     /*
      * Unconditional branch, 32-bit offset.
      *
@@ -1220,7 +1394,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_PACKED_SWITCH: /* 0x2b */
-/* File: armv5te/OP_PACKED_SWITCH.S */
+/* File: armv5te_taint/OP_PACKED_SWITCH.S */
     /*
      * Handle a packed-switch or sparse-switch instruction.  In both cases
      * we decode it and hand it off to a helper function.
@@ -1258,8 +1432,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPARSE_SWITCH: /* 0x2c */
-/* File: armv5te/OP_SPARSE_SWITCH.S */
-/* File: armv5te/OP_PACKED_SWITCH.S */
+/* File: armv5te_taint/OP_SPARSE_SWITCH.S */
+/* File: armv5te_taint/OP_PACKED_SWITCH.S */
     /*
      * Handle a packed-switch or sparse-switch instruction.  In both cases
      * we decode it and hand it off to a helper function.
@@ -1298,7 +1472,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPL_FLOAT: /* 0x2d */
-/* File: arm-vfp/OP_CMPL_FLOAT.S */
+/* File: arm-vfp_taint/OP_CMPL_FLOAT.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1337,7 +1511,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPG_FLOAT: /* 0x2e */
-/* File: arm-vfp/OP_CMPG_FLOAT.S */
+/* File: arm-vfp_taint/OP_CMPG_FLOAT.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1376,7 +1550,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPL_DOUBLE: /* 0x2f */
-/* File: arm-vfp/OP_CMPL_DOUBLE.S */
+/* File: arm-vfp_taint/OP_CMPL_DOUBLE.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1400,22 +1574,25 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-    fldd    d1, [r3]                    @ d1<- vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
     fcmped  d0, d1                      @ compare (vBB, vCC)
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     mvn     r0, #0                      @ r0<- -1 (default)
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fmstat                              @ export status flags
-    movgt   r0, #1                      @ (greater than) r1<- 1
-    moveq   r0, #0                      @ (equal) r1<- 0
     b       .LOP_CMPL_DOUBLE_finish          @ argh
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPG_DOUBLE: /* 0x30 */
-/* File: arm-vfp/OP_CMPG_DOUBLE.S */
+/* File: arm-vfp_taint/OP_CMPG_DOUBLE.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1439,22 +1616,25 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-    fldd    d1, [r3]                    @ d1<- vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
     fcmped  d0, d1                      @ compare (vBB, vCC)
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     mov     r0, #1                      @ r0<- 1 (default)
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fmstat                              @ export status flags
-    mvnmi   r0, #0                      @ (less than) r1<- -1
-    moveq   r0, #0                      @ (equal) r1<- 0
     b       .LOP_CMPG_DOUBLE_finish          @ argh
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CMP_LONG: /* 0x31 */
-/* File: armv5te/OP_CMP_LONG.S */
+/* File: armv5te_taint/OP_CMP_LONG.S */
     /*
      * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination
      * register based on the results of the comparison.
@@ -1480,10 +1660,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+	bl		cmp_long_taint_prop
+ // end WITH_TAINT_TRACKING
     cmp     r1, r3                      @ compare (vBB+1, vCC+1)
     blt     .LOP_CMP_LONG_less            @ signed compare on high part
     bgt     .LOP_CMP_LONG_greater
@@ -1495,8 +1674,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_EQ: /* 0x32 */
-/* File: armv6t2/OP_IF_EQ.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_EQ.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1531,8 +1710,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_NE: /* 0x33 */
-/* File: armv6t2/OP_IF_NE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_NE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1567,8 +1746,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LT: /* 0x34 */
-/* File: armv6t2/OP_IF_LT.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_LT.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1603,8 +1782,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GE: /* 0x35 */
-/* File: armv6t2/OP_IF_GE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_GE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1639,8 +1818,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GT: /* 0x36 */
-/* File: armv6t2/OP_IF_GT.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_GT.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1675,8 +1854,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LE: /* 0x37 */
-/* File: armv6t2/OP_IF_LE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_LE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1711,8 +1890,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_EQZ: /* 0x38 */
-/* File: armv5te/OP_IF_EQZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_EQZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1748,8 +1927,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_NEZ: /* 0x39 */
-/* File: armv5te/OP_IF_NEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_NEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1785,8 +1964,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LTZ: /* 0x3a */
-/* File: armv5te/OP_IF_LTZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_LTZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1822,8 +2001,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GEZ: /* 0x3b */
-/* File: armv5te/OP_IF_GEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_GEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1859,8 +2038,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GTZ: /* 0x3c */
-/* File: armv5te/OP_IF_GTZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_GTZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1896,8 +2075,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LEZ: /* 0x3d */
-/* File: armv5te/OP_IF_LEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_LEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1933,8 +2112,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_3E: /* 0x3e */
-/* File: armv5te/OP_UNUSED_3E.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_3E.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1942,8 +2121,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_3F: /* 0x3f */
-/* File: armv5te/OP_UNUSED_3F.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_3F.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1951,8 +2130,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_40: /* 0x40 */
-/* File: armv5te/OP_UNUSED_40.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_40.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1960,8 +2139,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_41: /* 0x41 */
-/* File: armv5te/OP_UNUSED_41.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_41.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1969,8 +2148,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_42: /* 0x42 */
-/* File: armv5te/OP_UNUSED_42.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_42.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1978,8 +2157,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_43: /* 0x43 */
-/* File: armv5te/OP_UNUSED_43.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_43.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -1987,7 +2166,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET: /* 0x44 */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2004,12 +2183,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2018,7 +2203,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_WIDE: /* 0x45 */
-/* File: armv5te/OP_AGET_WIDE.S */
+/* File: armv5te_taint/OP_AGET_WIDE.S */
     /*
      * Array get, 64 bits.  vAA <- vBB[vCC].
      *
@@ -2033,6 +2218,9 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_WIDE_taint_prop		@ r10<- taint
+// end WITH_TAINT_TRACKING
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
@@ -2045,8 +2233,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_OBJECT: /* 0x46 */
-/* File: armv5te/OP_AGET_OBJECT.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_OBJECT.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2063,12 +2251,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_OBJECT_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_OBJECT_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2078,8 +2272,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_BOOLEAN: /* 0x47 */
-/* File: armv5te/OP_AGET_BOOLEAN.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2096,12 +2290,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_BOOLEAN_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_BOOLEAN_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2111,8 +2311,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_BYTE: /* 0x48 */
-/* File: armv5te/OP_AGET_BYTE.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_BYTE.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2129,12 +2329,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_BYTE_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrsb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_BYTE_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrsb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2144,8 +2350,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_CHAR: /* 0x49 */
-/* File: armv5te/OP_AGET_CHAR.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_CHAR.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2162,12 +2368,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_CHAR_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_CHAR_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2177,8 +2389,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_SHORT: /* 0x4a */
-/* File: armv5te/OP_AGET_SHORT.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_SHORT.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2195,12 +2407,18 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_SHORT_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrsh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_SHORT_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrsh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -2210,7 +2428,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT: /* 0x4b */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2231,7 +2449,10 @@ dalvik_inst:
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
@@ -2241,7 +2462,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_WIDE: /* 0x4c */
-/* File: armv5te/OP_APUT_WIDE.S */
+/* File: armv5te_taint/OP_APUT_WIDE.S */
     /*
      * Array put, 64 bits.  vBB[vCC] <- vAA.
      *
@@ -2257,9 +2478,14 @@ dalvik_inst:
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	mov		r10, r0
+// end WITH_TAINT_TRACKING
     add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     bcc     .LOP_APUT_WIDE_finish          @ okay, continue below
     b       common_errArrayIndex        @ index >= length, bail
     @ May want to swap the order of these two branches depending on how the
@@ -2269,7 +2495,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_OBJECT: /* 0x4d */
-/* File: armv5te/OP_APUT_OBJECT.S */
+/* File: armv5te_taint/OP_APUT_OBJECT.S */
     /*
      * Store an object into an array.  vBB[vCC] <- vAA.
      *
@@ -2283,9 +2509,15 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     GET_VREG(r1, r2)                    @ r1<- vBB (array object)
     GET_VREG(r0, r3)                    @ r0<- vCC (requested index)
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_1
+// end WITH_TAINT_TRACKING
     cmp     r1, #0                      @ null array object?
     GET_VREG(r9, r9)                    @ r9<- vAA
     beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_2
+// end WITH_TAINT_TRACKING
     ldr     r3, [r1, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r10, r1, r0, lsl #2         @ r10<- arrayObj + index*width
     cmp     r0, r3                      @ compare unsigned index, length
@@ -2296,8 +2528,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_BOOLEAN: /* 0x4e */
-/* File: armv5te/OP_APUT_BOOLEAN.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2318,7 +2550,10 @@ dalvik_inst:
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_BOOLEAN_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strb  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
@@ -2329,8 +2564,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_BYTE: /* 0x4f */
-/* File: armv5te/OP_APUT_BYTE.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_BYTE.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2351,7 +2586,10 @@ dalvik_inst:
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_BYTE_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strb  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
@@ -2362,8 +2600,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_CHAR: /* 0x50 */
-/* File: armv5te/OP_APUT_CHAR.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_CHAR.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2384,7 +2622,10 @@ dalvik_inst:
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_CHAR_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strh  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
@@ -2395,8 +2636,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_SHORT: /* 0x51 */
-/* File: armv5te/OP_APUT_SHORT.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_SHORT.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2417,7 +2658,10 @@ dalvik_inst:
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_SHORT_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strh  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
@@ -2428,7 +2672,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET: /* 0x52 */
-/* File: armv6t2/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2439,8 +2683,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2454,7 +2699,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE: /* 0x53 */
-/* File: armv6t2/OP_IGET_WIDE.S */
+/* File: armv5te_taint/OP_IGET_WIDE.S */
     /*
      * Wide 32-bit instance field get.
      */
@@ -2463,8 +2708,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_WIDE_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
@@ -2478,8 +2724,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT: /* 0x54 */
-/* File: armv5te/OP_IGET_OBJECT.S */
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET_OBJECT.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2490,8 +2736,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_OBJECT_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_OBJECT_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2506,9 +2753,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_BOOLEAN: /* 0x55 */
-/* File: armv5te/OP_IGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_IGET_BOOLEAN.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrb", "sqnum":"1" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2519,8 +2766,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_BOOLEAN_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_BOOLEAN_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2535,9 +2783,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_BYTE: /* 0x56 */
-/* File: armv5te/OP_IGET_BYTE.S */
+/* File: armv5te_taint/OP_IGET_BYTE.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrsb", "sqnum":"2" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2548,8 +2796,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_BYTE_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_BYTE_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2564,9 +2813,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_CHAR: /* 0x57 */
-/* File: armv5te/OP_IGET_CHAR.S */
+/* File: armv5te_taint/OP_IGET_CHAR.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrh", "sqnum":"3" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2577,8 +2826,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_CHAR_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_CHAR_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2593,9 +2843,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_SHORT: /* 0x58 */
-/* File: armv5te/OP_IGET_SHORT.S */
+/* File: armv5te_taint/OP_IGET_SHORT.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrsh", "sqnum":"4" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2606,8 +2856,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_SHORT_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_SHORT_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2622,7 +2873,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT: /* 0x59 */
-/* File: armv6t2/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2648,7 +2899,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_WIDE: /* 0x5a */
-/* File: armv6t2/OP_IPUT_WIDE.S */
+/* File: armv5te_taint/OP_IPUT_WIDE.S */
     /* iput-wide vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
@@ -2669,8 +2920,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT: /* 0x5b */
-/* File: armv5te/OP_IPUT_OBJECT.S */
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2697,9 +2948,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_BOOLEAN: /* 0x5c */
-/* File: armv5te/OP_IPUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_IPUT_BOOLEAN.S */
 @include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"1" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2726,9 +2977,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_BYTE: /* 0x5d */
-/* File: armv5te/OP_IPUT_BYTE.S */
+/* File: armv5te_taint/OP_IPUT_BYTE.S */
 @include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"2" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2755,9 +3006,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_CHAR: /* 0x5e */
-/* File: armv5te/OP_IPUT_CHAR.S */
+/* File: armv5te_taint/OP_IPUT_CHAR.S */
 @include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"3" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2784,9 +3035,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_SHORT: /* 0x5f */
-/* File: armv5te/OP_IPUT_SHORT.S */
+/* File: armv5te_taint/OP_IPUT_SHORT.S */
 @include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"4" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2813,7 +3064,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET: /* 0x60 */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2829,6 +3080,11 @@ dalvik_inst:
 .LOP_SGET_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2837,7 +3093,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_WIDE: /* 0x61 */
-/* File: armv5te/OP_SGET_WIDE.S */
+/* File: armv5te_taint/OP_SGET_WIDE.S */
     /*
      * 64-bit SGET handler.
      */
@@ -2848,20 +3104,14 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
     cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SGET_WIDE_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_finish:
-    mov     r1, rINST, lsr #8           @ r1<- AA
-    ldrd    r2, [r0, #offStaticField_value] @ r2/r3<- field value (aligned)
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[AA]
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    stmia   r1, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    b		.LOP_SGET_WIDE_finish
+
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_OBJECT: /* 0x62 */
-/* File: armv5te/OP_SGET_OBJECT.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_OBJECT.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2877,6 +3127,11 @@ dalvik_inst:
 .LOP_SGET_OBJECT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2886,8 +3141,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_BOOLEAN: /* 0x63 */
-/* File: armv5te/OP_SGET_BOOLEAN.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2903,6 +3158,11 @@ dalvik_inst:
 .LOP_SGET_BOOLEAN_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2912,8 +3172,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_BYTE: /* 0x64 */
-/* File: armv5te/OP_SGET_BYTE.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_BYTE.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2929,6 +3189,11 @@ dalvik_inst:
 .LOP_SGET_BYTE_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2938,8 +3203,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_CHAR: /* 0x65 */
-/* File: armv5te/OP_SGET_CHAR.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_CHAR.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2955,6 +3220,11 @@ dalvik_inst:
 .LOP_SGET_CHAR_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2964,8 +3234,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_SHORT: /* 0x66 */
-/* File: armv5te/OP_SGET_SHORT.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_SHORT.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2981,6 +3251,11 @@ dalvik_inst:
 .LOP_SGET_SHORT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2990,7 +3265,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT: /* 0x67 */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3009,12 +3284,17 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_WIDE: /* 0x68 */
-/* File: armv5te/OP_SPUT_WIDE.S */
+/* File: armv5te_taint/OP_SPUT_WIDE.S */
     /*
      * 64-bit SPUT handler.
      */
@@ -3024,21 +3304,31 @@ dalvik_inst:
     ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
     mov     r9, rINST, lsr #8           @ r9<- AA
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SPUT_WIDE_resolve         @ yes, do resolve
 .LOP_SPUT_WIDE_finish: @ field ptr in r0, AA in r9
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr r1, [r9, #4]
+	ldr r2, [r9, #0]
+	ldr r3, [r9, #8]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strd    r2, [r0, #offStaticField_value] @ field<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+    str		r1, [r0, #offStaticField_taint]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_OBJECT: /* 0x69 */
-/* File: armv5te/OP_SPUT_OBJECT.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_OBJECT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3057,14 +3347,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BOOLEAN: /* 0x6a */
-/* File: armv5te/OP_SPUT_BOOLEAN.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3083,14 +3378,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BYTE: /* 0x6b */
-/* File: armv5te/OP_SPUT_BYTE.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BYTE.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3109,14 +3409,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_CHAR: /* 0x6c */
-/* File: armv5te/OP_SPUT_CHAR.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_CHAR.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3135,14 +3440,19 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_SHORT: /* 0x6d */
-/* File: armv5te/OP_SPUT_SHORT.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_SHORT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
@@ -3161,162 +3471,79 @@ dalvik_inst:
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL: /* 0x6e */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER: /* 0x6f */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_resolve         @ do resolve now
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT: /* 0x70 */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodNoRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC: /* 0x71 */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodNoRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodNoRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE: /* 0x72 */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodNoRange @ jump to common handler 
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_73: /* 0x73 */
-/* File: armv5te/OP_UNUSED_73.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_73.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -3324,166 +3551,68 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_RANGE: /* 0x75 */
-/* File: armv5te/OP_INVOKE_SUPER_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_RANGE_resolve         @ do resolve now
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
-/* File: armv5te/OP_INVOKE_DIRECT_RANGE.S */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_RANGE_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_RANGE_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC_RANGE: /* 0x77 */
-/* File: armv5te/OP_INVOKE_STATIC_RANGE.S */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
-/* File: armv5te/OP_INVOKE_INTERFACE_RANGE.S */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodRange @ jump to common handler 
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_79: /* 0x79 */
-/* File: armv5te/OP_UNUSED_79.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_79.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -3491,8 +3620,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_7A: /* 0x7a */
-/* File: armv5te/OP_UNUSED_7A.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_7A.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -3500,8 +3629,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_INT: /* 0x7b */
-/* File: armv6t2/OP_NEG_INT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NEG_INT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3514,6 +3643,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     rsb     r0, r0, #0                              @ r0<- op, r0-r3 changed
@@ -3526,8 +3660,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NOT_INT: /* 0x7c */
-/* File: armv6t2/OP_NOT_INT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NOT_INT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3540,6 +3674,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mvn     r0, r0                              @ r0<- op, r0-r3 changed
@@ -3552,8 +3691,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_LONG: /* 0x7d */
-/* File: armv6t2/OP_NEG_LONG.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NEG_LONG.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3562,26 +3701,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     rsbs    r0, r0, #0                           @ optional op; may set condition codes
     rsc     r1, r1, #0                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NEG_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NOT_LONG: /* 0x7e */
-/* File: armv6t2/OP_NOT_LONG.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NOT_LONG.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3590,26 +3732,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mvn     r0, r0                           @ optional op; may set condition codes
     mvn     r1, r1                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NOT_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_FLOAT: /* 0x7f */
-/* File: armv6t2/OP_NEG_FLOAT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NEG_FLOAT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3622,6 +3767,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     add     r0, r0, #0x80000000                              @ r0<- op, r0-r3 changed
@@ -3634,8 +3784,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_DOUBLE: /* 0x80 */
-/* File: armv6t2/OP_NEG_DOUBLE.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NEG_DOUBLE.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3644,26 +3794,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     add     r1, r1, #0x80000000                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_NEG_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_LONG: /* 0x81 */
-/* File: armv6t2/OP_INT_TO_LONG.S */
-/* File: armv6t2/unopWider.S */
+/* File: armv5te_taint/OP_INT_TO_LONG.S */
+/* File: armv5te_taint/unopWider.S */
     /*
      * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0", where
@@ -3672,24 +3825,27 @@ dalvik_inst:
      * For: int-to-long, int-to-double, float-to-long, float-to-double
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r0, r3)                    @ r0<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r3, r2)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+// end WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mov     r1, r0, asr #31                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+	b     .LOP_INT_TO_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_FLOAT: /* 0x82 */
-/* File: arm-vfp/OP_INT_TO_FLOAT.S */
-/* File: arm-vfp/funop.S */
+/* File: arm-vfp_taint/OP_INT_TO_FLOAT.S */
+/* File: arm-vfp_taint/funop.S */
     /*
      * Generic 32-bit unary floating-point operation.  Provide an "instr"
      * line that specifies an instruction that performs "s1 = op s0".
@@ -3701,20 +3857,26 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fsitos  s1, s0                              @ s1<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s1, [r9]                    @ vA<- s1
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_DOUBLE: /* 0x83 */
-/* File: arm-vfp/OP_INT_TO_DOUBLE.S */
-/* File: arm-vfp/funopWider.S */
+/* File: arm-vfp_taint/OP_INT_TO_DOUBLE.S */
+/* File: arm-vfp_taint/funopWider.S */
     /*
      * Generic 32bit-to-64bit floating point unary operation.  Provide an
      * "instr" line that specifies an instruction that performs "d0 = op s0".
@@ -3726,21 +3888,30 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fsitod  d0, s0                              @ d0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
-    fstd    d0, [r9]                    @ vA<- d0
+// begin WITH_TAINT_TRACKING
+//    fstd    d0, [r9]                    @ vA<- d0
+	fsts	s0, [r9]
+	fsts	s1, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_INT: /* 0x84 */
-/* File: armv5te/OP_LONG_TO_INT.S */
+/* File: armv5te_taint/OP_LONG_TO_INT.S */
 /* we ignore the high word, making this equivalent to a 32-bit reg move */
-/* File: armv5te/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
@@ -3748,6 +3919,11 @@ dalvik_inst:
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
     and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -3757,8 +3933,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_FLOAT: /* 0x85 */
-/* File: armv6t2/OP_LONG_TO_FLOAT.S */
-/* File: armv6t2/unopNarrower.S */
+/* File: armv5te_taint/OP_LONG_TO_FLOAT.S */
+/* File: armv5te_taint/unopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0/r1", where
@@ -3771,23 +3947,33 @@ dalvik_inst:
      */
     /* unop vA, vB */
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1
+    mov     r9, rINST, lsr #8           @ r9<- A+
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    and     r9, r9, #15
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1
+	ldr		r0, [r3, #0]
+	ldr		r10, [r3, #4]
+	ldr		r1, [r3, #8]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_l2f                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r10, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+    /* 10-11 instructions */
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_DOUBLE: /* 0x86 */
-/* File: armv6t2/OP_LONG_TO_DOUBLE.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_LONG_TO_DOUBLE.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3796,26 +3982,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_l2d                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_LONG_TO_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_INT: /* 0x87 */
-/* File: arm-vfp/OP_FLOAT_TO_INT.S */
-/* File: arm-vfp/funop.S */
+/* File: arm-vfp_taint/OP_FLOAT_TO_INT.S */
+/* File: arm-vfp_taint/funop.S */
     /*
      * Generic 32-bit unary floating-point operation.  Provide an "instr"
      * line that specifies an instruction that performs "s1 = op s0".
@@ -3827,21 +4016,27 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     ftosizs s1, s0                              @ s1<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s1, [r9]                    @ vA<- s1
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_LONG: /* 0x88 */
-/* File: armv6t2/OP_FLOAT_TO_LONG.S */
-@include "armv6t2/unopWider.S" {"instr":"bl      __aeabi_f2lz"}
-/* File: armv6t2/unopWider.S */
+/* File: armv5te_taint/OP_FLOAT_TO_LONG.S */
+@include "armv5te/unopWider.S" {"instr":"bl      __aeabi_f2lz"}
+/* File: armv5te_taint/unopWider.S */
     /*
      * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0", where
@@ -3850,25 +4045,28 @@ dalvik_inst:
      * For: int-to-long, int-to-double, float-to-long, float-to-double
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r0, r3)                    @ r0<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r3, r2)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+// end WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     bl      f2l_doconv                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+	b     .LOP_FLOAT_TO_LONG_finish
 
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_DOUBLE: /* 0x89 */
-/* File: arm-vfp/OP_FLOAT_TO_DOUBLE.S */
-/* File: arm-vfp/funopWider.S */
+/* File: arm-vfp_taint/OP_FLOAT_TO_DOUBLE.S */
+/* File: arm-vfp_taint/funopWider.S */
     /*
      * Generic 32bit-to-64bit floating point unary operation.  Provide an
      * "instr" line that specifies an instruction that performs "d0 = op s0".
@@ -3880,20 +4078,29 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fcvtds  d0, s0                              @ d0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
-    fstd    d0, [r9]                    @ vA<- d0
+// begin WITH_TAINT_TRACKING
+//    fstd    d0, [r9]                    @ vA<- d0
+	fsts	s0, [r9]
+	fsts	s1, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_INT: /* 0x8a */
-/* File: arm-vfp/OP_DOUBLE_TO_INT.S */
-/* File: arm-vfp/funopNarrower.S */
+/* File: arm-vfp_taint/OP_DOUBLE_TO_INT.S */
+/* File: arm-vfp_taint/funopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary floating point operation.  Provide an
      * "instr" line that specifies an instruction that performs "s0 = op d0".
@@ -3904,22 +4111,30 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
-    fldd    d0, [r3]                    @ d0<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r3]                    @ d0<- vB
+	flds	s0, [r3]
+	flds	s1, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     ftosizd  s0, d0                              @ s0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s0, [r9]                    @ vA<- s0
+// begin WITH_TAINT_TRACKING
+    str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_LONG: /* 0x8b */
-/* File: armv6t2/OP_DOUBLE_TO_LONG.S */
-@include "armv6t2/unopWide.S" {"instr":"bl      __aeabi_d2lz"}
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_DOUBLE_TO_LONG.S */
+@include "armv5te/unopWide.S" {"instr":"bl      __aeabi_d2lz"}
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3928,27 +4143,30 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      d2l_doconv                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
-
+	b     .LOP_DOUBLE_TO_LONG_finish
 
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_FLOAT: /* 0x8c */
-/* File: arm-vfp/OP_DOUBLE_TO_FLOAT.S */
-/* File: arm-vfp/funopNarrower.S */
+/* File: arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S */
+/* File: arm-vfp_taint/funopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary floating point operation.  Provide an
      * "instr" line that specifies an instruction that performs "s0 = op d0".
@@ -3959,21 +4177,29 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
-    fldd    d0, [r3]                    @ d0<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r3]                    @ d0<- vB
+	flds	s0, [r3]
+	flds	s1, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fcvtsd  s0, d0                              @ s0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s0, [r9]                    @ vA<- s0
+// begin WITH_TAINT_TRACKING
+    str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_BYTE: /* 0x8d */
-/* File: armv6t2/OP_INT_TO_BYTE.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_BYTE.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3986,6 +4212,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     sxtb    r0, r0                              @ r0<- op, r0-r3 changed
@@ -3998,8 +4229,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_CHAR: /* 0x8e */
-/* File: armv6t2/OP_INT_TO_CHAR.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_CHAR.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -4012,6 +4243,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     uxth    r0, r0                              @ r0<- op, r0-r3 changed
@@ -4024,8 +4260,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_SHORT: /* 0x8f */
-/* File: armv6t2/OP_INT_TO_SHORT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_SHORT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -4038,6 +4274,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     sxth    r0, r0                              @ r0<- op, r0-r3 changed
@@ -4050,8 +4291,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT: /* 0x90 */
-/* File: armv5te/OP_ADD_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_ADD_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4079,6 +4320,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_ADD_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     add     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4092,8 +4336,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_INT: /* 0x91 */
-/* File: armv5te/OP_SUB_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SUB_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4121,6 +4365,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SUB_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     sub     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4134,9 +4381,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT: /* 0x92 */
-/* File: armv5te/OP_MUL_INT.S */
+/* File: armv5te_taint/OP_MUL_INT.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4164,6 +4411,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_MUL_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     mul     r0, r1, r0                              @ r0<- op, r0-r3 changed
@@ -4177,8 +4427,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT: /* 0x93 */
-/* File: armv5te/OP_DIV_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_DIV_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4206,6 +4456,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_DIV_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl     __aeabi_idiv                              @ r0<- op, r0-r3 changed
@@ -4219,9 +4472,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT: /* 0x94 */
-/* File: armv5te/OP_REM_INT.S */
+/* File: armv5te_taint/OP_REM_INT.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4249,6 +4502,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_REM_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_idivmod                              @ r1<- op, r0-r3 changed
@@ -4262,8 +4518,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT: /* 0x95 */
-/* File: armv5te/OP_AND_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_AND_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4291,6 +4547,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AND_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     and     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4304,8 +4563,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT: /* 0x96 */
-/* File: armv5te/OP_OR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_OR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4333,6 +4592,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_OR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     orr     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4346,8 +4608,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT: /* 0x97 */
-/* File: armv5te/OP_XOR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_XOR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4375,6 +4637,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_XOR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     eor     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4388,8 +4653,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT: /* 0x98 */
-/* File: armv5te/OP_SHL_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SHL_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4417,6 +4682,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SHL_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, asl r1                              @ r0<- op, r0-r3 changed
@@ -4430,8 +4698,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT: /* 0x99 */
-/* File: armv5te/OP_SHR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SHR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4459,6 +4727,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SHR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, asr r1                              @ r0<- op, r0-r3 changed
@@ -4472,8 +4743,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT: /* 0x9a */
-/* File: armv5te/OP_USHR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_USHR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4501,6 +4772,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_USHR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, lsr r1                              @ r0<- op, r0-r3 changed
@@ -4514,8 +4788,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_LONG: /* 0x9b */
-/* File: armv5te/OP_ADD_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_ADD_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4536,11 +4810,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_ADD_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4550,7 +4822,13 @@ dalvik_inst:
     adds    r0, r0, r2                           @ optional op; may set condition codes
     adc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4559,8 +4837,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_LONG: /* 0x9c */
-/* File: armv5te/OP_SUB_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_SUB_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4581,11 +4859,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_SUB_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4595,7 +4871,13 @@ dalvik_inst:
     subs    r0, r0, r2                           @ optional op; may set condition codes
     sbc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4604,7 +4886,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_LONG: /* 0x9d */
-/* File: armv5te/OP_MUL_LONG.S */
+/* File: armv5te_taint/OP_MUL_LONG.S */
     /*
      * Signed 64-bit integer multiply.
      *
@@ -4627,24 +4909,25 @@ dalvik_inst:
     FETCH(r0, 1)                        @ r0<- CCBB
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		mul_long_taint_prop
+// end WITH_TAINT_TRACKING
     mul     ip, r2, r1                  @  ip<- ZxW
     umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
     mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
     mov     r0, rINST, lsr #8           @ r0<- AA
     add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
-    add     r0, rFP, r0, lsl #2         @ r0<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r0, rFP, r0, lsl #3         @ r0<- &fp[AA]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     b       .LOP_MUL_LONG_finish
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_LONG: /* 0x9e */
-/* File: armv5te/OP_DIV_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_DIV_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4665,11 +4948,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_DIV_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4679,7 +4960,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4688,9 +4975,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_LONG: /* 0x9f */
-/* File: armv5te/OP_REM_LONG.S */
+/* File: armv5te_taint/OP_REM_LONG.S */
 /* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4711,11 +4998,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4725,7 +5010,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+    str		r2, [r9, #0]
+    str		r10, [r9, #4]
+    str		r3, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4734,8 +5025,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_LONG: /* 0xa0 */
-/* File: armv5te/OP_AND_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_AND_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4756,11 +5047,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_AND_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4770,7 +5059,13 @@ dalvik_inst:
     and     r0, r0, r2                           @ optional op; may set condition codes
     and     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4779,8 +5074,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_LONG: /* 0xa1 */
-/* File: armv5te/OP_OR_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_OR_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4801,11 +5096,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_OR_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4815,7 +5108,13 @@ dalvik_inst:
     orr     r0, r0, r2                           @ optional op; may set condition codes
     orr     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4824,8 +5123,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_LONG: /* 0xa2 */
-/* File: armv5te/OP_XOR_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_XOR_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4846,11 +5145,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_XOR_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4860,7 +5157,13 @@ dalvik_inst:
     eor     r0, r0, r2                           @ optional op; may set condition codes
     eor     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -4869,7 +5172,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_LONG: /* 0xa3 */
-/* File: armv5te/OP_SHL_LONG.S */
+/* File: armv5te_taint/OP_SHL_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4881,11 +5184,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r1, r1, asl r2              @  r1<- r1 << r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4898,7 +5199,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_LONG: /* 0xa4 */
-/* File: armv5te/OP_SHR_LONG.S */
+/* File: armv5te_taint/OP_SHR_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4910,11 +5211,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r0<- r0 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4927,7 +5226,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_LONG: /* 0xa5 */
-/* File: armv5te/OP_USHR_LONG.S */
+/* File: armv5te_taint/OP_USHR_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4939,11 +5238,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r0<- r0 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4956,8 +5253,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_FLOAT: /* 0xa6 */
-/* File: arm-vfp/OP_ADD_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_ADD_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -4974,20 +5271,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fadds   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_FLOAT: /* 0xa7 */
-/* File: arm-vfp/OP_SUB_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_SUB_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -5004,20 +5300,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fsubs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_FLOAT: /* 0xa8 */
-/* File: arm-vfp/OP_MUL_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_MUL_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -5034,20 +5329,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fmuls   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_FLOAT: /* 0xa9 */
-/* File: arm-vfp/OP_DIV_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_DIV_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -5064,21 +5358,20 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fdivs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_FLOAT: /* 0xaa */
-/* File: armv5te/OP_REM_FLOAT.S */
+/* File: armv5te_taint/OP_REM_FLOAT.S */
 /* EABI doesn't define a float remainder function, but libm does */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -5106,6 +5399,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_REM_FLOAT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      fmodf                              @ r0<- op, r0-r3 changed
@@ -5119,8 +5415,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_DOUBLE: /* 0xab */
-/* File: arm-vfp/OP_ADD_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_ADD_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5135,22 +5431,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    faddd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_DOUBLE: /* 0xac */
-/* File: arm-vfp/OP_SUB_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_SUB_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5165,22 +5464,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fsubd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_DOUBLE: /* 0xad */
-/* File: arm-vfp/OP_MUL_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_MUL_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5195,22 +5497,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fmuld   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_DOUBLE: /* 0xae */
-/* File: arm-vfp/OP_DIV_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_DIV_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5225,23 +5530,26 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fdivd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_DOUBLE: /* 0xaf */
-/* File: armv5te/OP_REM_DOUBLE.S */
+/* File: armv5te_taint/OP_REM_DOUBLE.S */
 /* EABI doesn't define a double remainder function, but libm does */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5262,11 +5570,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_DOUBLE_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5276,7 +5582,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      fmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
@@ -5285,8 +5597,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_2ADDR: /* 0xb0 */
-/* File: armv6t2/OP_ADD_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_ADD_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5310,6 +5622,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_ADD_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5324,8 +5638,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_INT_2ADDR: /* 0xb1 */
-/* File: armv6t2/OP_SUB_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SUB_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5349,6 +5663,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SUB_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5363,9 +5679,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_2ADDR: /* 0xb2 */
-/* File: armv6t2/OP_MUL_INT_2ADDR.S */
+/* File: armv6t2_taint/OP_MUL_INT_2ADDR.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5389,6 +5705,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_MUL_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5403,8 +5721,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_2ADDR: /* 0xb3 */
-/* File: armv6t2/OP_DIV_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_DIV_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5428,6 +5746,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_DIV_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5442,9 +5762,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_2ADDR: /* 0xb4 */
-/* File: armv6t2/OP_REM_INT_2ADDR.S */
+/* File: armv6t2_taint/OP_REM_INT_2ADDR.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5468,6 +5788,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_REM_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5482,8 +5804,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_2ADDR: /* 0xb5 */
-/* File: armv6t2/OP_AND_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_AND_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5507,6 +5829,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_AND_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5521,8 +5845,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_2ADDR: /* 0xb6 */
-/* File: armv6t2/OP_OR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_OR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5546,6 +5870,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_OR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5560,8 +5886,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_2ADDR: /* 0xb7 */
-/* File: armv6t2/OP_XOR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_XOR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5585,6 +5911,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_XOR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5599,8 +5927,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT_2ADDR: /* 0xb8 */
-/* File: armv6t2/OP_SHL_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SHL_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5624,6 +5952,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SHL_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5638,8 +5968,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT_2ADDR: /* 0xb9 */
-/* File: armv6t2/OP_SHR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SHR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5663,6 +5993,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SHR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5677,8 +6009,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT_2ADDR: /* 0xba */
-/* File: armv6t2/OP_USHR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_USHR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5702,6 +6034,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_USHR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5716,8 +6050,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_LONG_2ADDR: /* 0xbb */
-/* File: armv6t2/OP_ADD_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_ADD_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5733,12 +6067,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_ADD_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5748,7 +6082,13 @@ dalvik_inst:
     adds    r0, r0, r2                           @ optional op; may set condition codes
     adc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5757,8 +6097,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_LONG_2ADDR: /* 0xbc */
-/* File: armv6t2/OP_SUB_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_SUB_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5774,12 +6114,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_SUB_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5789,7 +6129,13 @@ dalvik_inst:
     subs    r0, r0, r2                           @ optional op; may set condition codes
     sbc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5798,7 +6144,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_LONG_2ADDR: /* 0xbd */
-/* File: armv6t2/OP_MUL_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_MUL_LONG_2ADDR.S */
     /*
      * Signed 64-bit integer multiply, "/2addr" version.
      *
@@ -5808,28 +6154,33 @@ dalvik_inst:
      * again we stuff it into rINST.
      */
     /* mul-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     rINST, rFP, r9, lsl #2      @ rINST<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
-    mul     ip, r2, r1                  @  ip<- ZxW
+// begin WITH_TAINT_TRACKING
+	bl		mul_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
     umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
     mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
     mov     r0, rINST                   @ r0<- &fp[A] (free up rINST)
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_LONG_2ADDR: /* 0xbe */
-/* File: armv6t2/OP_DIV_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_DIV_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5845,12 +6196,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_DIV_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5860,7 +6211,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5869,9 +6226,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_LONG_2ADDR: /* 0xbf */
-/* File: armv6t2/OP_REM_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_REM_LONG_2ADDR.S */
 /* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5887,12 +6244,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5902,7 +6259,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+    str		r2, [r9, #0]
+    str		r10, [r9, #4]
+    str		r3, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5911,8 +6274,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_LONG_2ADDR: /* 0xc0 */
-/* File: armv6t2/OP_AND_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_AND_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5928,12 +6291,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_AND_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5943,7 +6306,13 @@ dalvik_inst:
     and     r0, r0, r2                           @ optional op; may set condition codes
     and     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5952,8 +6321,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_LONG_2ADDR: /* 0xc1 */
-/* File: armv6t2/OP_OR_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_OR_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5969,12 +6338,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_OR_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5984,7 +6353,13 @@ dalvik_inst:
     orr     r0, r0, r2                           @ optional op; may set condition codes
     orr     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -5993,8 +6368,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_LONG_2ADDR: /* 0xc2 */
-/* File: armv6t2/OP_XOR_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_XOR_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -6010,12 +6385,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_XOR_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -6025,7 +6400,13 @@ dalvik_inst:
     eor     r0, r0, r2                           @ optional op; may set condition codes
     eor     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -6034,18 +6415,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_LONG_2ADDR: /* 0xc3 */
-/* File: armv6t2/OP_SHL_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_SHL_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* shl-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r1, r1, asl r2              @  r1<- r1 << r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6059,18 +6441,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_LONG_2ADDR: /* 0xc4 */
-/* File: armv6t2/OP_SHR_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_SHR_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* shr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6084,18 +6467,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_LONG_2ADDR: /* 0xc5 */
-/* File: armv6t2/OP_USHR_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_USHR_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* ushr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6109,8 +6493,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
-/* File: arm-vfp/OP_ADD_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_ADD_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6124,21 +6508,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fadds   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
-/* File: arm-vfp/OP_SUB_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_SUB_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6152,21 +6539,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fsubs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
-/* File: arm-vfp/OP_MUL_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_MUL_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6180,21 +6570,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fmuls   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
-/* File: arm-vfp/OP_DIV_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_DIV_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6208,22 +6601,25 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fdivs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_FLOAT_2ADDR: /* 0xca */
-/* File: armv6t2/OP_REM_FLOAT_2ADDR.S */
+/* File: armv6t2_taint/OP_REM_FLOAT_2ADDR.S */
 /* EABI doesn't define a float remainder function, but libm does */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6247,6 +6643,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_REM_FLOAT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6261,8 +6659,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
-/* File: arm-vfp/OP_ADD_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_ADD_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6276,22 +6674,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    faddd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
-/* File: arm-vfp/OP_SUB_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_SUB_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6305,22 +6709,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fsubd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
-/* File: arm-vfp/OP_MUL_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_MUL_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6334,22 +6744,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fmuld   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_DOUBLE_2ADDR: /* 0xce */
-/* File: arm-vfp/OP_DIV_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_DIV_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6363,23 +6779,29 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fdivd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_DOUBLE_2ADDR: /* 0xcf */
-/* File: armv6t2/OP_REM_DOUBLE_2ADDR.S */
+/* File: armv5te_taint/OP_REM_DOUBLE_2ADDR.S */
 /* EABI doesn't define a double remainder function, but libm does */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -6395,12 +6817,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_DOUBLE_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -6410,7 +6832,13 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      fmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
@@ -6419,8 +6847,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_LIT16: /* 0xd0 */
-/* File: armv6t2/OP_ADD_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_ADD_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6436,8 +6864,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6455,9 +6889,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RSUB_INT: /* 0xd1 */
-/* File: armv6t2/OP_RSUB_INT.S */
+/* File: armv5te_taint/OP_RSUB_INT.S */
 /* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6473,8 +6907,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6492,9 +6932,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_LIT16: /* 0xd2 */
-/* File: armv6t2/OP_MUL_INT_LIT16.S */
+/* File: armv5te_taint/OP_MUL_INT_LIT16.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6510,8 +6950,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6529,8 +6975,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_LIT16: /* 0xd3 */
-/* File: armv6t2/OP_DIV_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_DIV_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6546,8 +6992,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 1
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6565,9 +7017,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_LIT16: /* 0xd4 */
-/* File: armv6t2/OP_REM_INT_LIT16.S */
+/* File: armv5te_taint/OP_REM_INT_LIT16.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6583,8 +7035,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 1
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6602,8 +7060,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_LIT16: /* 0xd5 */
-/* File: armv6t2/OP_AND_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_AND_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6619,8 +7077,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6638,8 +7102,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_LIT16: /* 0xd6 */
-/* File: armv6t2/OP_OR_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_OR_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6655,8 +7119,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6674,8 +7144,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_LIT16: /* 0xd7 */
-/* File: armv6t2/OP_XOR_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_XOR_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6691,8 +7161,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6710,8 +7186,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_LIT8: /* 0xd8 */
-/* File: armv5te/OP_ADD_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_ADD_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6735,6 +7211,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6749,8 +7230,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RSUB_INT_LIT8: /* 0xd9 */
-/* File: armv5te/OP_RSUB_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_RSUB_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6774,6 +7255,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6788,9 +7274,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_LIT8: /* 0xda */
-/* File: armv5te/OP_MUL_INT_LIT8.S */
+/* File: armv5te_taint/OP_MUL_INT_LIT8.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6814,6 +7300,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6828,8 +7319,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_LIT8: /* 0xdb */
-/* File: armv5te/OP_DIV_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_DIV_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6853,6 +7344,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6867,9 +7363,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_LIT8: /* 0xdc */
-/* File: armv5te/OP_REM_INT_LIT8.S */
+/* File: armv5te_taint/OP_REM_INT_LIT8.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6893,6 +7389,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6907,8 +7408,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_LIT8: /* 0xdd */
-/* File: armv5te/OP_AND_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_AND_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6932,6 +7433,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6946,8 +7452,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_LIT8: /* 0xde */
-/* File: armv5te/OP_OR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_OR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6971,6 +7477,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6985,8 +7496,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_LIT8: /* 0xdf */
-/* File: armv5te/OP_XOR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_XOR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7010,6 +7521,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -7024,8 +7540,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT_LIT8: /* 0xe0 */
-/* File: armv5te/OP_SHL_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_SHL_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7049,6 +7565,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -7063,8 +7584,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT_LIT8: /* 0xe1 */
-/* File: armv5te/OP_SHR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_SHR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7088,6 +7609,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -7102,8 +7628,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT_LIT8: /* 0xe2 */
-/* File: armv5te/OP_USHR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_USHR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7127,6 +7653,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -7141,8 +7672,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E3: /* 0xe3 */
-/* File: armv5te/OP_UNUSED_E3.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E3.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7150,8 +7681,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E4: /* 0xe4 */
-/* File: armv5te/OP_UNUSED_E4.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E4.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7159,8 +7690,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E5: /* 0xe5 */
-/* File: armv5te/OP_UNUSED_E5.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E5.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7168,8 +7699,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E6: /* 0xe6 */
-/* File: armv5te/OP_UNUSED_E6.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E6.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7177,8 +7708,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E7: /* 0xe7 */
-/* File: armv5te/OP_UNUSED_E7.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E7.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7186,8 +7717,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E8: /* 0xe8 */
-/* File: armv5te/OP_UNUSED_E8.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E8.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7195,8 +7726,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_E9: /* 0xe9 */
-/* File: armv5te/OP_UNUSED_E9.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_E9.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7204,8 +7735,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EA: /* 0xea */
-/* File: armv5te/OP_UNUSED_EA.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EA.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7213,8 +7744,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EB: /* 0xeb */
-/* File: armv5te/OP_UNUSED_EB.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EB.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7222,8 +7753,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EC: /* 0xec */
-/* File: armv5te/OP_UNUSED_EC.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EC.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7231,7 +7762,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_THROW_VERIFICATION_ERROR: /* 0xed */
-/* File: armv5te/OP_THROW_VERIFICATION_ERROR.S */
+/* File: armv5te_taint/OP_THROW_VERIFICATION_ERROR.S */
     /*
      * Handle a throw-verification-error instruction.  This throws an
      * exception for an error discovered during verification.  The
@@ -7249,7 +7780,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_EXECUTE_INLINE: /* 0xee */
-/* File: armv5te/OP_EXECUTE_INLINE.S */
+/* File: armv5te_taint/OP_EXECUTE_INLINE.S */
     /*
      * Execute a "native inline" instruction.
      *
@@ -7277,8 +7808,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_EF: /* 0xef */
-/* File: armv5te/OP_UNUSED_EF.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_EF.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7286,7 +7817,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT_EMPTY: /* 0xf0 */
-/* File: armv5te/OP_INVOKE_DIRECT_EMPTY.S */
+/* File: armv5te_taint/OP_INVOKE_DIRECT_EMPTY.S */
     /*
      * invoke-direct-empty is a no-op in a "standard" interpreter.
      */
@@ -7297,8 +7828,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_F1: /* 0xf1 */
-/* File: armv5te/OP_UNUSED_F1.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_F1.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7306,59 +7837,92 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_QUICK: /* 0xf2 */
-/* File: armv6t2/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE_QUICK: /* 0xf3 */
-/* File: armv6t2/OP_IGET_WIDE_QUICK.S */
+/* File: armv5te_taint/OP_IGET_WIDE_QUICK.S */
     /* iget-wide-quick vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
+// begin WITH_TAINT_TRACKING
+	add		r10, r1, #8
     ldrd    r0, [r3, r1]                @ r0<- obj.field (64 bits, aligned)
+    ldr		r10, [r3, r10]
+    orr		r10, r9, r10
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT_QUICK: /* 0xf4 */
-/* File: armv5te/OP_IGET_OBJECT_QUICK.S */
-/* File: armv5te/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
     FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
     mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_OBJECT_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
     and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -7366,18 +7930,27 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_QUICK: /* 0xf5 */
-/* File: armv6t2/OP_IPUT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_QUICK.S */
     /* For: iput-quick, iput-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- fp[B], the object pointer
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
+    and     r2, r2, #15
     GET_VREG(r0, r2)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -7385,18 +7958,23 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_WIDE_QUICK: /* 0xf6 */
-/* File: armv6t2/OP_IPUT_WIDE_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_WIDE_QUICK.S */
     /* iput-wide-quick vA, vB, offset@CCCC */
+    mov     r0, rINST, lsr #8           @ r0<- A(+)
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r0, rINST, #8, #4           @ r0<- A
+    and     r0, r0, #15
     GET_VREG(r2, r1)                    @ r2<- fp[B], the object pointer
-    add     r3, rFP, r0, lsl #2         @ r3<- &fp[A]
-    cmp     r2, #0                      @ check object for null
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+// begin WITH_TAINT_TRACKING
+	bl iput_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH(r3, 1)                        @ r3<- field byte offset
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     strd    r0, [r2, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r9, [r2, r3]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -7404,8 +7982,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
-/* File: armv5te/OP_IPUT_OBJECT_QUICK.S */
-/* File: armv5te/OP_IPUT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_QUICK.S */
     /* For: iput-quick, iput-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
@@ -7416,8 +7994,16 @@ dalvik_inst:
     beq     common_errNullObject        @ object was null
     and     r2, r2, #15
     GET_VREG(r0, r2)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -7426,118 +8012,56 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodNoRange @ continue on
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK: /* 0xfa */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodNoRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodRange @ continue on
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FC: /* 0xfc */
-/* File: armv5te/OP_UNUSED_FC.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FC.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7545,8 +8069,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FD: /* 0xfd */
-/* File: armv5te/OP_UNUSED_FD.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FD.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7554,8 +8078,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FE: /* 0xfe */
-/* File: armv5te/OP_UNUSED_FE.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FE.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7563,8 +8087,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FF: /* 0xff */
-/* File: armv5te/OP_UNUSED_FF.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FF.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7600,6 +8124,11 @@ dvmAsmSisterStart:
     bl      dvmResolveString            @ r0<- String reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7620,6 +8149,11 @@ dvmAsmSisterStart:
     bl      dvmResolveString            @ r0<- String reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7641,6 +8175,11 @@ dvmAsmSisterStart:
     bl      dvmResolveClass             @ r0<- Class reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7710,6 +8249,11 @@ dvmAsmSisterStart:
      */
 .LOP_INSTANCE_OF_store:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7722,6 +8266,11 @@ dvmAsmSisterStart:
     mov     r0, #1                      @ indicate success
     @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7755,6 +8304,11 @@ dvmAsmSisterStart:
     mov     r3, rINST, lsr #8           @ r3<- AA
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yes, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
@@ -7826,6 +8380,11 @@ dvmAsmSisterStart:
     beq     common_exceptionThrown      @ yes, handle the exception
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ vA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7858,6 +8417,9 @@ dvmAsmSisterStart:
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
     str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -7866,6 +8428,11 @@ dvmAsmSisterStart:
     @ copy values from registers into the array
     @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
     .if     0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r3)
+	str		r3, [rGLUE, #offGlue_rtaint]	@ rtaint <- clear
+	str		r3, [r2]
+// end WITH_TAINT_TRACKING
     add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
 1:  ldr     r3, [r2], #4                @ r3<- *r2++
     subs    r9, r9, #1                  @ count--
@@ -7937,6 +8504,9 @@ dvmAsmSisterStart:
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
     str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -7945,6 +8515,11 @@ dvmAsmSisterStart:
     @ copy values from registers into the array
     @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
     .if     1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r3)
+	str		r3, [rGLUE, #offGlue_rtaint]	@ rtaint <- clear
+	str		r3, [r2]
+// end WITH_TAINT_TRACKING
     add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
 1:  ldr     r3, [r2], #4                @ r3<- *r2++
     subs    r9, r9, #1                  @ count--
@@ -7992,24 +8567,50 @@ dvmAsmSisterStart:
 /* continuation for OP_CMPL_FLOAT */
 .LOP_CMPL_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPG_FLOAT */
 .LOP_CMPG_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPL_DOUBLE */
 .LOP_CMPL_DOUBLE_finish:
+    fmstat                              @ export status flags
+    movgt   r0, #1                      @ (greater than) r1<- 1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* continuation for OP_CMPG_DOUBLE */
 .LOP_CMPG_DOUBLE_finish:
+    fmstat                              @ export status flags
+    mvnmi   r0, #0                      @ (less than) r1<- -1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8021,6 +8622,11 @@ dvmAsmSisterStart:
     @ instead, we just replicate the tail end.
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r9)                    @ vAA<- r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -8031,28 +8637,174 @@ dvmAsmSisterStart:
 .LOP_CMP_LONG_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+cmp_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+	ldr		r2, [r3, #0]
+	ldr		r3, [r3, #8]
+	bx		lr
+
+/* continuation for OP_AGET */
+
+.LOP_AGET_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
 
 /* continuation for OP_AGET_WIDE */
 
 .LOP_AGET_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+    ldrd    r0, [r0, #offArrayObject_contents]  @ r0/r1<- vBB[vCC]
+    mov		r2, r1
+    mov		r1, r10
+    mov		r3, r10
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+.LOP_AGET_WIDE_taint_prop:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r10, r3, r10)
+	orr		r10, r10, r2					@ r10<- r10 | r1
+	bx		lr
+
+/* continuation for OP_AGET_OBJECT */
+
+.LOP_AGET_OBJECT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_OBJECT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BOOLEAN */
+
+.LOP_AGET_BOOLEAN_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BOOLEAN_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BYTE */
+
+.LOP_AGET_BYTE_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BYTE_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_CHAR */
+
+.LOP_AGET_CHAR_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_CHAR_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_SHORT */
 
+.LOP_AGET_SHORT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_SHORT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_APUT */
+
+.LOP_APUT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
 
 /* continuation for OP_APUT_WIDE */
 
 .LOP_APUT_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr		r2, [r9, #0]
+	ldr		r3, [r9, #8]
+	ldr		r1, [r9, #4]				@ r1<- array taint
+	ldr     r9, [r10, #offArrayObject_taint]
+	orr		r1, r1, r9					@ r1<- r1 | r9
+	str		r1, [r10, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
     strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8064,6 +8816,9 @@ dvmAsmSisterStart:
      *  r10 = offset into array (vBB + vCC * width)
      */
 .LOP_APUT_OBJECT_finish:
+// begin WITH_TAINT_TRACKING
+	str		r2, [r1, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
     cmp     r9, #0                      @ storing null reference?
     beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
     ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
@@ -8077,6 +8832,63 @@ dvmAsmSisterStart:
     str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+aput_object_taint_prop_1:
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r2, r9, r3)
+	bx		lr
+
+aput_object_taint_prop_2:
+	ldr     r3, [r1, #offArrayObject_taint]
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	bx		lr
+
+/* continuation for OP_APUT_BOOLEAN */
+
+.LOP_APUT_BOOLEAN_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_BYTE */
+
+.LOP_APUT_BYTE_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_CHAR */
+
+.LOP_APUT_CHAR_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_SHORT */
+
+.LOP_APUT_SHORT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
 
 /* continuation for OP_IGET */
 
@@ -8091,12 +8903,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
+    mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_WIDE */
 
@@ -8109,14 +8937,32 @@ dvmAsmSisterStart:
     cmp     r9, #0                      @ check object for null
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
+    mov     r2, rINST, lsr #8           @ r2<- A+
     ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    and     r2, r2, #15                 @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #8
+	ldr		r3, [r9, r3]
+	orr		r10, r3, r10
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+iget_wide_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_OBJECT */
 
@@ -8131,13 +8977,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_OBJECT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_BOOLEAN */
 
@@ -8152,13 +9013,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BOOLEAN_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_BYTE */
 
@@ -8173,13 +9049,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BYTE_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_CHAR */
 
@@ -8194,13 +9085,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_CHAR_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IGET_SHORT */
 
@@ -8215,13 +9121,28 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_SHORT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
 
 /* continuation for OP_IPUT */
 
@@ -8232,14 +9153,23 @@ dvmAsmSisterStart:
      */
 .LOP_IPUT_finish:
     @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    ubfx    r1, rINST, #8, #4           @ r1<- A
+    and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8251,15 +9181,27 @@ dvmAsmSisterStart:
      *  r9 holds object
      */
 .LOP_IPUT_WIDE_finish:
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    mov     r2, rINST, lsr #8           @ r2<- A+
     cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r10, [r2, #4]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8277,10 +9219,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8298,10 +9248,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8319,10 +9277,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8340,10 +9306,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8361,10 +9335,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
@@ -8386,6 +9368,22 @@ dvmAsmSisterStart:
 
 /* continuation for OP_SGET_WIDE */
 
+.LOP_SGET_WIDE_finish:
+    mov     r1, rINST, lsr #8           @ r1<- AA
+    ldrd    r2, [r0, #offStaticField_value] @ r2/r3<- field value (aligned)
+// begin WITH_TAINT_TRACKING
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[AA]
+    ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+//    stmia   r1, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+	str		r2, [r1, #0]
+	str		r0, [r1, #4]
+	str		r3, [r1, #8]
+	str		r0, [r1, #12]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
     /*
      * Continuation if the field has not yet been resolved.
      *  r1: BBBB field ref
@@ -8593,147 +9591,83 @@ dvmAsmSisterStart:
     b       common_exceptionThrown      @ no, handle exception
 
 
-/* continuation for OP_INVOKE_VIRTUAL */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-
-/* continuation for OP_INVOKE_SUPER */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-.LOP_INVOKE_SUPER_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
-
-
-/* continuation for OP_INVOKE_DIRECT */
-
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+/* continuation for OP_NEG_LONG */
 
-/* continuation for OP_INVOKE_VIRTUAL_RANGE */
+.LOP_NEG_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_RANGE_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
+/* continuation for OP_NOT_LONG */
 
+.LOP_NOT_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-/* continuation for OP_INVOKE_SUPER_RANGE */
+/* continuation for OP_NEG_DOUBLE */
 
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_RANGE_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
+.LOP_NEG_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-.LOP_INVOKE_SUPER_RANGE_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_INT_TO_LONG */
 
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_RANGE_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
+.LOP_INT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
 
+/* continuation for OP_LONG_TO_DOUBLE */
 
-/* continuation for OP_INVOKE_DIRECT_RANGE */
+.LOP_LONG_TO_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_RANGE_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_FLOAT_TO_LONG */
 
+.LOP_FLOAT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
 
 /* continuation for OP_FLOAT_TO_LONG */
 /*
@@ -8774,6 +9708,19 @@ f2l_doconv:
 
 
 /* continuation for OP_DOUBLE_TO_LONG */
+
+.LOP_DOUBLE_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
+
+/* continuation for OP_DOUBLE_TO_LONG */
 /*
  * Convert the double in r0/r1 to a long in r0/r1.
  *
@@ -8824,64 +9771,973 @@ d2l_doconv:
     ldmfd   sp!, {r4, r5, pc}
 
 
+/* continuation for OP_ADD_INT */
+
+.LOP_ADD_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SUB_INT */
+
+.LOP_SUB_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_MUL_INT */
+
+.LOP_MUL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_DIV_INT */
+
+.LOP_DIV_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_REM_INT */
+
+.LOP_REM_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_AND_INT */
+
+.LOP_AND_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_OR_INT */
+
+.LOP_OR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_XOR_INT */
+
+.LOP_XOR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHL_INT */
+
+.LOP_SHL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHR_INT */
+
+.LOP_SHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_USHR_INT */
+
+.LOP_USHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_LONG */
+
+.LOP_ADD_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG */
+
+.LOP_SUB_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
 /* continuation for OP_MUL_LONG */
 
 .LOP_MUL_LONG_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+mul_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	bx		lr
+
+/* continuation for OP_DIV_LONG */
+
+.LOP_DIV_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG */
+
+.LOP_REM_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG */
+
+.LOP_AND_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG */
+
+.LOP_OR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG */
+
+.LOP_XOR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_SHL_LONG */
 
 .LOP_SHL_LONG_finish:
     mov     r0, r0, asl r2              @  r0<- r0 << r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
 
 /* continuation for OP_SHR_LONG */
 
 .LOP_SHR_LONG_finish:
     mov     r1, r1, asr r2              @  r1<- r1 >> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
 
 /* continuation for OP_USHR_LONG */
 
 .LOP_USHR_LONG_finish:
     mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+ushr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r0<- r0 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
+
+/* continuation for OP_ADD_FLOAT */
+
+.LOP_ADD_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_SUB_FLOAT */
+
+.LOP_SUB_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_MUL_FLOAT */
+
+.LOP_MUL_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_DIV_FLOAT */
+
+.LOP_DIV_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+
+/* continuation for OP_REM_FLOAT */
+
+.LOP_REM_FLOAT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE */
+
+.LOP_ADD_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    faddd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE */
+
+.LOP_SUB_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_DOUBLE */
+
+.LOP_MUL_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuld   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_DOUBLE */
+
+.LOP_DIV_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE */
+
+.LOP_REM_DOUBLE_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_ADD_INT_2ADDR */
+
+.LOP_ADD_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SUB_INT_2ADDR */
+
+.LOP_SUB_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_MUL_INT_2ADDR */
+
+.LOP_MUL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_DIV_INT_2ADDR */
+
+.LOP_DIV_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_REM_INT_2ADDR */
+
+.LOP_REM_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_AND_INT_2ADDR */
+
+.LOP_AND_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_OR_INT_2ADDR */
+
+.LOP_OR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_XOR_INT_2ADDR */
+
+.LOP_XOR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHL_INT_2ADDR */
+
+.LOP_SHL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHR_INT_2ADDR */
+
+.LOP_SHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_USHR_INT_2ADDR */
+
+.LOP_USHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_LONG_2ADDR */
+
+.LOP_ADD_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG_2ADDR */
+
+.LOP_SUB_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_MUL_LONG_2ADDR */
+
+mul_long_2addr_taint_prop:
+    and     r9, r9, #15
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     rINST, rFP, r9, lsl #3      @ rINST<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r9, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
+    ldr		r0, [rINST, #0]
+    ldr		r10, [rINST, #4]
+    ldr		r1, [rINST, #8]
+	orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	mul     ip, r2, r1                  @  ip<- ZxW
+	bx		lr
+
+/* continuation for OP_DIV_LONG_2ADDR */
+
+.LOP_DIV_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG_2ADDR */
+
+.LOP_REM_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG_2ADDR */
+
+.LOP_AND_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG_2ADDR */
+
+.LOP_OR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG_2ADDR */
+
+.LOP_XOR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_SHL_LONG_2ADDR */
 
 .LOP_SHL_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
 
 /* continuation for OP_SHR_LONG_2ADDR */
 
 .LOP_SHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+// OP_SHR_LONG_2ADDR.S
+shr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
 
 /* continuation for OP_USHR_LONG_2ADDR */
 
 .LOP_USHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
+
+/* continuation for OP_ADD_FLOAT_2ADDR */
+
+.LOP_ADD_FLOAT_2ADDR_finish:
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_FLOAT_2ADDR */
+
+.LOP_SUB_FLOAT_2ADDR_finish:
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_FLOAT_2ADDR */
+
+.LOP_MUL_FLOAT_2ADDR_finish:
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_FLOAT_2ADDR */
+
+.LOP_DIV_FLOAT_2ADDR_finish:
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_FLOAT_2ADDR */
+
+.LOP_REM_FLOAT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE_2ADDR */
+
+.LOP_ADD_DOUBLE_2ADDR_finish:
+    faddd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE_2ADDR */
+
+.LOP_SUB_DOUBLE_2ADDR_finish:
+    fsubd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_DOUBLE_2ADDR */
+
+.LOP_MUL_DOUBLE_2ADDR_finish:
+    fmuld   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_DIV_DOUBLE_2ADDR */
+
+.LOP_DIV_DOUBLE_2ADDR_finish:
+    fdivd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE_2ADDR */
+
+.LOP_REM_DOUBLE_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_EXECUTE_INLINE */
 
@@ -8902,15 +10758,17 @@ d2l_doconv:
     FETCH(r9, 2)                        @ r9<- FEDC
     add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
     bl      common_abort                @ (skipped due to ARM prefetch)
+// begin WITH_TAINT_TRACKING
 4:  and     ip, r9, #0xf000             @ isolate F
-    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
+    ldr     r3, [rFP, ip, lsr #9]      @ r3<- vF (shift right 12, left 2)
 3:  and     ip, r9, #0x0f00             @ isolate E
-    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
+    ldr     r2, [rFP, ip, lsr #5]       @ r2<- vE
 2:  and     ip, r9, #0x00f0             @ isolate D
-    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
+    ldr     r1, [rFP, ip, lsr #1]       @ r1<- vD
 1:  and     ip, r9, #0x000f             @ isolate C
-    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
+    ldr     r0, [rFP, ip, lsl #3]       @ r0<- vC
 0:
+// end WITH_TAINT_TRACKING
     ldr     r9, .LOP_EXECUTE_INLINE_table       @ table of InlineOperation
     LDR_PC  "[r9, r10, lsl #4]"         @ sizeof=16, "func" is first entry
     @ (not reached)
@@ -8919,11 +10777,52 @@ d2l_doconv:
     .word   gDvmInlineOpsTable
 
 
+/* continuation for OP_IGET_QUICK */
+
+.LOP_IGET_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IGET_WIDE_QUICK */
+
+iget_wide_quick_taint_prop:
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+	bx		lr
+
+/* continuation for OP_IGET_OBJECT_QUICK */
+
+.LOP_IGET_OBJECT_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IPUT_WIDE_QUICK */
+
+iput_wide_quick_taint_prop:
+    add     r3, rFP, r0, lsl #3         @ r3<- &fp[A]
+    cmp     r2, #0                      @ check object for null
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r9, [r3, #4]
+	bx		lr
+
     .size   dvmAsmSisterStart, .-dvmAsmSisterStart
     .global dvmAsmSisterEnd
 dvmAsmSisterEnd:
 
-/* File: armv5te/footer.S */
+/* File: armv5te_taint/footer.S */
 
 /*
  * ===========================================================================
diff --git a/vm/mterp/out/InterpC-allstubs.c b/vm/mterp/out/InterpC-allstubs.c
index 4e832d8..ad2c247 100644
--- a/vm/mterp/out/InterpC-allstubs.c
+++ b/vm/mterp/out/InterpC-allstubs.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1198,6 +1486,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1209,6 +1500,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1220,6 +1514,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1232,6 +1529,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1242,6 +1542,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1252,6 +1555,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1264,6 +1570,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1277,6 +1586,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1290,6 +1602,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1301,6 +1616,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1309,6 +1627,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1320,6 +1641,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1330,6 +1654,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1340,6 +1667,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1349,6 +1679,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1357,6 +1690,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1367,6 +1703,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1380,6 +1719,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1390,6 +1732,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1403,6 +1748,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1413,6 +1761,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1422,6 +1773,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1435,6 +1789,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1451,6 +1808,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1461,6 +1821,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1480,6 +1843,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1502,6 +1868,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1522,6 +1891,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1641,6 +2013,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -1659,6 +2034,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1696,6 +2074,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1733,6 +2114,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2070,6 +2454,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));
         ((u4*) arrayObj->contents)[GET_REGISTER(vsrc2)] =
             GET_REGISTER(vdst);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2478,6 +2867,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2509,6 +2902,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2624,6 +3021,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2650,6 +3051,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2665,6 +3070,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2707,6 +3115,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3129,6 +3540,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -3763,6 +4177,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3773,8 +4190,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -3793,9 +4233,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3810,6 +4297,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -3831,13 +4319,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
@@ -3859,8 +4357,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -3924,6 +4429,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
             if (gDvm.debuggerActive) {
@@ -3981,3 +4495,7 @@ GOTO_TARGET_END
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
diff --git a/vm/mterp/out/InterpC-armv4t.c b/vm/mterp/out/InterpC-armv4t.c
index 6b82bc8..1127aae 100644
--- a/vm/mterp/out/InterpC-armv4t.c
+++ b/vm/mterp/out/InterpC-armv4t.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1196,6 +1484,10 @@ GOTO_TARGET_DECL(exceptionThrown);
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
 /* File: armv5te/debug.c */
 #include <inttypes.h>
 
diff --git a/vm/mterp/out/InterpC-armv5te-vfp.c b/vm/mterp/out/InterpC-armv5te-vfp.c
index 7312700..ed71288 100644
--- a/vm/mterp/out/InterpC-armv5te-vfp.c
+++ b/vm/mterp/out/InterpC-armv5te-vfp.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1196,6 +1484,10 @@ GOTO_TARGET_DECL(exceptionThrown);
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
 /* File: armv5te/debug.c */
 #include <inttypes.h>
 
diff --git a/vm/mterp/out/InterpC-armv5te.c b/vm/mterp/out/InterpC-armv5te.c
index ea11551..b14eb00 100644
--- a/vm/mterp/out/InterpC-armv5te.c
+++ b/vm/mterp/out/InterpC-armv5te.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1196,6 +1484,10 @@ GOTO_TARGET_DECL(exceptionThrown);
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
 /* File: armv5te/debug.c */
 #include <inttypes.h>
 
diff --git a/vm/mterp/out/InterpC-armv7-a.c b/vm/mterp/out/InterpC-armv7-a.c
index 97799ec..47629c6 100644
--- a/vm/mterp/out/InterpC-armv7-a.c
+++ b/vm/mterp/out/InterpC-armv7-a.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,10 +1465,1127 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
 
+/* File: c/OP_INVOKE_VIRTUAL.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeVirtual, false);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeSuper, false);
+OP_END
+
+/* File: c/OP_INVOKE_DIRECT.c */
+HANDLE_OPCODE(OP_INVOKE_DIRECT /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeDirect, false);
+OP_END
+
+/* File: c/OP_INVOKE_STATIC.c */
+HANDLE_OPCODE(OP_INVOKE_STATIC /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeStatic, false);
+OP_END
+
+/* File: c/OP_INVOKE_INTERFACE.c */
+HANDLE_OPCODE(OP_INVOKE_INTERFACE /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeInterface, false);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeVirtual, true);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeSuper, true);
+OP_END
+
+/* File: c/OP_INVOKE_DIRECT_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_DIRECT_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeDirect, true);
+OP_END
+
+/* File: c/OP_INVOKE_STATIC_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_STATIC_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeStatic, true);
+OP_END
+
+/* File: c/OP_INVOKE_INTERFACE_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_INTERFACE_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeInterface, true);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_QUICK.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_QUICK /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeVirtualQuick, false);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_QUICK_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_QUICK_RANGE/*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeVirtualQuick, true);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_QUICK.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_QUICK /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeSuperQuick, false);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_QUICK_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_QUICK_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeSuperQuick, true);
+OP_END
+
+/* File: c/gotoTargets.c */
+/*
+ * C footer.  This has some common code shared by the various targets.
+ */
+
+/*
+ * Everything from here on is a "goto target".  In the basic interpreter
+ * we jump into these targets and then jump directly to the handler for
+ * next instruction.  Here, these are subroutines that return to the caller.
+ */
+
+GOTO_TARGET(filledNewArray, bool methodCallRange)
+    {
+        ClassObject* arrayClass;
+        ArrayObject* newArray;
+        u4* contents;
+        char typeCh;
+        int i;
+        u4 arg5;
+
+        EXPORT_PC();
+
+        ref = FETCH(1);             /* class ref */
+        vdst = FETCH(2);            /* first 4 regs -or- range base */
+
+        if (methodCallRange) {
+            vsrc1 = INST_AA(inst);  /* #of elements */
+            arg5 = -1;              /* silence compiler warning */
+            ILOGV("|filled-new-array-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+        } else {
+            arg5 = INST_A(inst);
+            vsrc1 = INST_B(inst);   /* #of elements */
+            ILOGV("|filled-new-array args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1, ref, vdst, arg5);
+        }
+
+        /*
+         * Resolve the array class.
+         */
+        arrayClass = dvmDexGetResolvedClass(methodClassDex, ref);
+        if (arrayClass == NULL) {
+            arrayClass = dvmResolveClass(curMethod->clazz, ref, false);
+            if (arrayClass == NULL)
+                GOTO_exceptionThrown();
+        }
+        /*
+        if (!dvmIsArrayClass(arrayClass)) {
+            dvmThrowException("Ljava/lang/RuntimeError;",
+                "filled-new-array needs array class");
+            GOTO_exceptionThrown();
+        }
+        */
+        /* verifier guarantees this is an array class */
+        assert(dvmIsArrayClass(arrayClass));
+        assert(dvmIsClassInitialized(arrayClass));
+
+        /*
+         * Create an array of the specified type.
+         */
+        LOGVV("+++ filled-new-array type is '%s'\n", arrayClass->descriptor);
+        typeCh = arrayClass->descriptor[1];
+        if (typeCh == 'D' || typeCh == 'J') {
+            /* category 2 primitives not allowed */
+            dvmThrowException("Ljava/lang/RuntimeError;",
+                "bad filled array req");
+            GOTO_exceptionThrown();
+        } else if (typeCh != 'L' && typeCh != '[' && typeCh != 'I') {
+            /* TODO: requires multiple "fill in" loops with different widths */
+            LOGE("non-int primitives not implemented\n");
+            dvmThrowException("Ljava/lang/InternalError;",
+                "filled-new-array not implemented for anything but 'int'");
+            GOTO_exceptionThrown();
+        }
+
+        newArray = dvmAllocArrayByClass(arrayClass, vsrc1, ALLOC_DONT_TRACK);
+        if (newArray == NULL)
+            GOTO_exceptionThrown();
+
+        /*
+         * Fill in the elements.  It's legal for vsrc1 to be zero.
+         */
+        contents = (u4*) newArray->contents;
+        if (methodCallRange) {
+            for (i = 0; i < vsrc1; i++)
+                contents[i] = GET_REGISTER(vdst+i);
+        } else {
+            assert(vsrc1 <= 5);
+            if (vsrc1 == 5) {
+                contents[4] = GET_REGISTER(arg5);
+                vsrc1--;
+            }
+            for (i = 0; i < vsrc1; i++) {
+                contents[i] = GET_REGISTER(vdst & 0x0f);
+                vdst >>= 4;
+            }
+        }
+
+        retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
+    }
+    FINISH(3);
+GOTO_TARGET_END
+
+
+GOTO_TARGET(invokeVirtual, bool methodCallRange)
+    {
+        Method* baseMethod;
+        Object* thisPtr;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-virtual-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-virtual args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+        /*
+         * Resolve the method.  This is the correct method for the static
+         * type of the object.  We also verify access permissions here.
+         */
+        baseMethod = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (baseMethod == NULL) {
+            baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
+            if (baseMethod == NULL) {
+                ILOGV("+ unknown method or access denied\n");
+                GOTO_exceptionThrown();
+            }
+        }
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method.
+         */
+        assert(baseMethod->methodIndex < thisPtr->clazz->vtableCount);
+        methodToCall = thisPtr->clazz->vtable[baseMethod->methodIndex];
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            /*
+             * This can happen if you create two classes, Base and Sub, where
+             * Sub is a sub-class of Base.  Declare a protected abstract
+             * method foo() in Base, and invoke foo() from a method in Base.
+             * Base is an "abstract base class" and is never instantiated
+             * directly.  Now, Override foo() in Sub, and use Sub.  This
+             * Works fine unless Sub stops providing an implementation of
+             * the method.
+             */
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+
+        LOGVV("+++ base=%s.%s virtual[%d]=%s.%s\n",
+            baseMethod->clazz->descriptor, baseMethod->name,
+            (u4) baseMethod->methodIndex,
+            methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+#if 0
+        if (vsrc1 != methodToCall->insSize) {
+            LOGW("WRONG METHOD: base=%s.%s virtual[%d]=%s.%s\n",
+                baseMethod->clazz->descriptor, baseMethod->name,
+                (u4) baseMethod->methodIndex,
+                methodToCall->clazz->descriptor, methodToCall->name);
+            //dvmDumpClass(baseMethod->clazz);
+            //dvmDumpClass(methodToCall->clazz);
+            dvmDumpAllClasses(0);
+        }
+#endif
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeSuper, bool methodCallRange)
+    {
+        Method* baseMethod;
+        u2 thisReg;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        if (methodCallRange) {
+            ILOGV("|invoke-super-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-super args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        /* impossible in well-formed code, but we must check nevertheless */
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+        /*
+         * Resolve the method.  This is the correct method for the static
+         * type of the object.  We also verify access permissions here.
+         * The first arg to dvmResolveMethod() is just the referring class
+         * (used for class loaders and such), so we don't want to pass
+         * the superclass into the resolution call.
+         */
+        baseMethod = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (baseMethod == NULL) {
+            baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
+            if (baseMethod == NULL) {
+                ILOGV("+ unknown method or access denied\n");
+                GOTO_exceptionThrown();
+            }
+        }
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method's class.
+         *
+         * We're using the current method's class' superclass, not the
+         * superclass of "this".  This is because we might be executing
+         * in a method inherited from a superclass, and we want to run
+         * in that class' superclass.
+         */
+        if (baseMethod->methodIndex >= curMethod->clazz->super->vtableCount) {
+            /*
+             * Method does not exist in the superclass.  Could happen if
+             * superclass gets updated.
+             */
+            dvmThrowException("Ljava/lang/NoSuchMethodError;",
+                baseMethod->name);
+            GOTO_exceptionThrown();
+        }
+        methodToCall = curMethod->clazz->super->vtable[baseMethod->methodIndex];
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+        LOGVV("+++ base=%s.%s super-virtual=%s.%s\n",
+            baseMethod->clazz->descriptor, baseMethod->name,
+            methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeInterface, bool methodCallRange)
+    {
+        Object* thisPtr;
+        ClassObject* thisClass;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-interface-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-interface args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+        thisClass = thisPtr->clazz;
+
+        /*
+         * Given a class and a method index, find the Method* with the
+         * actual code we want to execute.
+         */
+        methodToCall = dvmFindInterfaceMethodInCache(thisClass, ref, curMethod,
+                        methodClassDex);
+        if (methodToCall == NULL) {
+            assert(dvmCheckException(self));
+            GOTO_exceptionThrown();
+        }
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeDirect, bool methodCallRange)
+    {
+        u2 thisReg;
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        EXPORT_PC();
+
+        if (methodCallRange) {
+            ILOGV("|invoke-direct-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-direct args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+        methodToCall = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (methodToCall == NULL) {
+            methodToCall = dvmResolveMethod(curMethod->clazz, ref,
+                            METHOD_DIRECT);
+            if (methodToCall == NULL) {
+                ILOGV("+ unknown direct method\n");     // should be impossible
+                GOTO_exceptionThrown();
+            }
+        }
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeStatic, bool methodCallRange)
+    vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+    ref = FETCH(1);             /* method ref */
+    vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+    EXPORT_PC();
+
+    if (methodCallRange)
+        ILOGV("|invoke-static-range args=%d @0x%04x {regs=v%d-v%d}",
+            vsrc1, ref, vdst, vdst+vsrc1-1);
+    else
+        ILOGV("|invoke-static args=%d @0x%04x {regs=0x%04x %x}",
+            vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+
+    methodToCall = dvmDexGetResolvedMethod(methodClassDex, ref);
+    if (methodToCall == NULL) {
+        methodToCall = dvmResolveMethod(curMethod->clazz, ref, METHOD_STATIC);
+        if (methodToCall == NULL) {
+            ILOGV("+ unknown method\n");
+            GOTO_exceptionThrown();
+        }
+    }
+    GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeVirtualQuick, bool methodCallRange)
+    {
+        Object* thisPtr;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* vtable index */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-virtual-quick-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-virtual-quick args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method.
+         */
+        assert(ref < thisPtr->clazz->vtableCount);
+        methodToCall = thisPtr->clazz->vtable[ref];
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+
+        LOGVV("+++ virtual[%d]=%s.%s\n",
+            ref, methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeSuperQuick, bool methodCallRange)
+    {
+        u2 thisReg;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* vtable index */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        if (methodCallRange) {
+            ILOGV("|invoke-super-quick-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-super-quick args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        /* impossible in well-formed code, but we must check nevertheless */
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+#if 0   /* impossible in optimized + verified code */
+        if (ref >= curMethod->clazz->super->vtableCount) {
+            dvmThrowException("Ljava/lang/NoSuchMethodError;", NULL);
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(ref < curMethod->clazz->super->vtableCount);
+#endif
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method's class.
+         *
+         * We're using the current method's class' superclass, not the
+         * superclass of "this".  This is because we might be executing
+         * in a method inherited from a superclass, and we want to run
+         * in the method's class' superclass.
+         */
+        methodToCall = curMethod->clazz->super->vtable[ref];
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+        LOGVV("+++ super-virtual[%d]=%s.%s\n",
+            ref, methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+
+
+    /*
+     * General handling for return-void, return, and return-wide.  Put the
+     * return value in "retval" before jumping here.
+     */
+GOTO_TARGET(returnFromMethod)
+    {
+        StackSaveArea* saveArea;
+
+        /*
+         * We must do this BEFORE we pop the previous stack frame off, so
+         * that the GC can see the return value (if any) in the local vars.
+         *
+         * Since this is now an interpreter switch point, we must do it before
+         * we do anything at all.
+         */
+        PERIODIC_CHECKS(kInterpEntryReturn, 0);
+
+        ILOGV("> retval=0x%llx (leaving %s.%s %s)",
+            retval.j, curMethod->clazz->descriptor, curMethod->name,
+            curMethod->shorty);
+        //DUMP_REGS(curMethod, fp);
+
+        saveArea = SAVEAREA_FROM_FP(fp);
+
+#ifdef EASY_GDB
+        debugSaveArea = saveArea;
+#endif
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_PROFILER)
+        TRACE_METHOD_EXIT(self, curMethod);
+#endif
+
+        /* back up to previous frame and see if we hit a break */
+        fp = saveArea->prevFrame;
+        assert(fp != NULL);
+        if (dvmIsBreakFrame(fp)) {
+            /* bail without popping the method frame from stack */
+            LOGVV("+++ returned into break frame\n");
+            GOTO_bail();
+        }
+
+        /* update thread FP, and reset local variables */
+        self->curFrame = fp;
+        curMethod = SAVEAREA_FROM_FP(fp)->method;
+        //methodClass = curMethod->clazz;
+        methodClassDex = curMethod->clazz->pDvmDex;
+        pc = saveArea->savedPc;
+        ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
+            curMethod->name, curMethod->shorty);
+
+        /* use FINISH on the caller's invoke instruction */
+        //u2 invokeInstr = INST_INST(FETCH(0));
+        if (true /*invokeInstr >= OP_INVOKE_VIRTUAL &&
+            invokeInstr <= OP_INVOKE_INTERFACE*/)
+        {
+            FINISH(3);
+        } else {
+            //LOGE("Unknown invoke instr %02x at %d\n",
+            //    invokeInstr, (int) (pc - curMethod->insns));
+            assert(false);
+        }
+    }
+GOTO_TARGET_END
+
+
+    /*
+     * Jump here when the code throws an exception.
+     *
+     * By the time we get here, the Throwable has been created and the stack
+     * trace has been saved off.
+     */
+GOTO_TARGET(exceptionThrown)
+    {
+        Object* exception;
+        int catchRelPc;
+
+        /*
+         * Since this is now an interpreter switch point, we must do it before
+         * we do anything at all.
+         */
+        PERIODIC_CHECKS(kInterpEntryThrow, 0);
+
+        /*
+         * We save off the exception and clear the exception status.  While
+         * processing the exception we might need to load some Throwable
+         * classes, and we don't want class loader exceptions to get
+         * confused with this one.
+         */
+        assert(dvmCheckException(self));
+        exception = dvmGetException(self);
+        dvmAddTrackedAlloc(exception, self);
+        dvmClearException(self);
+
+        LOGV("Handling exception %s at %s:%d\n",
+            exception->clazz->descriptor, curMethod->name,
+            dvmLineNumFromPC(curMethod, pc - curMethod->insns));
+
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
+        /*
+         * Tell the debugger about it.
+         *
+         * TODO: if the exception was thrown by interpreted code, control
+         * fell through native, and then back to us, we will report the
+         * exception at the point of the throw and again here.  We can avoid
+         * this by not reporting exceptions when we jump here directly from
+         * the native call code above, but then we won't report exceptions
+         * that were thrown *from* the JNI code (as opposed to *through* it).
+         *
+         * The correct solution is probably to ignore from-native exceptions
+         * here, and have the JNI exception code do the reporting to the
+         * debugger.
+         */
+        if (gDvm.debuggerActive) {
+            void* catchFrame;
+            catchRelPc = dvmFindCatchBlock(self, pc - curMethod->insns,
+                        exception, true, &catchFrame);
+            dvmDbgPostException(fp, pc - curMethod->insns, catchFrame,
+                catchRelPc, exception);
+        }
+#endif
+
+        /*
+         * We need to unroll to the catch block or the nearest "break"
+         * frame.
+         *
+         * A break frame could indicate that we have reached an intermediate
+         * native call, or have gone off the top of the stack and the thread
+         * needs to exit.  Either way, we return from here, leaving the
+         * exception raised.
+         *
+         * If we do find a catch block, we want to transfer execution to
+         * that point.
+         */
+        catchRelPc = dvmFindCatchBlock(self, pc - curMethod->insns,
+                    exception, false, (void*)&fp);
+
+        /*
+         * Restore the stack bounds after an overflow.  This isn't going to
+         * be correct in all circumstances, e.g. if JNI code devours the
+         * exception this won't happen until some other exception gets
+         * thrown.  If the code keeps pushing the stack bounds we'll end
+         * up aborting the VM.
+         *
+         * Note we want to do this *after* the call to dvmFindCatchBlock,
+         * because that may need extra stack space to resolve exception
+         * classes (e.g. through a class loader).
+         */
+        if (self->stackOverflowed)
+            dvmCleanupStackOverflow(self);
+
+        if (catchRelPc < 0) {
+            /* falling through to JNI code or off the bottom of the stack */
+#if DVM_SHOW_EXCEPTION >= 2
+            LOGD("Exception %s from %s:%d not caught locally\n",
+                exception->clazz->descriptor, dvmGetMethodSourceFile(curMethod),
+                dvmLineNumFromPC(curMethod, pc - curMethod->insns));
+#endif
+            dvmSetException(self, exception);
+            dvmReleaseTrackedAlloc(exception, self);
+            GOTO_bail();
+        }
+
+#if DVM_SHOW_EXCEPTION >= 3
+        {
+            const Method* catchMethod = SAVEAREA_FROM_FP(fp)->method;
+            LOGD("Exception %s thrown from %s:%d to %s:%d\n",
+                exception->clazz->descriptor, dvmGetMethodSourceFile(curMethod),
+                dvmLineNumFromPC(curMethod, pc - curMethod->insns),
+                dvmGetMethodSourceFile(catchMethod),
+                dvmLineNumFromPC(catchMethod, catchRelPc));
+        }
+#endif
+
+        /*
+         * Adjust local variables to match self->curFrame and the
+         * updated PC.
+         */
+        //fp = (u4*) self->curFrame;
+        curMethod = SAVEAREA_FROM_FP(fp)->method;
+        //methodClass = curMethod->clazz;
+        methodClassDex = curMethod->clazz->pDvmDex;
+        pc = curMethod->insns + catchRelPc;
+        ILOGV("> pc <-- %s.%s %s", curMethod->clazz->descriptor,
+            curMethod->name, curMethod->shorty);
+        DUMP_REGS(curMethod, fp, false);            // show all regs
+
+        /*
+         * Restore the exception if the handler wants it.
+         *
+         * The Dalvik spec mandates that, if an exception handler wants to
+         * do something with the exception, the first instruction executed
+         * must be "move-exception".  We can pass the exception along
+         * through the thread struct, and let the move-exception instruction
+         * clear it for us.
+         *
+         * If the handler doesn't call move-exception, we don't want to
+         * finish here with an exception still pending.
+         */
+        if (INST_INST(FETCH(0)) == OP_MOVE_EXCEPTION)
+            dvmSetException(self, exception);
+
+        dvmReleaseTrackedAlloc(exception, self);
+        FINISH(0);
+    }
+GOTO_TARGET_END
+
+
+    /*
+     * General handling for invoke-{virtual,super,direct,static,interface},
+     * including "quick" variants.
+     *
+     * Set "methodToCall" to the Method we're calling, and "methodCallRange"
+     * depending on whether this is a "/range" instruction.
+     *
+     * For a range call:
+     *  "vsrc1" holds the argument count (8 bits)
+     *  "vdst" holds the first argument in the range
+     * For a non-range call:
+     *  "vsrc1" holds the argument count (4 bits) and the 5th argument index
+     *  "vdst" holds four 4-bit register indices
+     *
+     * The caller must EXPORT_PC before jumping here, because any method
+     * call can throw a stack overflow exception.
+     */
+GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
+    u2 count, u2 regs)
+    {
+        STUB_HACK(vsrc1 = count; vdst = regs; methodToCall = _methodToCall;);
+
+        //printf("range=%d call=%p count=%d regs=0x%04x\n",
+        //    methodCallRange, methodToCall, count, regs);
+        //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
+        //    methodToCall->name, methodToCall->shorty);
+
+        u4* outs;
+        int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
+
+        /*
+         * Copy args.  This may corrupt vsrc1/vdst.
+         */
+        if (methodCallRange) {
+            // could use memcpy or a "Duff's device"; most functions have
+            // so few args it won't matter much
+            assert(vsrc1 <= curMethod->outsSize);
+            assert(vsrc1 == methodToCall->insSize);
+            outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
+            for (i = 0; i < vsrc1; i++)
+                outs[i] = GET_REGISTER(vdst+i);
+#endif
+        } else {
+            u4 count = vsrc1 >> 4;
+
+            assert(count <= curMethod->outsSize);
+            assert(count == methodToCall->insSize);
+            assert(count <= 5);
+
+            outs = OUTS_FROM_FP(fp, count);
+#if 0
+            if (count == 5) {
+                outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+                count--;
+            }
+            for (i = 0; i < (int) count; i++) {
+                outs[i] = GET_REGISTER(vdst & 0x0f);
+                vdst >>= 4;
+            }
+#else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
+            // This version executes fewer instructions but is larger
+            // overall.  Seems to be a teensy bit faster.
+            switch (count) {
+            case 5:
+                outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+            case 4:
+                outs[3] = GET_REGISTER(vdst >> 12);
+            case 3:
+                outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+            case 2:
+                outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+            case 1:
+                outs[0] = GET_REGISTER(vdst & 0x0f);
+            default:
+                ;
+            }
+#endif /* WITH_TAINT_TRACKING */
+#endif
+        }
+    }
+
+    /*
+     * (This was originally a "goto" target; I've kept it separate from the
+     * stuff above in case we want to refactor things again.)
+     *
+     * At this point, we have the arguments stored in the "outs" area of
+     * the current method's stack frame, and the method to call in
+     * "methodToCall".  Push a new stack frame.
+     */
+    {
+        StackSaveArea* newSaveArea;
+        u4* newFp;
+
+        ILOGV("> %s%s.%s %s",
+            dvmIsNativeMethod(methodToCall) ? "(NATIVE) " : "",
+            methodToCall->clazz->descriptor, methodToCall->name,
+            methodToCall->shorty);
+
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
+        newSaveArea = SAVEAREA_FROM_FP(newFp);
+
+        /* verify that we have enough space */
+        if (true) {
+            u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
+            bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
+            if (bottom < self->interpStackEnd) {
+                /* stack overflow */
+                LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
+                    self->interpStackStart, self->interpStackEnd, bottom,
+                    self->interpStackSize, methodToCall->name);
+                dvmHandleStackOverflow(self);
+                assert(dvmCheckException(self));
+                GOTO_exceptionThrown();
+            }
+            //LOGD("+++ fp=%p newFp=%p newSave=%p bottom=%p\n",
+            //    fp, newFp, newSaveArea, bottom);
+        }
+
+#ifdef LOG_INSTR
+        if (methodToCall->registersSize > methodToCall->insSize) {
+            /*
+             * This makes valgrind quiet when we print registers that
+             * haven't been initialized.  Turn it off when the debug
+             * messages are disabled -- we want valgrind to report any
+             * used-before-initialized issues.
+             */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
+        }
+#endif
+
+#ifdef EASY_GDB
+        newSaveArea->prevSave = SAVEAREA_FROM_FP(fp);
+#endif
+        newSaveArea->prevFrame = fp;
+        newSaveArea->savedPc = pc;
+#if defined(WITH_JIT)
+        newSaveArea->returnAddr = 0;
+#endif
+        newSaveArea->method = methodToCall;
+
+        if (!dvmIsNativeMethod(methodToCall)) {
+            /*
+             * "Call" interpreted code.  Reposition the PC, update the
+             * frame pointer and other local state, and continue.
+             */
+            curMethod = methodToCall;
+            methodClassDex = curMethod->clazz->pDvmDex;
+            pc = methodToCall->insns;
+            fp = self->curFrame = newFp;
+#ifdef EASY_GDB
+            debugSaveArea = SAVEAREA_FROM_FP(newFp);
+#endif
+#if INTERP_TYPE == INTERP_DBG
+            debugIsMethodEntry = true;              // profiling, debugging
+#endif
+            ILOGD("> pc <-- %s.%s %s", curMethod->clazz->descriptor,
+                curMethod->name, curMethod->shorty);
+            DUMP_REGS(curMethod, fp, true);         // show input args
+            FINISH(0);                              // jump to method start
+        } else {
+            /* set this up for JNI locals, even if not a JNI native */
+#ifdef USE_INDIRECT_REF
+            newSaveArea->xtra.localRefCookie = self->jniLocalRefTable.segmentState.all;
+#else
+            newSaveArea->xtra.localRefCookie = self->jniLocalRefTable.nextEntry;
+#endif
+
+            self->curFrame = newFp;
+
+            DUMP_REGS(methodToCall, newFp, true);   // show input args
+
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
+            if (gDvm.debuggerActive) {
+                dvmDbgPostLocationEvent(methodToCall, -1,
+                    dvmGetThisPtr(curMethod, fp), DBG_METHOD_ENTRY);
+            }
+#endif
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_PROFILER)
+            TRACE_METHOD_ENTER(self, methodToCall);
+#endif
+
+            ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
+                methodToCall->name, methodToCall->shorty);
+
+            /*
+             * Jump through native call bridge.  Because we leave no
+             * space for locals on native calls, "newFp" points directly
+             * to the method arguments.
+             */
+            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
+
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
+            if (gDvm.debuggerActive) {
+                dvmDbgPostLocationEvent(methodToCall, -1,
+                    dvmGetThisPtr(curMethod, fp), DBG_METHOD_EXIT);
+            }
+#endif
+#if (INTERP_TYPE == INTERP_DBG) && defined(WITH_PROFILER)
+            TRACE_METHOD_EXIT(self, methodToCall);
+#endif
+
+            /* pop frame off */
+            dvmPopJniLocals(self, newSaveArea);
+            self->curFrame = fp;
+
+            /*
+             * If the native code threw an exception, or interpreted code
+             * invoked by the native call threw one and nobody has cleared
+             * it, jump to our local exception handling.
+             */
+            if (dvmCheckException(self)) {
+                LOGV("Exception thrown by/below native code\n");
+                GOTO_exceptionThrown();
+            }
+
+            ILOGD("> retval=0x%llx (leaving native)", retval.j);
+            ILOGD("> (return from native %s.%s to %s.%s %s)",
+                methodToCall->clazz->descriptor, methodToCall->name,
+                curMethod->clazz->descriptor, curMethod->name,
+                curMethod->shorty);
+
+            //u2 invokeInstr = INST_INST(FETCH(0));
+            if (true /*invokeInstr >= OP_INVOKE_VIRTUAL &&
+                invokeInstr <= OP_INVOKE_INTERFACE*/)
+            {
+                FINISH(3);
+            } else {
+                //LOGE("Unknown invoke instr %02x at %d\n",
+                //    invokeInstr, (int) (pc - curMethod->insns));
+                assert(false);
+            }
+        }
+    }
+    assert(false);      // should not get here
+GOTO_TARGET_END
+
 /* File: cstubs/enddefs.c */
 
 /* undefine "magic" name remapping */
@@ -1196,6 +2597,10 @@ GOTO_TARGET_DECL(exceptionThrown);
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
 /* File: armv5te/debug.c */
 #include <inttypes.h>
 
diff --git a/vm/mterp/out/InterpC-portdbg.c b/vm/mterp/out/InterpC-portdbg.c
index 4b92639..800bce0 100644
--- a/vm/mterp/out/InterpC-portdbg.c
+++ b/vm/mterp/out/InterpC-portdbg.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -555,6 +727,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -580,6 +756,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -589,6 +769,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -615,6 +798,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -656,6 +842,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -691,6 +880,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -705,6 +898,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -738,6 +935,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -772,6 +972,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -787,6 +990,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -818,6 +1024,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -827,6 +1037,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -863,6 +1077,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -877,6 +1095,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -910,6 +1132,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -919,6 +1145,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -932,6 +1162,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -946,6 +1180,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -956,6 +1194,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -965,6 +1207,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -990,6 +1236,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1016,6 +1266,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1060,6 +1315,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1078,6 +1338,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1105,6 +1372,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1123,6 +1394,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1144,6 +1421,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1165,6 +1445,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1467,6 +1751,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
 #endif
     DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex
     JValue retval;
+#ifdef WITH_TAINT_TRACKING
+    Taint rtaint;
+#endif
 
     /* core state */
     const Method* curMethod;    // method we're interpreting
@@ -1511,6 +1798,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
     pc = interpState->pc;
     fp = interpState->fp;
     retval = interpState->retval;   /* only need for kInterpEntryReturn? */
+#ifdef WITH_TAINT_TRACKING
+    rtaint = interpState->rtaint;
+#endif
 
     methodClassDex = curMethod->clazz->pDvmDex;
 
@@ -1572,6 +1862,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1583,6 +1876,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1594,6 +1890,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1606,6 +1905,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1616,6 +1918,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1626,6 +1931,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1638,6 +1946,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1651,6 +1962,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1664,6 +1978,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1675,6 +1992,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1683,6 +2003,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1694,6 +2017,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1704,6 +2030,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1714,6 +2043,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1723,6 +2055,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1731,6 +2066,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1741,6 +2079,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1754,6 +2095,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1764,6 +2108,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1777,6 +2124,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1787,6 +2137,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1796,6 +2149,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1809,6 +2165,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1825,6 +2184,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1835,6 +2197,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1854,6 +2219,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1876,6 +2244,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1896,6 +2267,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2015,6 +2389,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -2033,6 +2410,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -2070,6 +2450,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2107,6 +2490,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2444,6 +2830,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));
         ((u4*) arrayObj->contents)[GET_REGISTER(vsrc2)] =
             GET_REGISTER(vdst);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2852,6 +3243,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2883,6 +3278,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2998,6 +3397,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -3024,6 +3427,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -3039,6 +3446,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3081,6 +3491,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3420,6 +3833,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -4054,6 +4470,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -4064,8 +4483,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -4084,9 +4526,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -4101,6 +4590,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -4122,13 +4612,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
@@ -4150,8 +4650,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -4215,6 +4722,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
             if (gDvm.debuggerActive) {
@@ -4273,6 +4789,9 @@ bail:
     ILOGD("|-- Leaving interpreter loop");      // note "curMethod" may be NULL
 
     interpState->retval = retval;
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     return false;
 
 bail_switch:
@@ -4297,6 +4816,9 @@ bail_switch:
     interpState->fp = fp;
     /* debugTrackedRefStart doesn't change */
     interpState->retval = retval;   /* need for _entryPoint=ret */
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     interpState->nextMode =
         (INTERP_TYPE == INTERP_STD) ? INTERP_DBG : INTERP_STD;
     LOGVV(" meth='%s.%s' pc=0x%x fp=%p\n",
diff --git a/vm/mterp/out/InterpC-portstd.c b/vm/mterp/out/InterpC-portstd.c
index 1db6e87..65fa120 100644
--- a/vm/mterp/out/InterpC-portstd.c
+++ b/vm/mterp/out/InterpC-portstd.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -548,6 +720,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -573,6 +749,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -582,6 +762,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -608,6 +791,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -649,6 +835,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -684,6 +873,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -698,6 +891,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -731,6 +928,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -765,6 +965,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -780,6 +983,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -811,6 +1017,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -820,6 +1030,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -856,6 +1070,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -870,6 +1088,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -903,6 +1125,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -912,6 +1138,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -925,6 +1155,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -939,6 +1173,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -949,6 +1187,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -958,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -983,6 +1229,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1009,6 +1259,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1053,6 +1308,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1071,6 +1331,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1098,6 +1365,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1116,6 +1387,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1137,6 +1414,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1158,6 +1438,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
 #endif
     DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex
     JValue retval;
+#ifdef WITH_TAINT_TRACKING
+    Taint rtaint;
+#endif
 
     /* core state */
     const Method* curMethod;    // method we're interpreting
@@ -1225,6 +1512,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
     pc = interpState->pc;
     fp = interpState->fp;
     retval = interpState->retval;   /* only need for kInterpEntryReturn? */
+#ifdef WITH_TAINT_TRACKING
+    rtaint = interpState->rtaint;
+#endif
 
     methodClassDex = curMethod->clazz->pDvmDex;
 
@@ -1286,6 +1576,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1297,6 +1590,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1308,6 +1604,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1320,6 +1619,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1330,6 +1632,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1340,6 +1645,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1352,6 +1660,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1365,6 +1676,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1378,6 +1692,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1389,6 +1706,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1397,6 +1717,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1408,6 +1731,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1418,6 +1744,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1428,6 +1757,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1437,6 +1769,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1445,6 +1780,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1455,6 +1793,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1468,6 +1809,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1478,6 +1822,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1491,6 +1838,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1501,6 +1851,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1510,6 +1863,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1523,6 +1879,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1539,6 +1898,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1549,6 +1911,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1568,6 +1933,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1590,6 +1958,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1610,6 +1981,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1729,6 +2103,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -1747,6 +2124,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1784,6 +2164,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1821,6 +2204,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2158,6 +2544,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));
         ((u4*) arrayObj->contents)[GET_REGISTER(vsrc2)] =
             GET_REGISTER(vdst);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2566,6 +2957,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2597,6 +2992,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2712,6 +3111,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2738,6 +3141,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2753,6 +3160,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2795,6 +3205,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3134,6 +3547,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -3768,6 +4184,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3778,8 +4197,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -3798,9 +4240,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3815,6 +4304,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -3836,13 +4326,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
@@ -3864,8 +4364,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -3929,6 +4436,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
             if (gDvm.debuggerActive) {
@@ -3987,6 +4503,9 @@ bail:
     ILOGD("|-- Leaving interpreter loop");      // note "curMethod" may be NULL
 
     interpState->retval = retval;
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     return false;
 
 bail_switch:
@@ -4011,6 +4530,9 @@ bail_switch:
     interpState->fp = fp;
     /* debugTrackedRefStart doesn't change */
     interpState->retval = retval;   /* need for _entryPoint=ret */
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     interpState->nextMode =
         (INTERP_TYPE == INTERP_STD) ? INTERP_DBG : INTERP_STD;
     LOGVV(" meth='%s.%s' pc=0x%x fp=%p\n",
diff --git a/vm/mterp/out/InterpC-x86.c b/vm/mterp/out/InterpC-x86.c
index 07536c4..5afc8c3 100644
--- a/vm/mterp/out/InterpC-x86.c
+++ b/vm/mterp/out/InterpC-x86.c
@@ -163,6 +163,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -182,6 +207,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -199,6 +238,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -218,6 +271,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -235,6 +302,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -243,6 +324,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -286,6 +416,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -448,6 +620,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1160,6 +1441,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1181,6 +1465,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1284,6 +1572,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -1918,6 +2209,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -1928,8 +2222,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -1948,9 +2265,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -1965,6 +2329,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -1986,13 +2351,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p size=%d '%s')\n",
@@ -2014,8 +2389,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if 
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -2079,6 +2461,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG) && defined(WITH_DEBUGGER)
             if (gDvm.debuggerActive) {
@@ -2136,3 +2527,7 @@ GOTO_TARGET_END
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
diff --git a/vm/mterp/portable/enddefs.c b/vm/mterp/portable/enddefs.c
index 5ddde3c..eab07a0 100644
--- a/vm/mterp/portable/enddefs.c
+++ b/vm/mterp/portable/enddefs.c
@@ -9,6 +9,9 @@ bail:
     ILOGD("|-- Leaving interpreter loop");      // note "curMethod" may be NULL
 
     interpState->retval = retval;
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     return false;
 
 bail_switch:
@@ -33,6 +36,9 @@ bail_switch:
     interpState->fp = fp;
     /* debugTrackedRefStart doesn't change */
     interpState->retval = retval;   /* need for _entryPoint=ret */
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     interpState->nextMode =
         (INTERP_TYPE == INTERP_STD) ? INTERP_DBG : INTERP_STD;
     LOGVV(" meth='%s.%s' pc=0x%x fp=%p\n",
diff --git a/vm/mterp/portable/entry.c b/vm/mterp/portable/entry.c
index 9c7c2d6..e6f2228 100644
--- a/vm/mterp/portable/entry.c
+++ b/vm/mterp/portable/entry.c
@@ -16,6 +16,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
 #endif
     DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex
     JValue retval;
+#ifdef WITH_TAINT_TRACKING
+    Taint rtaint;
+#endif
 
     /* core state */
     const Method* curMethod;    // method we're interpreting
@@ -60,6 +63,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
     pc = interpState->pc;
     fp = interpState->fp;
     retval = interpState->retval;   /* only need for kInterpEntryReturn? */
+#ifdef WITH_TAINT_TRACKING
+    rtaint = interpState->rtaint;
+#endif
 
     methodClassDex = curMethod->clazz->pDvmDex;
 
diff --git a/vm/native/InternalNative.c b/vm/native/InternalNative.c
index 735cf96..259d012 100644
--- a/vm/native/InternalNative.c
+++ b/vm/native/InternalNative.c
@@ -54,6 +54,9 @@ static DalvikNativeClass gDvmNativeMethodSet[] = {
     { "Ldalvik/system/VMRuntime;",        dvm_dalvik_system_VMRuntime, 0 },
     { "Ldalvik/system/Zygote;",           dvm_dalvik_system_Zygote, 0 },
     { "Ldalvik/system/VMStack;",          dvm_dalvik_system_VMStack, 0 },
+#ifdef WITH_TAINT_TRACKING
+    { "Ldalvik/system/Taint;",            dvm_dalvik_system_Taint, 0 },
+#endif
     { "Lorg/apache/harmony/dalvik/ddmc/DdmServer;",
             dvm_org_apache_harmony_dalvik_ddmc_DdmServer, 0 },
     { "Lorg/apache/harmony/dalvik/ddmc/DdmVmInternal;", 
diff --git a/vm/native/InternalNativePriv.h b/vm/native/InternalNativePriv.h
index abfda6c..80bdf8d 100644
--- a/vm/native/InternalNativePriv.h
+++ b/vm/native/InternalNativePriv.h
@@ -35,6 +35,12 @@
 #define RETURN_FLOAT(_val)      do { pResult->f = (_val); return; } while(0)
 #define RETURN_DOUBLE(_val)     do { pResult->d = (_val); return; } while(0)
 #define RETURN_PTR(_val)        do { pResult->l = (_val); return; } while(0)
+#ifdef WITH_TAINT_TRACKING
+/* use "->i" instead of "->c" and "->b" because interpreter expects 32-bit 
+ * value, as described above */
+#define RETURN_CHAR(_val)       do { pResult->i = (_val); return; } while(0)
+#define RETURN_BYTE(_val)       do { pResult->i = (_val); return; } while(0)
+#endif
 
 
 /*
@@ -113,5 +119,8 @@ extern const DalvikNativeMethod dvm_org_apache_harmony_dalvik_ddmc_DdmServer[];
 extern const DalvikNativeMethod dvm_org_apache_harmony_dalvik_ddmc_DdmVmInternal[];
 extern const DalvikNativeMethod dvm_org_apache_harmony_dalvik_NativeTestTarget[];
 extern const DalvikNativeMethod dvm_sun_misc_Unsafe[];
+#ifdef WITH_TAINT_TRACKING
+extern const DalvikNativeMethod dvm_dalvik_system_Taint[];
+#endif
 
 #endif /*_DALVIK_NATIVE_INTERNALNATIVEPRIV*/
diff --git a/vm/native/dalvik_system_Taint.c b/vm/native/dalvik_system_Taint.c
new file mode 100644
index 0000000..d7da407
--- /dev/null
+++ b/vm/native/dalvik_system_Taint.c
@@ -0,0 +1,743 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+/*
+ * dalvik.system.Taint
+ */
+#include "Dalvik.h"
+#include "native/InternalNativePriv.h"
+#include "attr/xattr.h"
+
+#include <errno.h>
+
+#define TAINT_XATTR_NAME "user.taint"
+
+/*
+ * public static void addTaintString(String str, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintString(const u4* args,
+    JValue* pResult)
+{
+    StringObject *strObj = (StringObject*) args[0];
+    u4 tag = args[1];
+    ArrayObject *value = NULL;
+    
+    if (strObj) {
+	value = (ArrayObject*) dvmGetFieldObject((Object*)strObj,
+				    gDvm.offJavaLangString_value);
+	value->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintObjectArray(Object[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintObjectArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintBooleanArray(boolean[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintBooleanArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintCharArray(char[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintCharArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintByteArray(byte[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintByteArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintIntArray(int[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintIntArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintShortArray(short[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintShortArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintLongArray(long[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintLongArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintFloatArray(float[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintFloatArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static void addTaintDoubleArray(double[] array, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintDoubleArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    u4 tag = args[1];
+    if (arr) {
+	arr->taint.tag |= tag;
+    }
+    RETURN_VOID();
+}
+
+/*
+ * public static boolean addTaintBoolean(boolean val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintBoolean(const u4* args,
+    JValue* pResult)
+{
+    u4 val     = args[0];
+    u4 tag     = args[1];	 /* the tag to add */
+    u4* rtaint = (u4*) &args[2]; /* pointer to return taint tag */
+    u4 vtaint  = args[3];	 /* the existing taint tag on val */
+    *rtaint = (vtaint | tag);
+    RETURN_BOOLEAN(val);
+}
+
+/*
+ * public static char addTaintChar(char val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintChar(const u4* args,
+    JValue* pResult)
+{
+    u4 val     = args[0];
+    u4 tag     = args[1];         /* the tag to add */
+    u4* rtaint = (u4*) &args[2];  /* pointer to return taint tag */
+    u4 vtaint  = args[3];	  /* the existing taint tag on val */
+    *rtaint = (vtaint | tag);
+    RETURN_CHAR(val);
+}
+
+/*
+ * public static char addTaintByte(byte val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintByte(const u4* args,
+    JValue* pResult)
+{
+    u4 val     = args[0];
+    u4 tag     = args[1];         /* the tag to add */
+    u4* rtaint = (u4*) &args[2];  /* pointer to return taint tag */
+    u4 vtaint  = args[3];	  /* the existing taint tag on val */
+    *rtaint = (vtaint | tag);
+    RETURN_BYTE(val);
+}
+
+/*
+ * public static int addTaintInt(int val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintInt(const u4* args,
+    JValue* pResult)
+{
+    u4 val     = args[0];
+    u4 tag     = args[1];	  /* the tag to add */
+    u4* rtaint = (u4*) &args[2];  /* pointer to return taint tag */
+    u4 vtaint  = args[3];	  /* the existing taint tag on val */
+    *rtaint = (vtaint | tag);
+    RETURN_INT(val);
+}
+
+/*
+ * public static long addTaintLong(long val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintLong(const u4* args,
+    JValue* pResult)
+{
+    u8 val;
+    u4 tag     = args[2];	     /* the tag to add */
+    u4* rtaint = (u4*) &args[3];     /* pointer to return taint tag */
+    u4 vtaint  = args[4];	     /* the existing taint tag on val */
+    memcpy(&val, &args[0], 8);	     /* EABI prevents direct store */
+    *rtaint = (vtaint | tag);
+    RETURN_LONG(val);
+}
+
+/*
+ * public static float addTaintFloat(float val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintFloat(const u4* args,
+    JValue* pResult)
+{
+    u4 val     = args[0];
+    u4 tag     = args[1];	  /* the tag to add */
+    u4* rtaint = (u4*) &args[2];  /* pointer to return taint tag */
+    u4 vtaint  = args[3];	  /* the existing taint tag on val */
+    *rtaint = (vtaint | tag);
+    RETURN_INT(val);		  /* Be opaque; RETURN_FLOAT doesn't work */
+}
+
+/*
+ * public static double addTaintDouble(double val, int tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintDouble(const u4* args,
+    JValue* pResult)
+{
+    u8 val;
+    u4 tag     = args[2];	     /* the tag to add */
+    u4* rtaint = (u4*) &args[3];     /* pointer to return taint tag */
+    u4 vtaint  = args[4];	     /* the existing taint tag on val */
+    memcpy(&val, &args[0], 8);	     /* EABI prevents direct store */
+    *rtaint = (vtaint | tag);
+    RETURN_LONG(val);		     /* Be opaque; RETURN_DOUBLE doesn't work */
+}
+
+/*
+ * public static int getTaintString(String str)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintString(const u4* args,
+    JValue* pResult)
+{
+    StringObject *strObj = (StringObject*) args[0];
+    ArrayObject *value = NULL;
+
+    if (strObj) {
+	value = (ArrayObject*) dvmGetFieldObject((Object*)strObj,
+				    gDvm.offJavaLangString_value);
+	RETURN_INT(value->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintObjectArray(Object[] obj)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintObjectArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintBooleanArray(boolean[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintBooleanArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintCharArray(char[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintCharArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintByteArray(byte[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintByteArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintIntArray(int[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintIntArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintShortArray(short[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintShortArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintLongArray(long[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintLongArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintFloatArray(float[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintFloatArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else {
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintDoubleArray(double[] array)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintDoubleArray(const u4* args,
+    JValue* pResult)
+{
+    ArrayObject *arr = (ArrayObject *) args[0];
+    if (arr) {
+	RETURN_INT(arr->taint.tag);
+    } else{ 
+	RETURN_INT(TAINT_CLEAR);
+    }
+}
+
+/*
+ * public static int getTaintBoolean(boolean val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintBoolean(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintChar(char val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintChar(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintByte(byte val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintByte(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintInt(int val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintInt(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintLong(long val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintLong(const u4* args,
+    JValue* pResult)
+{
+    // args[0:1] = the value
+    // args[2] = the return taint
+    u4 tag = args[3]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintFloat(float val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintFloat(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintDouble(long val)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintDouble(const u4* args,
+    JValue* pResult)
+{
+    // args[0:1] = the value
+    // args[2] = the return taint
+    u4 tag = args[3]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int getTaintRef(Object obj)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintRef(const u4* args,
+    JValue* pResult)
+{
+    // args[0] = the value
+    // args[1] = the return taint
+    u4 tag = args[2]; /* the existing taint */
+    RETURN_INT(tag);
+}
+
+static u4 getTaintXattr(int fd)
+{
+    int ret;
+    u4 buf;
+    u4 tag = TAINT_CLEAR;
+
+    ret = fgetxattr(fd, TAINT_XATTR_NAME, &buf, sizeof(buf)); 
+    if (ret > 0) {
+	tag = buf;
+    } else {
+	if (errno == ENOATTR) {
+	    /* do nothing */
+	} else if (errno == ERANGE) {
+	    LOGW("TaintLog: fgetxattr(%d) contents to large", fd);
+	} else if (errno == ENOTSUP) {
+	    /* XATTRs are not supported. No need to spam the logs */
+	} else {
+	    LOGW("TaintLog: fgetxattr(%d): unknown error code %d", fd, errno);
+	}
+    }
+
+    return tag;
+}
+
+static void setTaintXattr(int fd, u4 tag)
+{
+    int ret;
+
+    ret = fsetxattr(fd, TAINT_XATTR_NAME, &tag, sizeof(tag), 0);
+
+    if (ret < 0) {
+	if (errno == ENOSPC || errno == EDQUOT) {
+	    LOGW("TaintLog: fsetxattr(%d): not enough room to set xattr", fd);
+	} else if (errno == ENOTSUP) {
+	    /* XATTRs are not supported. No need to spam the logs */
+	} else {
+	    LOGW("TaintLog: fsetxattr(%d): unknown error code %d", fd, errno);
+	}
+    }
+
+}
+
+/*
+ * public static int getTaintFile(int fd)
+ */
+static void Dalvik_dalvik_system_Taint_getTaintFile(const u4* args,
+    JValue* pResult)
+{
+    u4 tag;
+    int fd = (int)args[0]; // args[0] = the file descriptor
+    // args[1] = the return taint
+    // args[2] = fd taint
+  
+    tag = getTaintXattr(fd);
+
+    if (tag) {
+	LOGI("TaintLog: getTaintFile(%d) = 0x%08x", fd, tag);
+    }
+   
+    RETURN_INT(tag);
+}
+
+/*
+ * public static int addTaintFile(int fd, u4 tag)
+ */
+static void Dalvik_dalvik_system_Taint_addTaintFile(const u4* args,
+    JValue* pResult)
+{
+    u4 otag;
+    int fd = (int)args[0]; // args[0] = the file descriptor
+    u4 tag = args[1];      // args[1] = the taint tag
+    // args[2] = the return taint
+    // args[3] = fd taint
+    // args[4] = tag taint
+    
+    otag = getTaintXattr(fd);
+
+    if (tag) {
+	LOGI("TaintLog: addTaintFile(%d): adding 0x%08x to 0x%08x = 0x%08x",
+		fd, tag, otag, tag | otag);
+    }
+
+    setTaintXattr(fd, tag | otag);
+
+    RETURN_VOID();
+}
+
+/*
+ * public static void log(String msg)
+ */
+static void Dalvik_dalvik_system_Taint_log(const u4* args,
+    JValue* pResult)
+{
+    StringObject* msgObj = (StringObject*) args[0];
+    char *msg;
+
+    if (msgObj == NULL) {
+	dvmThrowException("Ljava/lang/NullPointerException;", NULL);
+	RETURN_VOID();
+    }
+
+    msg = dvmCreateCstrFromString(msgObj);
+    LOGW("TaintLog: %s", msg);
+    free(msg);
+
+    RETURN_VOID();
+}
+
+/*
+ * public static void logPathFromFd(int fd)
+ */
+static void Dalvik_dalvik_system_Taint_logPathFromFd(const u4* args,
+    JValue* pResult)
+{
+    int fd = (int) args[0];
+    pid_t pid;
+    char ppath[20]; // these path lengths should be enough
+    char rpath[80];
+    int err;
+
+
+    pid = getpid();
+    snprintf(ppath, 20, "/proc/%d/fd/%d", pid, fd);
+    err = readlink(ppath, rpath, 80);
+    if (err >= 0) {
+	LOGW("TaintLog: fd %d -> %s", fd, rpath);
+    } else {
+	LOGW("TaintLog: error finding path for fd %d", fd);
+    }
+
+    RETURN_VOID();
+}
+
+/*
+ * public static void logPeerFromFd(int fd)
+ */
+static void Dalvik_dalvik_system_Taint_logPeerFromFd(const u4* args,
+    JValue* pResult)
+{
+    int fd = (int) args[0];
+
+    LOGW("TaintLog: logPeerFromFd not yet implemented");
+
+    RETURN_VOID();
+}
+
+const DalvikNativeMethod dvm_dalvik_system_Taint[] = {
+    { "addTaintString",  "(Ljava/lang/String;I)V",
+        Dalvik_dalvik_system_Taint_addTaintString},
+    { "addTaintObjectArray",  "([Ljava/lang/Object;I)V",
+        Dalvik_dalvik_system_Taint_addTaintObjectArray},
+    { "addTaintBooleanArray",  "([ZI)V",
+        Dalvik_dalvik_system_Taint_addTaintBooleanArray},
+    { "addTaintCharArray",  "([CI)V",
+        Dalvik_dalvik_system_Taint_addTaintCharArray},
+    { "addTaintByteArray",  "([BI)V",
+        Dalvik_dalvik_system_Taint_addTaintByteArray},
+    { "addTaintIntArray",  "([II)V",
+        Dalvik_dalvik_system_Taint_addTaintIntArray},
+    { "addTaintShortArray",  "([SI)V",
+        Dalvik_dalvik_system_Taint_addTaintShortArray},
+    { "addTaintLongArray",  "([JI)V",
+        Dalvik_dalvik_system_Taint_addTaintLongArray},
+    { "addTaintFloatArray",  "([FI)V",
+        Dalvik_dalvik_system_Taint_addTaintFloatArray},
+    { "addTaintDoubleArray",  "([DI)V",
+        Dalvik_dalvik_system_Taint_addTaintDoubleArray},
+    { "addTaintBoolean",  "(ZI)Z",
+        Dalvik_dalvik_system_Taint_addTaintBoolean},
+    { "addTaintChar",  "(CI)C",
+        Dalvik_dalvik_system_Taint_addTaintChar},
+    { "addTaintByte",  "(BI)B",
+        Dalvik_dalvik_system_Taint_addTaintByte},
+    { "addTaintInt",  "(II)I",
+        Dalvik_dalvik_system_Taint_addTaintInt},
+    { "addTaintLong",  "(JI)J",
+        Dalvik_dalvik_system_Taint_addTaintLong},
+    { "addTaintFloat",  "(FI)F",
+        Dalvik_dalvik_system_Taint_addTaintFloat},
+    { "addTaintDouble",  "(DI)D",
+        Dalvik_dalvik_system_Taint_addTaintDouble},
+    { "getTaintString",  "(Ljava/lang/String;)I",
+        Dalvik_dalvik_system_Taint_getTaintString},
+    { "getTaintObjectArray",  "([Ljava/lang/Object;)I",
+        Dalvik_dalvik_system_Taint_getTaintObjectArray},
+    { "getTaintBooleanArray",  "([Z)I",
+        Dalvik_dalvik_system_Taint_getTaintBooleanArray},
+    { "getTaintCharArray",  "([C)I",
+        Dalvik_dalvik_system_Taint_getTaintCharArray},
+    { "getTaintByteArray",  "([B)I",
+        Dalvik_dalvik_system_Taint_getTaintByteArray},
+    { "getTaintIntArray",  "([I)I",
+        Dalvik_dalvik_system_Taint_getTaintIntArray},
+    { "getTaintShortArray",  "([S)I",
+        Dalvik_dalvik_system_Taint_getTaintShortArray},
+    { "getTaintLongArray",  "([J)I",
+        Dalvik_dalvik_system_Taint_getTaintLongArray},
+    { "getTaintFloatArray",  "([F)I",
+        Dalvik_dalvik_system_Taint_getTaintFloatArray},
+    { "getTaintDoubleArray",  "([D)I",
+        Dalvik_dalvik_system_Taint_getTaintDoubleArray},
+    { "getTaintBoolean",  "(Z)I",
+        Dalvik_dalvik_system_Taint_getTaintBoolean},
+    { "getTaintChar",  "(C)I",
+        Dalvik_dalvik_system_Taint_getTaintChar},
+    { "getTaintByte",  "(B)I",
+        Dalvik_dalvik_system_Taint_getTaintByte},
+    { "getTaintInt",  "(I)I",
+        Dalvik_dalvik_system_Taint_getTaintInt},
+    { "getTaintLong",  "(J)I",
+        Dalvik_dalvik_system_Taint_getTaintLong},
+    { "getTaintFloat",  "(F)I",
+        Dalvik_dalvik_system_Taint_getTaintFloat},
+    { "getTaintDouble",  "(D)I",
+        Dalvik_dalvik_system_Taint_getTaintDouble},
+    { "getTaintRef",  "(Ljava/lang/Object;)I",
+        Dalvik_dalvik_system_Taint_getTaintRef},
+    { "getTaintFile",  "(I)I",
+        Dalvik_dalvik_system_Taint_getTaintFile},
+    { "addTaintFile",  "(II)V",
+        Dalvik_dalvik_system_Taint_addTaintFile},
+    { "log",  "(Ljava/lang/String;)V",
+        Dalvik_dalvik_system_Taint_log},
+    { "logPathFromFd",  "(I)V",
+        Dalvik_dalvik_system_Taint_logPathFromFd},
+    { "logPeerFromFd",  "(I)V",
+        Dalvik_dalvik_system_Taint_logPeerFromFd},
+    { NULL, NULL, NULL },
+};
diff --git a/vm/native/java_lang_System.c b/vm/native/java_lang_System.c
index b26a368..ea18581 100644
--- a/vm/native/java_lang_System.c
+++ b/vm/native/java_lang_System.c
@@ -122,6 +122,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
         (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                 (const u1*)srcArray->contents + srcPos * width,
                 length * width);
+#ifdef WITH_TAINT_TRACKING
+	if (dstPos == 0 && dstArray->length == length) {
+	    /* entire array replaced */
+	    dstArray->taint.tag = srcArray->taint.tag;
+	} else {
+	    dstArray->taint.tag |= srcArray->taint.tag;
+	}
+#endif
     } else {
         /*
          * Neither class is primitive.  See if elements in "src" are instances
@@ -143,6 +151,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
             (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                     (const u1*)srcArray->contents + srcPos * width,
                     length * width);
+#ifdef WITH_TAINT_TRACKING
+	    if (dstPos == 0 && dstArray->length == length) {
+		/* entire array replaced */
+		dstArray->taint.tag = srcArray->taint.tag;
+	    } else {
+		dstArray->taint.tag |= srcArray->taint.tag;
+	    }
+#endif
         } else {
             /*
              * The arrays are not fundamentally compatible.  However, we may
@@ -189,6 +205,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
             (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                     (const u1*)srcArray->contents + srcPos * width,
                     copyCount * width);
+#ifdef WITH_TAINT_TRACKING
+	    if (dstPos == 0 && dstArray->length == length) {
+		/* entire array replaced */
+		dstArray->taint.tag = srcArray->taint.tag;
+	    } else {
+		dstArray->taint.tag |= srcArray->taint.tag;
+	    }
+#endif
 
             if (copyCount != length) {
                 dvmThrowException("Ljava/lang/ArrayStoreException;", NULL);
diff --git a/vm/native/java_lang_reflect_Field.c b/vm/native/java_lang_reflect_Field.c
index 72f4c65..ae8d86c 100644
--- a/vm/native/java_lang_reflect_Field.c
+++ b/vm/native/java_lang_reflect_Field.c
@@ -169,6 +169,9 @@ static void Dalvik_java_lang_reflect_Field_getField(const u4* args,
     ClassObject* fieldType = (ClassObject*) args[3];
     int slot = args[4];
     bool noAccessCheck = (args[5] != 0);
+#ifdef WITH_TAINT_TRACKING
+    u4* rtaint = (u4*) &args[6]; /* return taint tag slot */
+#endif
     JValue value;
     const JValue* fieldPtr;
     DataObject* result;
@@ -191,6 +194,31 @@ static void Dalvik_java_lang_reflect_Field_getField(const u4* args,
 
     result = dvmWrapPrimitive(value, fieldType);
     dvmReleaseTrackedAlloc((Object*) result, NULL);
+
+#ifdef WITH_TAINT_TRACKING
+    /* If we got this far, we know the fields is okay to access and there
+     * will not be a problem getting the field from the slot */
+    {
+	Field* field = dvmSlotToField(declaringClass, slot);
+	assert(field != NULL);
+	if (dvmIsStaticField(field)) {
+	    StaticField* sfield = (StaticField*)field;
+	    *rtaint = dvmGetStaticFieldTaint(sfield);
+	} else {
+	    /* Note, getFieldDataAddr() already checked that 
+	     * obj is of type declaringClass, so no need to check here
+	     */
+	    InstField* ifield = (InstField*)field;
+	    if (fieldType->primitiveType == PRIM_LONG ||
+		fieldType->primitiveType == PRIM_DOUBLE) {
+		*rtaint = dvmGetFieldTaintWide(obj, ifield->byteOffset);
+	    } else {
+		*rtaint = dvmGetFieldTaint(obj, ifield->byteOffset);
+	    }
+	}
+    }
+#endif
+
     RETURN_PTR(result);
 }
 
@@ -211,6 +239,17 @@ static void Dalvik_java_lang_reflect_Field_setField(const u4* args,
     int slot = args[4];
     bool noAccessCheck = (args[5] != 0);
     Object* valueObj = (Object*) args[6];
+#ifdef WITH_TAINT_TRACKING
+    /* rtaint = args[7]
+     * thisPtr taint = args[8]
+     * obj taint = args[9]
+     * declaringClass taint = args[10]
+     * fieldType taint = args[11]
+     * slot taint = args[12]
+     * noAccessCheck taint = args[13]
+     */
+    u4 valueTaint = args[14];
+#endif
     JValue* fieldPtr;
     JValue value;
 
@@ -235,6 +274,30 @@ static void Dalvik_java_lang_reflect_Field_setField(const u4* args,
         fieldPtr->i = value.i;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* If we got this far, we know the fields is okay to access and there
+     * will not be a problem getting the field from the slot */
+    {
+	Field* field = dvmSlotToField(declaringClass, slot);
+	assert(field != NULL);
+	if (dvmIsStaticField(field)) {
+	    StaticField* sfield = (StaticField*)field;
+	    dvmSetStaticFieldTaint(sfield, valueTaint);
+	} else {
+	    /* Note, getFieldDataAddr() already checked that 
+	     * obj is of type declaringClass, so no need to check here
+	     */
+	    InstField* ifield = (InstField*)field;
+	    if (fieldType->primitiveType == PRIM_LONG ||
+		fieldType->primitiveType == PRIM_DOUBLE) {
+		dvmSetFieldTaintWide(obj, ifield->byteOffset, valueTaint);
+	    } else {
+		dvmSetFieldTaint(obj, ifield->byteOffset, valueTaint);
+	    }
+	}
+    }
+#endif
+
     RETURN_VOID();
 }
 
@@ -270,6 +333,9 @@ static void Dalvik_java_lang_reflect_Field_getPrimitiveField(const u4* args,
     int slot = args[4];
     bool noAccessCheck = (args[5] != 0);
     int typeNum = args[6];
+#ifdef WITH_TAINT_TRACKING
+    u4* rtaint = (u4*) &args[7]; /* return taint tag slot */
+#endif
     PrimitiveType targetType = convPrimType(typeNum);
     const JValue* fieldPtr;
     JValue value;
@@ -302,6 +368,30 @@ static void Dalvik_java_lang_reflect_Field_getPrimitiveField(const u4* args,
             "invalid primitive conversion");
         RETURN_VOID();
     }
+
+#ifdef WITH_TAINT_TRACKING
+    /* If we got this far, we know the fields is okay to access and there
+     * will not be a problem getting the field from the slot */
+    {
+	Field* field = dvmSlotToField(declaringClass, slot);
+	assert(field != NULL);
+	if (dvmIsStaticField(field)) {
+	    StaticField* sfield = (StaticField*)field;
+	    *rtaint = dvmGetStaticFieldTaint(sfield);
+	} else {
+	    /* Note, getFieldDataAddr() already checked that 
+	     * obj is of type declaringClass, so no need to check here
+	     */
+	    InstField* ifield = (InstField*)field;
+	    if (fieldType->primitiveType == PRIM_LONG ||
+		fieldType->primitiveType == PRIM_DOUBLE) {
+		*rtaint = dvmGetFieldTaintWide(obj, ifield->byteOffset);
+	    } else {
+		*rtaint = dvmGetFieldTaint(obj, ifield->byteOffset);
+	    }
+	}
+    }
+#endif
 }
 
 /*
@@ -322,6 +412,18 @@ static void Dalvik_java_lang_reflect_Field_setPrimitiveField(const u4* args,
     bool noAccessCheck = (args[5] != 0);
     int typeNum = args[6];
     const s4* valuePtr = (s4*) &args[7];
+#ifdef WITH_TAINT_TRACKING
+    /* rtaint = args[8]
+     * thisPtr taint = args[9]
+     * obj taint = args[10]
+     * declaringClass taint = args[11]
+     * fieldType taint = args[12]
+     * slot taint = args[13]
+     * noAccessCheck taint = args[14]
+     * typeNum taint = args[15]
+     */
+    u4 valueTaint = args[16];
+#endif
     PrimitiveType srcType = convPrimType(typeNum);
     JValue* fieldPtr;
     JValue value;
@@ -355,6 +457,30 @@ static void Dalvik_java_lang_reflect_Field_setPrimitiveField(const u4* args,
         fieldPtr->i = value.i;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* If we got this far, we know the fields is okay to access and there
+     * will not be a problem getting the field from the slot */
+    {
+	Field* field = dvmSlotToField(declaringClass, slot);
+	assert(field != NULL);
+	if (dvmIsStaticField(field)) {
+	    StaticField* sfield = (StaticField*)field;
+	    dvmSetStaticFieldTaint(sfield, valueTaint);
+	} else {
+	    /* Note, getFieldDataAddr() already checked that 
+	     * obj is of type declaringClass, so no need to check here
+	     */
+	    InstField* ifield = (InstField*)field;
+	    if (fieldType->primitiveType == PRIM_LONG ||
+		fieldType->primitiveType == PRIM_DOUBLE) {
+		dvmSetFieldTaintWide(obj, ifield->byteOffset, valueTaint);
+	    } else {
+		dvmSetFieldTaint(obj, ifield->byteOffset, valueTaint);
+	    }
+	}
+    }
+#endif
+
     RETURN_VOID();
 }
 
diff --git a/vm/oo/Array.c b/vm/oo/Array.c
index 19a0f96..ddee081 100644
--- a/vm/oo/Array.c
+++ b/vm/oo/Array.c
@@ -63,6 +63,9 @@ ArrayObject* dvmAllocArray(ClassObject* arrayClass, size_t length,
     if (newArray != NULL) {
         DVM_OBJECT_INIT(&newArray->obj, arrayClass);
         newArray->length = length;
+#ifdef WITH_TAINT_TRACKING
+	newArray->taint.tag = TAINT_CLEAR;
+#endif
         LOGVV("AllocArray: %s [%d] (%d)\n",
             arrayClass->descriptor, (int) length, (int) size);
 #if WITH_HPROF && WITH_HPROF_STACK
diff --git a/vm/oo/Class.c b/vm/oo/Class.c
index 1bde718..182d29f 100644
--- a/vm/oo/Class.c
+++ b/vm/oo/Class.c
@@ -2259,6 +2259,9 @@ static void loadSFieldFromDex(ClassObject* clazz,
 #ifdef PROFILE_FIELD_ACCESS
     sfield->field.gets = sfield->field.puts = 0;
 #endif
+#ifdef WITH_TAINT_TRACKING
+    sfield->taint.tag = TAINT_CLEAR;
+#endif
 }
 
 /*
@@ -3551,7 +3554,11 @@ static bool computeFieldOffsets(ClassObject* clazz)
             break;
 
         pField->byteOffset = fieldOffset;
+#ifdef WITH_TAINT_TRACKING
+        fieldOffset += sizeof(u4) + sizeof(u4); /* interleaved tag */
+#else
         fieldOffset += sizeof(u4);
+#endif
         LOGVV("  --- offset1 '%s'=%d\n", pField->field.name,pField->byteOffset);
     }
 
@@ -3563,6 +3570,11 @@ static bool computeFieldOffsets(ClassObject* clazz)
     if (i != clazz->ifieldCount && (fieldOffset & 0x04) != 0) {
         LOGVV("  +++ not aligned\n");
 
+#ifdef WITH_TAINT_TRACKING
+	/* Technically, this never occurs, but it doesn't hurt to add */
+	LOGV("  +++ inserting pad field in '%s'\n", clazz->descriptor);
+	fieldOffset += sizeof(u4);
+#else
         InstField* pField = &clazz->ifields[i];
         char c = pField->field.signature[0];
 
@@ -3606,6 +3618,7 @@ static bool computeFieldOffsets(ClassObject* clazz)
                 fieldOffset += sizeof(u4);
             }
         }
+#endif /* ndef WITH_TAINT_TRACKING */
     }
 
     /*
@@ -3648,9 +3661,15 @@ static bool computeFieldOffsets(ClassObject* clazz)
 
         pField->byteOffset = fieldOffset;
         LOGVV("  --- offset4 '%s'=%d\n", pField->field.name,pField->byteOffset);
+#ifdef WITH_TAINT_TRACKING
+        fieldOffset += sizeof(u4) + sizeof(u4); /* room for tag */
+        if (c == 'J' || c == 'D')
+            fieldOffset += sizeof(u4) + sizeof(u4); /* keep 64-bit aligned */
+#else
         fieldOffset += sizeof(u4);
         if (c == 'J' || c == 'D')
             fieldOffset += sizeof(u4);
+#endif /* ndef WITH_TAINT_TRACKING */
     }
 
 #ifndef NDEBUG
diff --git a/vm/oo/Object.h b/vm/oo/Object.h
index 3e724f4..efcbdad 100644
--- a/vm/oo/Object.h
+++ b/vm/oo/Object.h
@@ -23,6 +23,10 @@
 
 #include <stddef.h>
 
+#ifdef WITH_TAINT_TRACKING
+#include "interp/Taint.h"
+#endif
+
 /* fwd decl */
 struct DataObject;
 struct InitiatingLoaderList;
@@ -285,6 +289,10 @@ struct ArrayObject {
     /* number of elements; immutable after init */
     u4              length;
 
+#ifdef WITH_TAINT_TRACKING
+    Taint           taint;
+#endif
+
     /*
      * Array contents; actual size is (length * sizeof(type)).  This is
      * declared as u8 so that the compiler inserts any necessary padding
@@ -569,6 +577,9 @@ struct Field {
 struct StaticField {
     Field           field;          /* MUST be first item */
     JValue          value;          /* initially set from DEX for primitives */
+#ifdef WITH_TAINT_TRACKING
+    Taint           taint;
+#endif
 };
 
 /*
@@ -706,6 +717,36 @@ INLINE Object* dvmGetFieldObject(const Object* obj, int offset) {
     return ((JValue*)BYTE_OFFSET(obj, offset))->l;
 }
 
+#ifdef WITH_TAINT_TRACKING
+INLINE u4 dvmGetFieldTaint(const Object* obj, int offset) {
+    return (*(u4*)BYTE_OFFSET(obj, offset+sizeof(u4)));
+}
+INLINE u4 dvmGetFieldTaintWide(const Object* obj, int offset) {
+    return (*(u4*)BYTE_OFFSET(obj, offset+sizeof(u4)+sizeof(u4)));
+}
+#define dvmGetFieldTaintBoolean(_obj, _offset) dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintByte(_obj, _offset)    dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintShort(_obj, _offset)   dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintChar(_obj, _offset)    dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintInt(_obj, _offset)     dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintLong(_obj, _offset)    dvmGetFieldTaintWide(_obj, _offset)
+#define dvmGetFieldTaintFloat(_obj, _offset)   dvmGetFieldTaint(_obj, _offset)
+#define dvmGetFieldTaintDouble(_obj, _offset)  dvmGetFieldTaintWide(_obj, _offset)
+#define dvmGetFieldTaintObject(_obj, _offset)  dvmGetFieldTaint(_obj, _offset)
+#else
+#define dvmGetFieldTaint(_obj, _offset)        ((void)0)
+#define dvmGetFieldTaintWide(_obj, _offset)    ((void)0)
+#define dvmGetFieldTaintBoolean(_obj, _offset) ((void)0)
+#define dvmGetFieldTaintByte(_obj, _offset)    ((void)0)
+#define dvmGetFieldTaintShort(_obj, _offset)   ((void)0)
+#define dvmGetFieldTaintChar(_obj, _offset)    ((void)0)
+#define dvmGetFieldTaintInt(_obj, _offset)     ((void)0)
+#define dvmGetFieldTaintLong(_obj, _offset)    ((void)0)
+#define dvmGetFieldTaintFloat(_obj, _offset)   ((void)0)
+#define dvmGetFieldTaintDouble(_obj, _offset)  ((void)0)
+#define dvmGetFieldTaintObject(_obj, _offset)  ((void)0)
+#endif
+
 INLINE void dvmSetFieldBoolean(Object* obj, int offset, bool val) {
     ((JValue*)BYTE_OFFSET(obj, offset))->i = val;
 }
@@ -734,6 +775,36 @@ INLINE void dvmSetFieldObject(Object* obj, int offset, Object* val) {
     ((JValue*)BYTE_OFFSET(obj, offset))->l = val;
 }
 
+#ifdef WITH_TAINT_TRACKING
+INLINE void dvmSetFieldTaint(Object* obj, int offset, u4 tag) {
+    (*(u4*)BYTE_OFFSET(obj, offset+sizeof(u4))) = tag;
+}
+INLINE void dvmSetFieldTaintWide(Object* obj, int offset, u4 tag) {
+    (*(u4*)BYTE_OFFSET(obj, offset+sizeof(u4)+sizeof(u4))) = tag;
+}
+#define dvmSetFieldTaintBoolean(_obj, _offset, _tag) dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintByte(_obj, _offset, _tag)    dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintShort(_obj, _offset, _tag)   dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintChar(_obj, _offset, _tag)    dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintInt(_obj, _offset, _tag)     dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintLong(_obj, _offset, _tag)    dvmSetFieldTaintWide(_obj, _offset, _tag)
+#define dvmSetFieldTaintFloat(_obj, _offset, _tag)   dvmSetFieldTaint(_obj, _offset, _tag)
+#define dvmSetFieldTaintDouble(_obj, _offset, _tag)  dvmSetFieldTaintWide(_obj, _offset, _tag)
+#define dvmSetFieldTaintObject(_obj, _offset, _tag)  dvmSetFieldTaint(_obj, _offset, _tag)
+#else
+#define dvmSetFieldTaint(_obj, _offset, _tag)        ((void)0)
+#define dvmSetFieldTaintWide(_obj, _offset, _tag)    ((void)0)
+#define dvmSetFieldTaintBoolean(_obj, _offset, _tag) ((void)0)
+#define dvmSetFieldTaintByte(_obj, _offset, _tag)    ((void)0)
+#define dvmSetFieldTaintShort(_obj, _offset, _tag)   ((void)0)
+#define dvmSetFieldTaintChar(_obj, _offset, _tag)    ((void)0)
+#define dvmSetFieldTaintInt(_obj, _offset, _tag)     ((void)0)
+#define dvmSetFieldTaintLong(_obj, _offset, _tag)    ((void)0)
+#define dvmSetFieldTaintFloat(_obj, _offset, _tag)   ((void)0)
+#define dvmSetFieldTaintDouble(_obj, _offset, _tag)  ((void)0)
+#define dvmSetFieldTaintObject(_obj, _offset, _tag)  ((void)0)
+#endif
+
 /*
  * Static field access functions.
  */
@@ -769,6 +840,32 @@ INLINE Object* dvmGetStaticFieldObject(const StaticField* sfield) {
     return sfield->value.l;
 }
 
+#ifdef WITH_TAINT_TRACKING
+INLINE u4 dvmGetStaticFieldTaint(const StaticField* sfield) {
+    return sfield->taint.tag;
+}
+#define dvmGetStaticFieldTaintBoolean(_sfield) dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintByte(_sfield)    dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintShort(_sfield)   dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintChar(_sfield)    dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintInt(_sfield)     dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintLong(_sfield)    dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintFloat(_sfield)   dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintDouble(_sfield)  dvmGetStaticFieldTaint(_sfield)
+#define dvmGetStaticFieldTaintObject(_sfield)  dvmGetStaticFieldTaint(_sfield)
+#else
+#define dvmGetStaticFieldTaint(_sfield)        ((void)0)
+#define dvmGetStaticFieldTaintBoolean(_sfield) ((void)0)
+#define dvmGetStaticFieldTaintByte(_sfield)    ((void)0)
+#define dvmGetStaticFieldTaintShort(_sfield)   ((void)0)
+#define dvmGetStaticFieldTaintChar(_sfield)    ((void)0)
+#define dvmGetStaticFieldTaintInt(_sfield)     ((void)0)
+#define dvmGetStaticFieldTaintLong(_sfield)    ((void)0)
+#define dvmGetStaticFieldTaintFloat(_sfield)   ((void)0)
+#define dvmGetStaticFieldTaintDouble(_sfield)  ((void)0)
+#define dvmGetStaticFieldTaintObject(_sfield)  ((void)0)
+#endif
+
 INLINE void dvmSetStaticFieldBoolean(StaticField* sfield, bool val) {
     sfield->value.i = val;
 }
@@ -797,6 +894,32 @@ INLINE void dvmSetStaticFieldObject(StaticField* sfield, Object* val) {
     sfield->value.l = val;
 }
 
+#ifdef WITH_TAINT_TRACKING
+INLINE void dvmSetStaticFieldTaint(StaticField* sfield, u4 tag) {
+    sfield->taint.tag = tag;
+}
+#define dvmSetStaticFieldTaintBoolean(_sfield, _tag) dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintByte(_sfield, _tag)    dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintShort(_sfield, _tag)   dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintChar(_sfield, _tag)    dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintInt(_sfield, _tag)     dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintLong(_sfield, _tag)    dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintFloat(_sfield, _tag)   dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintDouble(_sfield, _tag)  dvmSetStaticFieldTaint(_sfield, _tag)
+#define dvmSetStaticFieldTaintObject(_sfield, _tag)  dvmSetStaticFieldTaint(_sfield, _tag)
+#else
+#define dvmSetStaticFieldTaint(_sfield, _tag)        ((void)0)
+#define dvmSetStaticFieldTaintBoolean(_sfield, _tag) ((void)0)
+#define dvmSetStaticFieldTaintByte(_sfield, _tag)    ((void)0)
+#define dvmSetStaticFieldTaintShort(_sfield, _tag)   ((void)0)
+#define dvmSetStaticFieldTaintChar(_sfield, _tag)    ((void)0)
+#define dvmSetStaticFieldTaintInt(_sfield, _tag)     ((void)0)
+#define dvmSetStaticFieldTaintLong(_sfield, _tag)    ((void)0)
+#define dvmSetStaticFieldTaintFloat(_sfield, _tag)   ((void)0)
+#define dvmSetStaticFieldTaintDouble(_sfield, _tag)  ((void)0)
+#define dvmSetStaticFieldTaintObject(_sfield, _tag)  ((void)0)
+#endif
+
 /*
  * Helpers.
  */
diff --git a/vm/reflect/Reflect.c b/vm/reflect/Reflect.c
index 2e3c549..67f0c63 100644
--- a/vm/reflect/Reflect.c
+++ b/vm/reflect/Reflect.c
@@ -1016,6 +1016,69 @@ int dvmConvertArgument(DataObject* arg, ClassObject* type, s4* destPtr)
     return retVal;
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* Returns the width corresponding to a type
+ * returns -1 if type isn't a primitive type
+ */
+int getTypeWidth(PrimitiveType type) 
+{
+    int width = -1;
+
+    switch (type) {
+	case PRIM_BOOLEAN:
+	case PRIM_CHAR:
+	case PRIM_FLOAT:
+	case PRIM_BYTE:
+	case PRIM_SHORT:
+	case PRIM_INT:
+	    width = 1;
+	    break;
+	case PRIM_DOUBLE:
+	case PRIM_LONG:
+	    width = 2;
+	    break;
+	default:
+	    break;
+    }
+
+    return width;
+}
+
+/* Returns the taint tag for a boxed primitive.
+ * If the object is not a boxed primitive, TAINT_CLEAR
+ * is returned
+ */
+u4 dvmGetPrimitiveTaint(DataObject* arg, ClassObject* type)
+{
+    u4 tag = TAINT_CLEAR;
+    int width = getTypeWidth(type->primitiveType);
+
+    if (width > 0) { /* non-primitives have width -1 */
+	/* the tag is store right after the variable */
+	/* see dvmConvertArgument(): for primitives, the value is first */
+	tag = *(u4*)(arg->instanceData+width);
+
+    } /* else, don't worry about it */
+
+    return tag;
+}
+
+/* Set the taint tag for a boxed primitive.
+ * If the object is not a boxed primitive, does nothing
+ */
+void dvmSetPrimitiveTaint(DataObject* arg, ClassObject* type, u4 tag)
+{
+    int width = getTypeWidth(type->primitiveType);
+
+    if (width > 0) { /* non-primitives have width -1 */
+	/* the tag is store right after the variable */
+	/* see dvmConvertArgument(): for primitives, the value is first */
+	*(u4*)(arg->instanceData+width) = tag;
+
+    } /* else, don't worry about it */
+}
+#endif
+
 /*
  * Create a wrapper object for a primitive data type.  If "returnType" is
  * not primitive, this just casts "value" to an object and returns it.
diff --git a/vm/reflect/Reflect.h b/vm/reflect/Reflect.h
index cd8e76c..55db8af 100644
--- a/vm/reflect/Reflect.h
+++ b/vm/reflect/Reflect.h
@@ -76,6 +76,20 @@ int dvmConvertPrimitiveValue(PrimitiveType srcType,
  */
 int dvmConvertArgument(DataObject* arg, ClassObject* type, s4* ins);
 
+#ifdef WITH_TAINT_TRACKING
+/* Returns the taint tag for a boxed primitive.
+ * If the object is not a boxed primitive, TAINT_CLEAR
+ * is returned
+ */
+u4 dvmGetPrimitiveTaint(DataObject* arg, ClassObject* type);
+
+/* Set the taint tag for a boxed primitive.
+ * If the object is not a boxed primitive, does nothing
+ */
+void dvmSetPrimitiveTaint(DataObject* arg, ClassObject* type, u4 tag);
+#endif
+
+
 /*
  * Create a wrapper object for a primitive data type.  If "returnType" is
  * not primitive, this just returns "value" cast to an object.
diff --git a/vm/tprop/TaintPolicy.c b/vm/tprop/TaintPolicy.c
new file mode 100644
index 0000000..309765e
--- /dev/null
+++ b/vm/tprop/TaintPolicy.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "tprop/TaintPolicyPriv.h"
+
+/* Constext free grammar for profile entries:
+ *
+ * <entry> ::= <etype> "." <var> | "return"
+ * <etype> ::= "class" | "param" <num> | "return"
+ * <var> ::= <signature> "%" <vname> | <var> "." <var>
+ *
+ * Where:
+ * <signature> is the java type signature
+ * <vname> is a valid java variable name
+ *
+ * Variable naming conv
+ */
+
+
+/* Policy for com.ibm.icu4jni.charset.NativeConverter **************/
+
+TaintProfileEntry com_ibm_icu4jni_charset_NativeConverter_convertByteToChar_profile[] = {
+    {"param1", "param3"}, /* byte[] input -> char[] output */
+    {NULL, NULL}
+};
+
+TaintProfileEntry com_ibm_icu4jni_charset_NativeConverter_decode_profile[] = {
+    {"param1", "param3"}, /* byte[] input -> char[] output */
+    {NULL, NULL}
+};
+
+TaintProfileEntry com_ibm_icu4jni_charset_NativeConverter_convertCharToByte_profile[] = {
+    {"param1", "param3"}, /* char[] input -> byte[] output */
+    {NULL, NULL}
+};
+
+TaintProfileEntry com_ibm_icu4jni_charset_NativeConverter_encode_profile[] = {
+    {"param1", "param3"}, /* char[] input -> byte[] output */
+    {NULL, NULL}
+};
+
+TaintProfile com_ibm_icu4jni_charset_NativeConverter_methods[] = {
+    {"convertByteToChar", com_ibm_icu4jni_charset_NativeConverter_convertByteToChar_profile},
+    {"decode", com_ibm_icu4jni_charset_NativeConverter_decode_profile},
+    {"convertCharToByte", com_ibm_icu4jni_charset_NativeConverter_convertCharToByte_profile},
+    {"encode", com_ibm_icu4jni_charset_NativeConverter_encode_profile},
+    {NULL, NULL}
+};
+
+/* Policy for foo.bar.name2 ****************************************/
+
+TaintProfileEntry foo_bar_name2_method1_profile[] = {
+    {"class.foo", "return"},
+    {"param1.bar", "class.bar"},
+    {NULL, NULL}
+};
+
+TaintProfileEntry foo_bar_name2_method2_profile[] = {
+    {"class.foo", "return"},
+    {"param1.bar", "class.bar"},
+    {NULL, NULL}
+};
+
+TaintProfile foo_bar_name2_methods[] = {
+    {"method1", foo_bar_name2_method1_profile},
+    {"method2", foo_bar_name2_method2_profile},
+    {NULL, NULL}
+};
+
+/* Class list ******************************************************/
+
+TaintPolicy gDvmJniTaintPolicy[] = {
+    {"Lcom/ibm/icu4jni/charset/NativeConverter;", com_ibm_icu4jni_charset_NativeConverter_methods, NULL},
+    {"Lfoo/bar/name2;", foo_bar_name2_methods, NULL},
+    {NULL, NULL, NULL}
+};
diff --git a/vm/tprop/TaintPolicyPriv.h b/vm/tprop/TaintPolicyPriv.h
new file mode 100644
index 0000000..f53d984
--- /dev/null
+++ b/vm/tprop/TaintPolicyPriv.h
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef _DALVIK_TPROP_TAINT_PROP_PRIV
+#define _DALVIK_TPROP_TAINT_PROP_PRIV
+
+#include "Dalvik.h"
+
+typedef enum {
+    kTaintProfileUnknown = 0,
+    kTaintProfileClass,
+    kTaintProfileParam,
+    kTaintProfileReturn
+} TaintProfileEntryType;
+
+typedef struct {
+    const char* from;
+    const char* to;
+} TaintProfileEntry;
+
+#define TAINT_PROFILE_TABLE_SIZE 8 /* per class */
+#define TAINT_POLICY_TABLE_SIZE 32 /* number of classes */
+
+typedef struct {
+    const char* methodName;
+    const TaintProfileEntry* entries;
+} TaintProfile;
+
+typedef struct {
+    const char* classDescriptor;
+    const TaintProfile* profiles;
+    HashTable* methodTable; /* created on startup */
+} TaintPolicy;
+
+extern TaintPolicy gDvmJniTaintPolicy[];
+
+/* function of type HashCompareFunc */
+static int hashcmpTaintPolicy(const void* ptr1, const void* ptr2)
+{
+    TaintPolicy* p1 = (TaintPolicy*) ptr1;
+    TaintPolicy* p2 = (TaintPolicy*) ptr2;
+
+    return strcmp(p1->classDescriptor, p2->classDescriptor);
+}
+
+/* function of type HashCompareFunc */
+static int hashcmpTaintProfile(const void* ptr1, const void* ptr2)
+{
+    TaintProfile* m1 = (TaintProfile*) ptr1;
+    TaintProfile* m2 = (TaintProfile*) ptr2;
+
+    return strcmp(m1->methodName, m2->methodName);
+}
+
+/* function of type HashFreeFunc */
+static void freeTaintPolicy(void* p)
+{
+    TaintPolicy* pol = (TaintPolicy*) p;
+    if (pol != NULL) {
+	dvmHashTableFree(pol->methodTable);
+    }
+}
+
+/* function of type HashFreeFunc */
+static void freeTaintProfile(void* p)
+{
+    /* nothing to free */
+    return;
+}
+
+#endif
diff --git a/vm/tprop/TaintProp.c b/vm/tprop/TaintProp.c
new file mode 100644
index 0000000..872d08b
--- /dev/null
+++ b/vm/tprop/TaintProp.c
@@ -0,0 +1,796 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "Dalvik.h"
+#include "tprop/TaintPolicyPriv.h"
+
+/* Wrapper to bundle a Field and an Object instance 
+ * - needed when dealing with nested instance field entries
+ */
+typedef struct {
+    Field *field;
+    Object *obj;
+} FieldRef;
+
+HashTable *gPolicyTable = NULL;
+
+#ifdef TAINT_JNI_LOG
+/* JNI logging for debugging purposes 
+ * -- used to only print methods once (quites things down a bit)
+ */
+HashTable *gJniLogSeen = NULL;
+bool gJniLog = true;
+#endif
+
+/* Code called from dvmJniStartup()
+ * Initializes the gPolicyTable for fast lookup of taint policy 
+ * profiles for methods.
+ */
+void dvmTaintPropJniStartup()
+{
+    TaintPolicy* policy;
+    u4 hash;
+    
+    /* Create the policy table (perfect size) */
+    gPolicyTable = dvmHashTableCreate(
+	    dvmHashSize(TAINT_POLICY_TABLE_SIZE), 
+	    freeTaintPolicy);
+
+    for (policy = gDvmJniTaintPolicy; policy->classDescriptor != NULL; policy++) {
+	TaintProfile *profile;
+    
+	/* Create the method table for this class */
+	policy->methodTable = dvmHashTableCreate(
+		TAINT_PROFILE_TABLE_SIZE, freeTaintProfile);
+
+	/* Add all of the methods */
+	for (profile = &policy->profiles[0]; profile->methodName != NULL; profile++) {
+	    hash = dvmComputeUtf8Hash(profile->methodName);
+	    dvmHashTableLookup(policy->methodTable, hash, profile,
+		    hashcmpTaintProfile, true);
+	}
+
+	/* Add this class to gPolicyTable */
+	hash = dvmComputeUtf8Hash(policy->classDescriptor);
+	dvmHashTableLookup(gPolicyTable, hash, policy, 
+		hashcmpTaintPolicy, true);
+    }
+
+#ifdef TAINT_JNI_LOG
+    /* JNI logging for debugging purposes */
+    gJniLogSeen = dvmHashTableCreate(dvmHashSize(50), free);
+#endif
+}
+
+/* Code called from dvmJniShutdown()
+ * deallocates the gPolicyTable
+ */
+void dvmTaintPropJniShutdown()
+{
+    dvmHashTableFree(gPolicyTable);
+#ifdef TAINT_JNI_LOG
+    /* JNI logging for debugging purposes */
+    dvmHashTableFree(gJniLogSeen);
+#endif
+}
+
+/* Returns the taint on an object.
+ * - Currently only arrays and java.lang.String is supported
+ */
+u4 getObjectTaint(Object* obj, const char* descriptor)
+{
+    ArrayObject *arrObj = NULL;
+
+    if (obj == NULL) {
+	return TAINT_CLEAR;
+    }
+
+    if (descriptor[0] == '[') {
+	/* Get the taint from the array */
+	arrObj = (ArrayObject*) obj;
+	if (arrObj != NULL) {
+	    return arrObj->taint.tag;
+	}
+    } 
+    
+    if (strcmp(descriptor, "Ljava/lang/String;") == 0) {
+	arrObj = (ArrayObject*) dvmGetFieldObject(obj, 
+		gDvm.offJavaLangString_value);
+	if (arrObj != NULL) {
+	    return arrObj->taint.tag;
+	} /* else, empty string? don't worry about it */
+    } 
+
+    /* TODO: What about classes derived from String? */
+
+    /* Don't worry about other object types */
+    return TAINT_CLEAR;
+}
+
+/* Adds taint to a known object.
+ * - Currently only arrays and java.lang.String is supported
+ */
+void addObjectTaint(Object* obj, const char* descriptor, u4 tag)
+{
+    ArrayObject *arrObj = NULL;
+
+    if (obj == NULL) {
+	return;
+    }
+
+    if (descriptor[0] == '[') {
+	/* Get the taint from the array */
+	arrObj = (ArrayObject*) obj;
+	if (arrObj != NULL) {
+	    arrObj->taint.tag |= tag;
+	}
+    } 
+    
+    if (strcmp(descriptor, "Ljava/lang/String;") == 0) {
+	arrObj = (ArrayObject*) dvmGetFieldObject(obj, 
+		gDvm.offJavaLangString_value);
+	if (arrObj != NULL) {
+	    arrObj->taint.tag |= tag;
+	} /* else, empty string? don't worry about it */
+    } 
+
+    /* TODO: What about classes derived from String? */
+
+    /* Don't worry about other object types */
+    return;
+}
+
+/* Sets the taint on the return value
+ * - rtaint points to an address in the args array
+ * - descriptor is the return type
+ * - for return objects, only arrays and java.lang.String supported
+ *   (will taint object reference returned otherwise)
+ */
+void setReturnTaint(u4 tag, u4* rtaint, JValue* pResult, 
+	const char* descriptor)
+{
+    Object* obj = NULL;
+    ArrayObject* arrObj = NULL;
+
+    switch (descriptor[0]) {
+	case 'V':
+	    /* void, do nothing */
+	    break;
+	case 'Z':
+	case 'B':
+	case 'C':
+	case 'S':
+	case 'I':
+	case 'J':
+	case 'F':
+	case 'D':
+	    /* Easy case */
+	    *rtaint |= tag;
+	    break;
+	case '[':
+	    /* Best we can do is taint the array, however
+	     * this is not right for "[[" or "[L" */
+	    arrObj = (ArrayObject*) pResult->l;
+	    if (arrObj != NULL) {
+		arrObj->taint.tag |= tag;
+	    } /* else, method returning null pointer */
+	    break;
+	case 'L':
+	    obj = (Object*) pResult->l;
+
+	    if (obj != NULL) {
+		if (strcmp(descriptor, "Ljava/lang/String;") == 0) {
+		    arrObj = (ArrayObject*)dvmGetFieldObject(obj, 
+			    gDvm.offJavaLangString_value);
+		    if (arrObj != NULL) {
+			arrObj->taint.tag |= tag;
+		    } /* else, empty string?, don't worry about it */
+		} else {
+		    /* TODO: What about classes derived from String? */
+		    /* Best we can do is to taint the object ref */
+		    *rtaint |= tag;
+		}
+	    }
+	    break;
+    }
+}
+
+/* Returns the TaintPolicyProfile associated with this method
+ * - returns NULL if not found
+ */
+TaintProfile* getPolicyProfile(const Method* method)
+{
+    TaintPolicy* policy = NULL;
+    TaintProfile* profile = NULL;
+    u4 hash;
+
+    /* temporary variables for the search */
+    TaintPolicy tPol = {NULL, NULL, NULL};
+    TaintProfile tProf = {NULL, NULL};
+
+    dvmHashTableLock(gPolicyTable);
+
+    /* Find the class */
+    hash = dvmComputeUtf8Hash(method->clazz->descriptor);
+    tPol.classDescriptor = method->clazz->descriptor;
+    policy = (TaintPolicy*) dvmHashTableLookup(gPolicyTable,
+	    hash, &tPol, hashcmpTaintPolicy, false);
+
+    if (policy != NULL) {
+	dvmHashTableLock(policy->methodTable);
+
+	/* Find the Method */
+	hash = dvmComputeUtf8Hash(method->name);
+	tProf.methodName = method->name;
+	profile = (TaintProfile*) dvmHashTableLookup(policy->methodTable,
+		hash, &tProf, hashcmpTaintProfile, false);
+
+	dvmHashTableUnlock(policy->methodTable);
+    }
+
+    dvmHashTableUnlock(gPolicyTable);
+
+    return profile;
+}
+
+
+/* utility to determine the type of entry string
+ */
+TaintProfileEntryType getEntryType(const char* entry)
+{
+    TaintProfileEntryType type = kTaintProfileUnknown;
+
+    if (strncmp(entry, "class", 5) == 0) {
+	type = kTaintProfileClass;
+    } else if (strncmp(entry, "param", 5) == 0) {
+	type = kTaintProfileParam;
+    } else if (strncmp(entry, "return", 6) == 0) {
+	type = kTaintProfileReturn;
+    }
+
+    return type;
+}
+
+/* returns the field structure corresponding to the profile entry
+ * variable in the form: <signature> % <name> 
+ */
+Field* getFieldFromProfileVar(const char* var, const ClassObject* clazz)
+{
+    char* pos;
+    char* sig;
+    char* name;
+    InstField* ifield;
+    StaticField* sfield;
+    Field* field = NULL;
+
+    // TODO: Can we avoid the allocation if we replace the '%'?
+    // Need to make sure there isn't a locking problem if that route
+    // is taken.
+    pos = index(var, '%');
+    sig = strndup(var, pos-var);
+    name = strdup(pos+1);
+
+    /* Try both static and instance fields */
+    ifield = dvmFindInstanceFieldHier(clazz, name, sig);
+    if (ifield != NULL) {
+	field = (Field*) ifield;
+    } else {
+	sfield = dvmFindStaticFieldHier(clazz, name, sig);
+	if (sfield != NULL) {
+	    field = (Field*) sfield;
+	}
+    }
+
+    free(sig);
+    free(name);
+
+    return field;
+}
+
+/* Returns the taint tag for a field
+ * - obj only used if the field is not static
+ */
+u4 getTaintFromField(Field* field, Object* obj)
+{
+    u4 tag = TAINT_CLEAR;
+
+    if (dvmIsStaticField(field)) {
+	StaticField* sfield = (StaticField*) field;
+	tag = dvmGetStaticFieldTaint(sfield);
+    } else {
+	InstField* ifield = (InstField*) field;
+	if (field->signature[0] == 'J' || field->signature[0] == 'D') {
+	    tag = dvmGetFieldTaintWide(obj, ifield->byteOffset);
+	} else {
+	    tag = dvmGetFieldTaint(obj, ifield->byteOffset);
+	}
+    }
+
+    return tag;
+}
+
+/* add tag to a field
+ * - obj only used if the field is not static
+ */
+void addTaintToField(Field* field, Object* obj, u4 tag)
+{
+    if (dvmIsStaticField(field)) {
+	StaticField* sfield = (StaticField*) field;
+	tag |= dvmGetStaticFieldTaint(sfield);
+	dvmSetStaticFieldTaint(sfield, tag);
+    } else {
+	InstField* ifield = (InstField*) field;
+	if (field->signature[0] == 'J' || field->signature[0] == 'D') {
+	    tag |= dvmGetFieldTaintWide(obj, ifield->byteOffset);
+	    dvmSetFieldTaintWide(obj, ifield->byteOffset, tag);
+	} else {
+	    tag |= dvmGetFieldTaint(obj, ifield->byteOffset);
+	    dvmSetFieldTaint(obj, ifield->byteOffset, tag);
+	}
+    }
+}
+
+/* Returns the object pointer for a field
+ * - obj only used if the field is not static
+ * - Note: will not return an array object
+ */
+Object* getObjectFromField(Field* field, Object* obj)
+{
+    if (field->signature[0] != 'L') {
+	return NULL;
+    }
+
+    if (dvmIsStaticField(field)) {
+	StaticField* sfield = (StaticField*) field;
+	return dvmGetStaticFieldObject(sfield);
+    } else {
+	InstField* ifield = (InstField*) field;
+	return dvmGetFieldObject(obj, ifield->byteOffset);
+    }
+}
+
+/* Gets the field associated with an entry string that has the
+ * "class.", "argX.", or "return." stripped
+ * - recursively finds the end field
+ * - obj is ignored if field is static
+ */
+FieldRef getFieldFromEntry(const char* entry, ClassObject* clazz, Object* obj)
+{
+    FieldRef fRef;
+    char* split;
+
+    memset(&fRef, 0, sizeof(fRef));
+
+    split = index(entry, '.');
+    if (split == NULL) { /* This is the last part */
+	fRef.field = getFieldFromProfileVar(entry, clazz);
+	fRef.obj = obj;
+	if (fRef.field == NULL) {
+	    LOGW("TaintPolicy: variable doesn't exist: %s", entry);
+	}
+
+    } else if (entry[0] != 'L') {
+	/* recursion is required, but target isn't an Object */
+	LOGW("TaintPolicy: expected object variable: %s", entry);
+
+    } else { /* recursion is required */
+	char* var = strndup(entry, split-entry);
+	fRef.field = getFieldFromProfileVar(var, clazz);
+	fRef.obj = obj;
+	free(var);
+
+	if (fRef.field == NULL) {
+	    LOGW("TaintPolicy: variable doesn't exist: %s", entry);
+	} else {
+	    Object* obj2 = getObjectFromField(fRef.field, fRef.obj);
+	    if (obj2 != NULL) { 
+		/* recurse */
+		fRef = getFieldFromEntry(split+1, fRef.field->clazz, obj2);
+	    } else {
+		LOGW("TaintPolicy: error getting object for %s", entry);
+	    }
+	}
+    }
+
+    return fRef;
+}
+
+/* Gets the taint tag associated with a field.
+ *  - Here, we assume any "class." has been stripped.
+ *  - We recursively dereference the field name if multiple levels
+ *  - obj is ignored if field is static
+ */
+u4 getFieldEntryTaint(const char* entry, ClassObject* clazz, Object* obj)
+{
+    u4 tag = TAINT_CLEAR;
+    FieldRef fRef;
+
+    fRef = getFieldFromEntry(entry, clazz, obj);
+    if (fRef.field != NULL) {
+	tag = getTaintFromField(fRef.field, fRef.obj);
+    }
+
+    return tag;
+}
+
+/* Returns the index in args[] corresponding to the parameter
+ * string entry.
+ * - It doesn't matter if the entry has multiple parts, e.g.,
+ *   "param1.foo.bar", as long as the variable name after the first
+ *   "." is not a number. Since the signature comes next, we can 
+ *   safely assume this is the case.
+ * - returns -1 on parsing error
+ * - If descriptor is not NULL, it will point to a newly allocated 
+ *   descriptor that needs to be free()'d (unless there was an error)
+ */
+int paramToArgIndex(const char* entry, const Method* method, char** descriptor) {
+    int pIdx, aIdx, i;
+    char* endptr;
+    const char* num = entry + 5; /* "param" is the first 5 characters */
+    const DexProto* proto = &method->prototype;
+    DexParameterIterator pIterator;
+
+    /* Step 1: determine the parameter index (pIdx) */
+    pIdx = strtol(num, &endptr, 10);
+    if (num == endptr) {
+	/* error parsing */
+	return -1;
+    } 
+
+    /* Step 2: translate parameter index into args array index */
+    dexParameterIteratorInit(&pIterator, proto);
+    aIdx = (dvmIsStaticMethod(method)?0:1); /* index where params start */
+    for (i=0; i<=pIdx ; i++) {
+	const char* desc = dexParameterIteratorNextDescriptor(&pIterator);
+
+	if (desc == NULL) {
+	    /* This index doesn't exist, error */
+	    return -1;
+	} 
+
+	if (i == pIdx) {
+	    /* This is the index */
+	    if (descriptor != NULL) {
+		*descriptor = strdup(desc);
+	    }
+	    break;
+	}
+
+	/* increment the args array index */
+	aIdx++;
+
+	if (desc[0] == 'J' || desc[0] == 'D') {
+	    /* wide argument, increment index one more */
+	    aIdx++;
+	}
+    }
+
+    return aIdx;
+}
+
+u4 getParamEntryTaint(const char* entry, const u4* args, const Method* method)
+{
+    u4 tag = TAINT_CLEAR;
+    int aIdx;
+    char* pos;
+    char* pDesc = NULL; /* parameter descriptor */
+
+    /* Determine corresponding args[] index */
+    aIdx = paramToArgIndex(entry, method, &pDesc);
+    if (aIdx == -1) {
+	LOGW("TaintPolicy: error parsing %s", entry);
+	return tag;
+    }
+
+    /* Determine if entry requres field search */
+    pos = index(entry, '.');
+    if (pos == NULL ) { /* just need parameter taint */
+	switch (pDesc[0]) {
+	    case 'Z':
+	    case 'B':
+	    case 'C':
+	    case 'S':
+	    case 'I':
+	    case 'J':
+	    case 'F':
+	    case 'D':
+		/* assume args array length (insSize) = 3
+		 * and aIdx = 1 (second index)
+		 * 0 1 2 [3] 4 5 6
+		 *	       ^-- the taint value we want
+		 */
+		tag = args[aIdx+method->insSize+1];
+		break;
+	    case '[':
+	    case 'L':
+		/* use both the object reference taint and Object taint */
+		tag = args[aIdx+method->insSize+1];
+		tag |= getObjectTaint((Object*)args[aIdx], pDesc);
+		break;
+	    default:
+		LOGW("TaintPolicy: unknown parameter type for %s", entry);
+	}
+
+    } else { /* need to get the parameter object for field search */
+	if (pDesc[0] != 'L') {
+	    LOGW("TaintPolicy: param not object in %s", entry);
+	} else {
+	    Object* obj = (Object*)args[aIdx];
+	    tag = getFieldEntryTaint(pos+1, obj->clazz, obj);
+	}
+    }
+
+    if (pDesc) {
+	free(pDesc);
+    }
+    
+    return tag;
+}
+
+u4 getEntryTaint(const char* entry, const u4* args, const Method* method)
+{
+    u4 tag = TAINT_CLEAR;
+    char *pos;
+
+    /* Determine split point if any */
+    pos = index(entry, '.');
+
+    switch (getEntryType(entry)) {
+	case kTaintProfileClass:
+	    if (dvmIsStaticMethod(method)) {
+		tag = getFieldEntryTaint(pos+1, method->clazz, NULL);
+	    } else {
+		tag = getFieldEntryTaint(pos+1, method->clazz, (Object*)args[0]);
+	    }
+	    break;
+
+	case kTaintProfileParam:
+	    tag = getParamEntryTaint(entry, args, method);
+	    break;
+
+	default:
+	    LOGW("TaintPolicy: Invalid from type: [%s]", entry);
+    }
+    
+    return tag;
+}
+
+/* adds the taint tag associated with a field.
+ *  - Here, we assume any "class." has been stripped.
+ *  - We recursively dereference the field name if multiple levels
+ *  - obj is ignored if field is static
+ */
+void addFieldEntryTaint(u4 tag, const char* entry, ClassObject* clazz, Object* obj)
+{
+    FieldRef field;
+
+    field = getFieldFromEntry(entry, clazz, obj);
+    if (field.field != NULL) {
+	addTaintToField(field.field, field.obj, tag);
+    }
+}
+
+void addParamEntryTaint(u4 tag, const char* entry, const u4* args, const Method* method)
+{
+    int aIdx;
+    char* pos;
+    char* pDesc = NULL; /* parameter descriptor */
+    
+    pos = index(entry, '.');
+
+    /* Determine corresponding args[] index */
+    aIdx = paramToArgIndex(entry, method, &pDesc);
+    if (aIdx == -1) {
+	LOGW("TaintPolicy: error parsing %s", entry);
+	return;
+    }
+
+    if (pos == NULL && (pDesc[0] == '[' || pDesc[0] == 'L')) {
+	/* target is a parameter that we can taint directly */
+	Object* obj = (Object*)args[aIdx];
+	addObjectTaint(obj, pDesc, tag);
+    } else if (pDesc[0] == 'L') {
+	Object* obj = (Object*)args[aIdx];
+	addFieldEntryTaint(tag, pos+1, obj->clazz, obj);
+    } else {
+	LOGW("TaintPolicy: param not object or array in %s (%s)", 
+		entry, pDesc);
+    }
+
+    if (pDesc) {
+	free(pDesc);
+    }
+}
+
+u4 addEntryTaint(u4 tag, const char* entry, const u4* args, const Method* method)
+{
+    u4 rtaint = TAINT_CLEAR;
+
+    switch (getEntryType(entry)) {
+	case kTaintProfileClass:
+	    if (dvmIsStaticMethod(method)) {
+		addFieldEntryTaint(tag, entry, method->clazz, NULL);
+	    } else {
+		addFieldEntryTaint(tag, entry, method->clazz, (Object*)args[0]);
+	    }
+	    break;
+
+	case kTaintProfileParam:
+	    addParamEntryTaint(tag, entry, args, method);
+	    break;
+
+	case kTaintProfileReturn:
+	    if (entry[7] == '\0') { /* taint the return itself */
+		rtaint = tag;
+	    } else {
+		// TODO: implement return field tainting (need pResult)
+		LOGW("TaintPolicy: tainting return fields not supported");
+	    }
+	    break;
+
+	default:
+	    LOGW("TaintPolicy: Invalid from type: [%s]", entry);
+    }
+
+    return rtaint;
+}
+
+/* Returns a taint if the profile policy indicates propagation
+ * to the return
+ */
+u4 propMethodProfile(const u4* args, const Method* method)
+{
+    u4 rtaint = TAINT_CLEAR;
+    TaintProfile* profile = NULL;
+    TaintProfileEntry* entry = NULL;
+
+    profile = getPolicyProfile(method);
+    if (profile == NULL) {
+	return rtaint;
+    }
+
+    //LOGD("TaintPolicy: applying policy for %s.%s",
+    //	    method->clazz->descriptor, method->name);
+
+    /* Cycle through the profile entries */
+    for (entry = &profile->entries[0]; entry->from != NULL; entry++) {
+	u4 tag = TAINT_CLEAR;
+
+	tag = getEntryTaint(entry->from, args, method);
+	if (tag) {
+	    //LOGD("TaintPolicy: tag = %d %s -> %s",
+	    //	    tag, entry->from, entry->to);
+	    rtaint |= addEntryTaint(tag, entry->to, args, method);
+	}
+
+    }
+
+    return rtaint;
+}
+
+/* Used to propagate taint for JNI methods
+ * Two types of propagation:
+ *  1) simple conservative propagation based on parameters
+ *  2) propagation based on function profile policies
+ */
+void dvmTaintPropJniMethod(const u4* args, JValue* pResult, const Method* method)
+{
+    const DexProto* proto = &method->prototype;
+    DexParameterIterator pIterator;
+    int nParams = dexProtoGetParameterCount(proto);
+    int pStart = (dvmIsStaticMethod(method)?0:1); /* index where params start */
+
+    /* Consider 3 arguments. [x] indicates return taint index
+     * 0 1 2 [3] 4 5 6
+     */
+    int nArgs = method->insSize;
+    u4* rtaint = (u4*) &args[nArgs]; /* The return taint value */
+    int tStart = nArgs+1; /* index of args[] where taint values start */
+    int tEnd   = nArgs*2; /* index of args[] where taint values end */
+    u4	tag = TAINT_CLEAR;
+    int i;
+
+#if 0
+    {
+	char *desc = dexProtoCopyMethodDescriptor(proto);
+	LOGW("Jni: %s.%s%s, descriptor: %s", 
+		method->clazz->descriptor, method->name, 
+		(dvmIsStaticMethod(method)?"[static]":"", desc)
+		);
+	free(desc);
+    }
+#endif
+
+#ifdef TAINT_JNI_LOG
+    /* JNI logging for debugging purposes */
+    if (gJniLog) {
+	u4 hash;
+	int len;
+	char *inStr, *outStr;
+
+	len = strlen(method->clazz->descriptor) + 1 + strlen(method->name);
+	inStr = malloc(len+1);
+	strcpy(inStr, method->clazz->descriptor);
+	strcat(inStr, ".");
+	strcat(inStr, method->name);
+	hash = dvmComputeUtf8Hash(inStr);
+
+	dvmHashTableLock(gJniLogSeen);
+
+	outStr = dvmHashTableLookup(gJniLogSeen, hash, inStr, 
+		(HashCompareFunc) strcmp, false);
+
+	if (outStr == NULL) {
+	    /* New method! */
+	    LOGD("JNI METHOD INVOCATION: %s\n", inStr);
+	    /* add it */
+	    dvmHashTableLookup(gJniLogSeen, hash, inStr, 
+		(HashCompareFunc) strcmp, true);
+	} else {
+	    free(inStr); /* don't need this anymore */
+	}
+
+	dvmHashTableUnlock(gJniLogSeen);
+    }
+#endif
+
+    /* Union the taint tags, this includes object ref tags 
+     * - we don't need to worry about static vs. not static, because getting
+     *	 the taint tag on the "this" object reference is a good
+     * - we don't need to worry about wide registers, because the stack
+     *	 interleaving of taint tags makes it transparent
+     */
+    for (i = tStart; i <= tEnd; i++) {
+	tag |= args[i];
+    }
+
+    /* If not static, pull any taint from the "this" object */
+    if (!dvmIsStaticMethod(method)) {
+	tag |= getObjectTaint((Object*)args[0], method->clazz->descriptor);
+    }
+
+    /* Union taint from Objects we care about */
+    dexParameterIteratorInit(&pIterator, proto);
+    for (i=pStart; ; i++) {
+	const char* desc = dexParameterIteratorNextDescriptor(&pIterator);
+
+	if (desc == NULL) {
+	    break;
+	} 
+	
+	if (desc[0] == '[' || desc[0] == 'L') {
+	    tag |= getObjectTaint((Object*) args[i], desc);
+	}
+
+	if (desc[0] == 'J' || desc[0] == 'D') {
+	    /* wide argument, increment index one more */
+	    i++;
+	}
+    }
+
+    /* Look at the taint policy profiles (may have return taint) */
+    tag |= propMethodProfile(args, method);
+
+    /* Update return taint according to the return type */
+    if (tag) {
+	const char* desc = dexProtoGetReturnType(proto);
+	setReturnTaint(tag, rtaint, pResult, desc);
+    }
+}
+
diff --git a/vm/tprop/TaintProp.h b/vm/tprop/TaintProp.h
new file mode 100644
index 0000000..ccc1daa
--- /dev/null
+++ b/vm/tprop/TaintProp.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2010 The Pennsylvania State University
+ * Systems and Internet Infrastructure Security Laboratory
+ *
+ * Authors: William Enck <enck@cse.psu.edu>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/* Note, this file should be included near the end of Dalvik.h */
+
+#ifndef _DALVIK_TPROP_TAINT_PROP
+#define _DALVIK_TPROP_TAINT_PROP
+
+/* Called from dvmJniStartup() */
+void dvmTaintPropJniStartup();
+
+/* Called from dvmJniShutdown() */
+void dvmTaintPropJniShutdown();
+
+/* Main propagation */
+void dvmTaintPropJniMethod(const u4* args, JValue* pResult, const Method* method);
+
+#endif
