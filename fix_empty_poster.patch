From b0b2c678292f036714651c5b547bb8cbebf5bb98 Mon Sep 17 00:00:00 2001
From: Arun Natarajan <arun.n.ece@gmail.com>
Date: Fri, 4 Mar 2011 08:18:56 -0800
Subject: [PATCH] Chnages introduced to get libdvm working after taintdroid patch applied

Change-Id: I378bb1ec282b7f1ac7f1ab9ae5f50a6fa9c65ec5
---
 dexopt/Android.mk                |    9 +
 dexopt/OptMain.c                 |   14 +
 vm/Dvm.mk                        |   26 +
 vm/Init.c                        |   19 +
 vm/Jni.c                         |   19 +
 vm/Native.c                      |   11 +
 vm/Thread.h                      |    6 +
 vm/interp/Interp.c               |   27 +
 vm/interp/Stack.c                |  267 ++-
 vm/interp/Stack.h                |   12 +-
 vm/mterp/c/OP_APUT_OBJECT.c      |    5 +
 vm/mterp/c/gotoTargets.c         |  105 +-
 vm/mterp/c/opcommon.c            |  112 +
 vm/mterp/common/asm-constants.h  |   53 +
 vm/mterp/config-armv7-a          |  215 +-
 vm/mterp/out/InterpAsm-armv7-a.S | 5311 +++++++++++++++++++++++++-------------
 vm/mterp/out/InterpC-allstubs.c  |  519 ++++-
 vm/mterp/out/InterpC-armv7-a.c   | 1459 +++++++++++
 vm/mterp/out/InterpC-portdbg.c   |  524 ++++-
 vm/mterp/out/InterpC-portstd.c   |  524 ++++-
 vm/mterp/out/InterpC-x86.c       |  396 +++-
 vm/native/java_lang_System.c     |   24 +
 vm/oo/Object.h                   |   11 +
 23 files changed, 7710 insertions(+), 1958 deletions(-)

diff --git a/dexopt/Android.mk b/dexopt/Android.mk
index 3bb98a5..c720211 100644
--- a/dexopt/Android.mk
+++ b/dexopt/Android.mk
@@ -34,6 +34,15 @@ local_shared_libraries := \
 		libicuuc \
 		libicui18n
 
+# Turn on Taint Tracking
+ifeq ($(WITH_TAINT_TRACKING),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_TRACKING
+endif
+ifeq ($(WITH_TAINT_ODEX),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_ODEX
+endif
+
+
 include $(CLEAR_VARS)
 ifeq ($(TARGET_CPU_SMP),true)
     LOCAL_CFLAGS += -DANDROID_SMP=1
diff --git a/dexopt/OptMain.c b/dexopt/OptMain.c
index b8e5889..b4508a7 100644
--- a/dexopt/OptMain.c
+++ b/dexopt/OptMain.c
@@ -128,7 +128,11 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
     /* Parse the options. */
 
     DexClassVerifyMode verifyMode = VERIFY_MODE_ALL;
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    DexOptimizerMode dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     DexOptimizerMode dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
     int dexoptFlags = 0;        /* bit flags, from enum DexoptFlags */
 
     if (dexoptFlagStr[0] != '\0') {
@@ -145,6 +149,10 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
             }
         }
 
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+	/* No choices */
+	dexOptMode = OPTIMIZE_MODE_NONE;
+#else
         opc = strstr(dexoptFlagStr, "o=");      /* optimization */
         if (opc != NULL) {
             switch (*(opc+2)) {
@@ -154,6 +162,7 @@ static int extractAndProcessZip(int zipFd, int cacheFd,
             default:                                            break;
             }
         }
+#endif
 
         opc = strstr(dexoptFlagStr, "m=y");     /* register map */
         if (opc != NULL) {
@@ -504,6 +513,10 @@ static int fromDex(int argc, char* const argv[])
     } else {
         verifyMode = VERIFY_MODE_NONE;
     }
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    /* no choices */
+    dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     if ((flags & DEXOPT_OPT_ENABLED) != 0) {
         if ((flags & DEXOPT_OPT_ALL) != 0)
             dexOptMode = OPTIMIZE_MODE_ALL;
@@ -512,6 +525,7 @@ static int fromDex(int argc, char* const argv[])
     } else {
         dexOptMode = OPTIMIZE_MODE_NONE;
     }
+#endif
 
     if (dvmPrepForDexOpt(bootClassPath, dexOptMode, verifyMode, flags) != 0) {
         LOGE("VM init failed\n");
diff --git a/vm/Dvm.mk b/vm/Dvm.mk
index 0867ffa..ace11c8 100644
--- a/vm/Dvm.mk
+++ b/vm/Dvm.mk
@@ -29,6 +29,17 @@ LOCAL_CFLAGS += -fstrict-aliasing -Wstrict-aliasing=2 -fno-align-jumps
 LOCAL_CFLAGS += -Wall -Wextra -Wno-unused-parameter
 LOCAL_CFLAGS += -DARCH_VARIANT=\"$(dvm_arch_variant)\"
 
+# Turn on Taint Tracking
+ifeq ($(WITH_TAINT_TRACKING),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_TRACKING
+endif
+ifeq ($(TAINT_JNI_LOG),true)
+  LOCAL_CFLAGS += -DTAINT_JNI_LOG
+endif
+ifeq ($(WITH_TAINT_FAST),true)
+  LOCAL_CFLAGS += -DWITH_TAINT_FAST
+endif
+
 #
 # Optional features.  These may impact the size or performance of the VM.
 #
@@ -194,6 +205,12 @@ LOCAL_SRC_FILES := \
 	test/TestHash.c \
 	test/TestIndirectRefTable.c
 
+ifeq ($(WITH_TAINT_TRACKING), true)
+    LOCAL_SRC_FILES += native/dalvik_system_Taint.c
+    LOCAL_SRC_FILES += tprop/TaintProp.c
+    LOCAL_SRC_FILES += tprop/TaintPolicy.c
+endif
+
 WITH_COPYING_GC := $(strip $(WITH_COPYING_GC))
 
 ifeq ($(WITH_COPYING_GC),true)
@@ -250,6 +267,10 @@ LOCAL_C_INCLUDES += \
 	external/zlib \
 	$(KERNEL_HEADERS)
 
+# Taint tracking with file propagation
+ifeq ($(WITH_TAINT_TRACKING),true)
+    LOCAL_C_INCLUDES += dalvik/libattr
+endif
 
 ifeq ($(dvm_simulator),true)
   LOCAL_LDLIBS += -lpthread -ldl
@@ -334,3 +355,8 @@ endif
 ifeq ($(TEST_VM_IN_ECLAIR),true)
   LOCAL_CFLAGS += -DTEST_VM_IN_ECLAIR
 endif
+
+# Taint tracking with file propagation
+ifeq ($(WITH_TAINT_TRACKING),teue)
+    LOCAL_STATIC_LIBRARIES += libattr
+endif
diff --git a/vm/Init.c b/vm/Init.c
index 4a2cbed..610b2ea 100644
--- a/vm/Init.c
+++ b/vm/Init.c
@@ -190,6 +190,9 @@ static void dvmUsage(const char* progName)
 #if ANDROID_SMP != 0
         " smp"
 #endif
+#ifdef WITH_TAINT_TRACKING
+	" taint_tracking"
+#endif
     );
 #ifdef DVM_SHOW_EXCEPTION
     dvmFprintf(stderr, " show_exception=%d", DVM_SHOW_EXCEPTION);
@@ -848,9 +851,17 @@ static int dvmProcessOptions(int argc, const char* const argv[],
             if (strcmp(argv[i] + 9, "none") == 0)
                 gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
             else if (strcmp(argv[i] + 9, "verified") == 0)
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+                gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
                 gDvm.dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
             else if (strcmp(argv[i] + 9, "all") == 0)
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+                gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
                 gDvm.dexOptMode = OPTIMIZE_MODE_ALL;
+#endif
             else {
                 dvmFprintf(stderr, "Unrecognized dexopt option '%s'\n",argv[i]);
                 return -1;
@@ -1043,7 +1054,11 @@ static void setCommandLineDefaults()
 
     /* default verification and optimization modes */
     gDvm.classVerifyMode = VERIFY_MODE_ALL;
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_ODEX)
+    gDvm.dexOptMode = OPTIMIZE_MODE_NONE;
+#else
     gDvm.dexOptMode = OPTIMIZE_MODE_VERIFIED;
+#endif
 
     /*
      * Default execution mode.
@@ -1058,6 +1073,10 @@ static void setCommandLineDefaults()
     gDvm.executionMode = kExecutionModeInterpFast;
 #endif
 
+#if defined(WITH_TAINT_TRACKING) && !defined(WITH_TAINT_FAST)
+    gDvm.executionMode = kExecutionModeInterpPortable;
+#endif
+
     /*
      * SMP support is a compile-time define, but we may want to have
      * dexopt target a differently-configured device.
diff --git a/vm/Jni.c b/vm/Jni.c
index ef0749a..a105949 100644
--- a/vm/Jni.c
+++ b/vm/Jni.c
@@ -428,6 +428,10 @@ bool dvmJniStartup(void)
         return false;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniStartup();
+#endif
+
     return true;
 }
 
@@ -442,6 +446,9 @@ void dvmJniShutdown(void)
     dvmClearReferenceTable(&gDvm.jniGlobalRefTable);
 #endif
     dvmClearReferenceTable(&gDvm.jniPinRefTable);
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniShutdown();
+#endif
 }
 
 
@@ -1731,6 +1738,10 @@ void dvmCallJNIMethod_general(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(env, pResult, method, self);
@@ -1792,6 +1803,10 @@ void dvmCallJNIMethod_virtualNoRef(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(self->jniEnv, pResult, method, self);
@@ -1828,6 +1843,10 @@ void dvmCallJNIMethod_staticNoRef(const u4* args, JValue* pResult,
         (void*)method->insns, pResult);
     CHECK_STACK_SUM(self);
 
+#ifdef WITH_TAINT_TRACKING
+    dvmTaintPropJniMethod(args, pResult, method);
+#endif
+
     dvmChangeStatus(self, oldStatus);
 
     convertReferenceResult(self->jniEnv, pResult, method, self);
diff --git a/vm/Native.c b/vm/Native.c
index 1ebef2e..4416a20 100644
--- a/vm/Native.c
+++ b/vm/Native.c
@@ -330,6 +330,17 @@ bool dvmLoadNativeCode(const char* pathName, Object* classLoader,
     if (verbose)
         LOGD("Trying to load lib %s %p\n", pathName, classLoader);
 
+#ifdef WITH_TAINT_TRACKING
+    if (strncmp(pathName, "/system", 7) != 0) {
+	LOGW("Denying lib %s (not \"/system\" prefix)\n", pathName);
+	return false;
+    }
+    if (strstr(pathName, "/../") != NULL) {
+	LOGW("Denying lib %s (contains \"/../\")\n", pathName);
+	return false;
+    }
+#endif
+
     *detail = NULL;
 
     /*
diff --git a/vm/Thread.h b/vm/Thread.h
index e336dda..503386a 100644
--- a/vm/Thread.h
+++ b/vm/Thread.h
@@ -80,9 +80,15 @@ void dvmSlayDaemons(void);
 #define kInternalRefDefault     32      /* equally arbitrary */
 #define kInternalRefMax         4096    /* mainly a sanity check */
 
+#ifdef WITH_TAINT_TRACKING
+# define kMinStackSize       (1024 + STACK_OVERFLOW_RESERVE)
+# define kDefaultStackSize   (24*1024)    /* six 4K pages */
+# define kMaxStackSize       (512*1024 + STACK_OVERFLOW_RESERVE)
+#else
 #define kMinStackSize       (512 + STACK_OVERFLOW_RESERVE)
 #define kDefaultStackSize   (12*1024)   /* three 4K pages */
 #define kMaxStackSize       (256*1024 + STACK_OVERFLOW_RESERVE)
+#endif
 
 /*
  * Our per-thread data.
diff --git a/vm/interp/Interp.c b/vm/interp/Interp.c
index 9f44a13..05e2fce 100644
--- a/vm/interp/Interp.c
+++ b/vm/interp/Interp.c
@@ -613,7 +613,11 @@ Object* dvmGetThisPtr(const Method* method, const u4* fp)
 {
     if (dvmIsStaticMethod(method))
         return NULL;
+#ifdef WITH_TAINT_TRACKING
+    return (Object*)fp[(method->registersSize - method->insSize)<<1];
+#else
     return (Object*)fp[method->registersSize - method->insSize];
+#endif
 }
 
 
@@ -673,7 +677,11 @@ void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly)
     for (i = method->registersSize-1; i >= 0; i--) {
         if (i >= localCount) {
             LOG(LOG_VERBOSE, LOG_TAG"i", "  v%-2d in%-2d : 0x%08x\n",
+#ifdef WITH_TAINT_TRACKING
+                i, i-localCount, framePtr[i<<1]);
+#else
                 i, i-localCount, framePtr[i]);
+#endif
         } else {
             if (inOnly) {
                 LOG(LOG_VERBOSE, LOG_TAG"i", "  [...]\n");
@@ -694,7 +702,11 @@ void dvmDumpRegs(const Method* method, const u4* framePtr, bool inOnly)
             }
 #endif
             LOG(LOG_VERBOSE, LOG_TAG"i", "  v%-2d      : 0x%08x %s\n",
+#ifdef WITH_TAINT_TRACKING
+                i, framePtr[i<<1], name);
+#else
                 i, framePtr[i], name);
+#endif
         }
     }
 }
@@ -946,6 +958,11 @@ bool dvmInterpHandleFillArrayData(ArrayObject* arrayObj, const u2* arrayData)
         return false;
     }
     copySwappedArrayData(arrayObj->contents, &arrayData[4], size, width);
+#ifdef WITH_TAINT_TRACKING
+    if (arrayObj->length == size) {
+	arrayObj->taint.tag = TAINT_CLEAR;
+    }
+#endif
     return true;
 }
 
@@ -1222,7 +1239,11 @@ void dvmThrowVerificationError(const Method* method, int kind, int ref)
  * The interpreted stack frame, which holds the method arguments, has
  * already been set up.
  */
+#ifdef WITH_TAINT_TRACKING
+void dvmInterpret(Thread* self, const Method* method, JValue* pResult, u4* rtaint)
+#else
 void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
+#endif
 {
     InterpState interpState;
     bool change;
@@ -1297,6 +1318,9 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
      *
      * No need to initialize "retval".
      */
+#ifdef WITH_TAINT_TRACKING
+    interpState.rtaint.tag = TAINT_CLEAR;
+#endif
     interpState.method = method;
     interpState.fp = (u4*) self->curFrame;
     interpState.pc = method->insns;
@@ -1354,6 +1378,9 @@ void dvmInterpret(Thread* self, const Method* method, JValue* pResult)
     }
 
     *pResult = interpState.retval;
+#ifdef WITH_TAINT_TRACKING
+    *rtaint = interpState.rtaint.tag;
+#endif
 #if defined(WITH_JIT)
     dvmJitCalleeRestore(interpState.calleeSave);
 #endif
diff --git a/vm/interp/Stack.c b/vm/interp/Stack.c
index 695aa44..1fb2c69 100644
--- a/vm/interp/Stack.c
+++ b/vm/interp/Stack.c
@@ -66,9 +66,16 @@ static bool dvmPushInterpFrame(Thread* self, const Method* method)
     assert(!dvmIsNativeMethod(method));
     assert(!dvmIsAbstractMethod(method));
 
+#ifdef WITH_TAINT_TRACKING
+    /* taint tags are interleaved, plus "native hack" spacer for args */
+    stackReq = method->registersSize * 8 + 4       // params + locals
+                + sizeof(StackSaveArea) * 2     // break frame + regular frame
+                + method->outsSize * 8 + 4;         // args to other methods
+# else
     stackReq = method->registersSize * 4        // params + locals
                 + sizeof(StackSaveArea) * 2     // break frame + regular frame
                 + method->outsSize * 4;         // args to other methods
+#endif
 
     if (self->curFrame != NULL)
         stackPtr = (u1*) SAVEAREA_FROM_FP(self->curFrame);
@@ -92,13 +99,22 @@ static bool dvmPushInterpFrame(Thread* self, const Method* method)
      */
     stackPtr -= sizeof(StackSaveArea);
     breakSaveBlock = (StackSaveArea*)stackPtr;
+#ifdef WITH_TAINT_TRACKING
+    /* interleaved taint tracking plus "native hack" spacer for args */
+    stackPtr -= method->registersSize * 8 + 4 + sizeof(StackSaveArea);
+#else
     stackPtr -= method->registersSize * 4 + sizeof(StackSaveArea);
+#endif
     saveBlock = (StackSaveArea*) stackPtr;
 
 #if !defined(NDEBUG) && !defined(PAD_SAVE_AREA)
     /* debug -- memset the new stack, unless we want valgrind's help */
+#ifdef WITH_TAINT_TRACKING
+    memset(stackPtr - (method->outsSize*8+4), 0xaf, stackReq);
+#else
     memset(stackPtr - (method->outsSize*4), 0xaf, stackReq);
 #endif
+#endif
 #ifdef EASY_GDB
     breakSaveBlock->prevSave = FP_FROM_SAVEAREA(self->curFrame);
     saveBlock->prevSave = breakSaveBlock;
@@ -140,8 +156,14 @@ bool dvmPushJNIFrame(Thread* self, const Method* method)
 
     assert(dvmIsNativeMethod(method));
 
+#ifdef WITH_TAINT_TRACKING
+    /* Interleaved taint tags plus "native hack" spacer */
+    stackReq = method->registersSize * 8 + 4    // params only
+                + sizeof(StackSaveArea) * 2;    // break frame + regular frame
+#else
     stackReq = method->registersSize * 4        // params only
                 + sizeof(StackSaveArea) * 2;    // break frame + regular frame
+#endif
 
     if (self->curFrame != NULL)
         stackPtr = (u1*) SAVEAREA_FROM_FP(self->curFrame);
@@ -166,7 +188,12 @@ bool dvmPushJNIFrame(Thread* self, const Method* method)
      */
     stackPtr -= sizeof(StackSaveArea);
     breakSaveBlock = (StackSaveArea*)stackPtr;
+#ifdef WITH_TAINT_TRACKING
+    /* interleaved taint tags plus "native hack" spacer */
+    stackPtr -= method->registersSize * 8 + 4 + sizeof(StackSaveArea);
+#else
     stackPtr -= method->registersSize * 4 + sizeof(StackSaveArea);
+#endif
     saveBlock = (StackSaveArea*) stackPtr;
 
 #if !defined(NDEBUG) && !defined(PAD_SAVE_AREA)
@@ -452,12 +479,28 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
     ClassObject* clazz;
     u4* ins;
 
+#ifdef WITH_TAINT_TRACKING
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+#endif
+
     clazz = callPrep(self, method, obj, false);
     if (clazz == NULL)
         return;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((u4*)self->curFrame) +
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
 
     //LOGD("  FP is %p, INs live at >= %p\n", self->curFrame, ins);
 
@@ -467,6 +510,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
         assert(obj != NULL && dvmIsValidObject(obj));
 #endif
         *ins++ = (u4) obj;
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -476,7 +525,19 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
             case 'D': case 'J': {
                 u8 val = va_arg(args, u8);
                 memcpy(ins, &val, 8);       // EABI prevents direct store
+#ifdef WITH_TAINT_TRACKING
+		if (nativeTarget) {
+		    ins += 2;
+		} else { /* adjust for taint tag interleaving */
+		    ins[2] = ins[1];
+		    ins[1] = TAINT_CLEAR;
+		    ins[3] = TAINT_CLEAR;
+		    ins += 4;
+		}
+		slot_cnt += 2;
+#else
                 ins += 2;
+#endif
                 verifyCount += 2;
                 break;
             }
@@ -484,6 +545,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
                 /* floats were normalized to doubles; convert back */
                 float f = (float) va_arg(args, double);
                 *ins++ = dvmFloatToU4(f);
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
@@ -494,18 +561,43 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
                     *ins++ = (u4) dvmDecodeIndirectRef(env, argObj);
                 else
                     *ins++ = (u4) argObj;
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
             default: {
                 /* Z B C S I -- all passed as 32-bit integers */
                 *ins++ = va_arg(args, u4);
+#ifdef WITH_TAINT_TRACKING
+		if (!nativeTarget) {
+		    *ins++ = TAINT_CLEAR;
+		}
+		slot_cnt++;
+#endif
                 verifyCount++;
                 break;
             }
         }
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	}
+    }
+#endif
+
 #ifndef NDEBUG
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
@@ -526,7 +618,12 @@ void dvmCallMethodV(Thread* self, const Method* method, Object* obj,
         (*method->nativeFunc)(self->curFrame, pResult, method, self);
         TRACE_METHOD_EXIT(self, method);
     } else {
+#ifdef WITH_TAINT_TRACKING
+	u4 rtaint; /* not used */
+        dvmInterpret(self, method, pResult, &rtaint);
+#else
         dvmInterpret(self, method, pResult);
+#endif
     }
 
 #ifndef NDEBUG
@@ -556,17 +653,39 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
     ClassObject* clazz;
     u4* ins;
 
+#ifdef WITH_TAINT_TRACKING
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+#endif
+
     clazz = callPrep(self, method, obj, false);
     if (clazz == NULL)
         return;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((u4*)self->curFrame) +
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((u4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
 
     /* put "this" pointer into in0 if appropriate */
     if (!dvmIsStaticMethod(method)) {
         assert(obj != NULL);
         *ins++ = (u4) obj;              /* obj is a "real" ref */
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -576,7 +695,19 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         case 'D':                       /* 64-bit quantity; have to use */
         case 'J':                       /*  memcpy() in case of mis-alignment */
             memcpy(ins, &args->j, 8);
-            ins += 2;
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		ins += 2;
+	    } else { /* adjust for taint tag interleaving */
+		ins[2] = ins[1];
+		ins[1] = TAINT_CLEAR;
+		ins[3] = TAINT_CLEAR;
+		ins += 4;
+	    }
+	    slot_cnt += 2;
+#else
+	    ins += 2;
+#endif
             verifyCount++;              /* this needs an extra push */
             break;
         case 'L':                       /* includes array refs */
@@ -584,22 +715,58 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
                 *ins++ = (u4) dvmDecodeIndirectRef(env, args->l);
             else
                 *ins++ = (u4) args->l;
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'F':
         case 'I':
             *ins++ = args->i;           /* full 32 bits */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'S':
             *ins++ = args->s;           /* 16 bits, sign-extended */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'C':
             *ins++ = args->c;           /* 16 bits, unsigned */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'B':
             *ins++ = args->b;           /* 8 bits, sign-extended */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         case 'Z':
             *ins++ = args->z;           /* 8 bits, zero or non-zero */
+#ifdef WITH_TAINT_TRACKING
+	    if (!nativeTarget) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	    slot_cnt++;
+#endif
             break;
         default:
             LOGE("Invalid char %c in short signature of %s.%s\n",
@@ -612,6 +779,19 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         args++;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = TAINT_CLEAR;
+	    }
+	}
+    }
+#endif
+
 #ifndef NDEBUG
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
@@ -630,7 +810,12 @@ void dvmCallMethodA(Thread* self, const Method* method, Object* obj,
         (*method->nativeFunc)(self->curFrame, pResult, method, self);
         TRACE_METHOD_EXIT(self, method);
     } else {
+#ifdef WITH_TAINT_TRACKING
+	u4 rtaint; /* not used */
+        dvmInterpret(self, method, pResult, &rtaint);
+#else
         dvmInterpret(self, method, pResult);
+#endif
     }
 
 bail:
@@ -660,6 +845,17 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     JValue retval;
     bool needPop = false;
 
+#ifdef WITH_TAINT_TRACKING
+    u4 rtaint = TAINT_CLEAR;
+    int slot_cnt = 0;
+    bool nativeTarget = dvmIsNativeMethod(method);
+    /* For simplicity, argument tags for native targets
+     * are unioned. This may cause false positives, but
+     * it is the easiest way to handle this for now.
+     */
+    u4 nativeTag = TAINT_CLEAR;
+#endif
+
     /* verify arg count */
     if (argList != NULL)
         argListLength = argList->length;
@@ -679,7 +875,18 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     needPop = true;
 
     /* "ins" for new frame start at frame pointer plus locals */
+#ifdef WITH_TAINT_TRACKING
+    if (nativeTarget) {
+	/* native target, no taint tag interleaving */
+	ins = ((s4*)self->curFrame) + (method->registersSize - method->insSize);
+    } else {
+	/* interpreted target, taint tags are interleaved */
+	ins = ((s4*)self->curFrame) + 
+	    ((method->registersSize - method->insSize) << 1);
+    }
+#else
     ins = ((s4*)self->curFrame) + (method->registersSize - method->insSize);
+#endif
     verifyCount = 0;
 
     //LOGD("  FP is %p, INs live at >= %p\n", self->curFrame, ins);
@@ -688,6 +895,12 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     if (!dvmIsStaticMethod(method)) {
         assert(obj != NULL);
         *ins++ = (s4) obj;
+#ifdef WITH_TAINT_TRACKING
+	if (!nativeTarget) {
+	    *ins++ = TAINT_CLEAR;
+	}
+	slot_cnt++;
+#endif
         verifyCount++;
     }
 
@@ -703,7 +916,9 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
     types = (ClassObject**) params->contents;
     for (i = 0; i < argListLength; i++) {
         int width;
-
+#ifdef WITH_TAINT_TRACKING
+	int tag = dvmGetPrimitiveTaint(*args, *types);
+#endif
         width = dvmConvertArgument(*args++, *types++, ins);
         if (width < 0) {
             if (*(args-1) != NULL) {
@@ -718,10 +933,47 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
             goto bail;
         }
 
+#ifdef WITH_TAINT_TRACKING
+	/* dvmConvertArgument() returns -1, 1, or 2 */
+	if (nativeTarget) {
+	    nativeTag |= tag; /* TODO: is there a better way to do this?*/
+	    ins += width;
+	} else {
+	    if (width == 2) {
+		ins[2] = ins[1];
+		ins[1] = tag;
+		ins[3] = tag;
+		ins += 4;
+	    } else if (width == 1) {
+		ins[1] = tag;
+		ins += 2;
+	    } else { /* error condition duplicated from above */
+		dvmPopFrame(self);
+		dvmThrowException("Ljava/lang/IllegalArgumentException;",
+		    "argument type mismatch");
+		goto bail_popped;
+	    }
+	}
+	slot_cnt += width;
+#else
         ins += width;
+#endif
         verifyCount += width;
     }
 
+#ifdef WITH_TAINT_TRACKING
+    /* native hack spacer */
+    *ins++ = TAINT_CLEAR; /* if nativeTarget, this is return taint */
+    {
+	int i;
+	if (nativeTarget) {
+	    for (i = 0; i < slot_cnt; i++) {
+		*ins++ = nativeTag; /* TODO: better way? */
+	    }
+	}
+    }
+#endif
+
     if (verifyCount != method->insSize) {
         LOGE("Got vfycount=%d insSize=%d for %s.%s\n", verifyCount,
             method->insSize, clazz->descriptor, method->name);
@@ -738,8 +990,15 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
          */
         (*method->nativeFunc)(self->curFrame, &retval, method, self);
         TRACE_METHOD_EXIT(self, method);
+#ifdef WITH_TAINT_TRACKING
+	rtaint = ((u4*)self->curFrame)[slot_cnt];
+#endif
     } else {
+#ifdef WITH_TAINT_TRACKING
+        dvmInterpret(self, method, &retval, &rtaint);
+#else
         dvmInterpret(self, method, &retval);
+#endif
     }
 
     /*
@@ -769,6 +1028,9 @@ Object* dvmInvokeMethod(Object* obj, const Method* method,
          */
         if (returnType != NULL) {
             retObj = (Object*)dvmWrapPrimitive(retval, returnType);
+#ifdef WITH_TAINT_TRACKING
+	    dvmSetPrimitiveTaint((DataObject *)retObj, returnType, rtaint);
+#endif
             dvmReleaseTrackedAlloc(retObj, NULL);
         }
     }
@@ -777,6 +1039,7 @@ bail:
     if (needPop) {
         dvmPopFrame(self);
     }
+bail_popped:
     return retObj;
 }
 
diff --git a/vm/interp/Stack.h b/vm/interp/Stack.h
index 3f76cb1..e984f3c 100644
--- a/vm/interp/Stack.h
+++ b/vm/interp/Stack.h
@@ -163,11 +163,21 @@ struct StackSaveArea {
 #define FP_FROM_SAVEAREA(_save) ((void*) ((StackSaveArea*)(_save) +1))
 
 /* when calling a function, get a pointer to outs[0] */
+#ifdef WITH_TAINT_TRACKING
+#define OUTS_FROM_FP(_fp, _argCount) \
+    ((u4*) ((u1*)SAVEAREA_FROM_FP(_fp) - \
+	( ((sizeof(u4) * (_argCount))<<1) +4) ))
+#else /* ndef WITH_TAINT_TRACKING */
 #define OUTS_FROM_FP(_fp, _argCount) \
     ((u4*) ((u1*)SAVEAREA_FROM_FP(_fp) - sizeof(u4) * (_argCount)))
+#endif /* WITH_TAINT_TRACKING */
 
 /* reserve this many bytes for handling StackOverflowError */
-#define STACK_OVERFLOW_RESERVE  768
+#ifdef WITH_TAINT_TRACKING
+# define STACK_OVERFLOW_RESERVE  1024
+#else
+# define STACK_OVERFLOW_RESERVE  512
+#endif
 
 /*
  * Determine if the frame pointer points to a "break frame".
diff --git a/vm/mterp/c/OP_APUT_OBJECT.c b/vm/mterp/c/OP_APUT_OBJECT.c
index 07e48c6..575f963 100644
--- a/vm/mterp/c/OP_APUT_OBJECT.c
+++ b/vm/mterp/c/OP_APUT_OBJECT.c
@@ -35,6 +35,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         dvmSetObjectArrayElement(arrayObj,
                                  GET_REGISTER(vsrc2),
                                  (Object *)GET_REGISTER(vdst));
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
diff --git a/vm/mterp/c/gotoTargets.c b/vm/mterp/c/gotoTargets.c
index 0db6fb7..7d74669 100644
--- a/vm/mterp/c/gotoTargets.c
+++ b/vm/mterp/c/gotoTargets.c
@@ -99,6 +99,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -776,6 +779,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -786,8 +792,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -806,9 +835,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -823,6 +899,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -844,13 +921,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
@@ -873,8 +960,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -946,6 +1040,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
 
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 #if (INTERP_TYPE == INTERP_DBG)
             if (gDvm.debuggerActive) {
                 dvmDbgPostLocationEvent(methodToCall, -1,
diff --git a/vm/mterp/c/opcommon.c b/vm/mterp/c/opcommon.c
index 43ee5bc..78c6f02 100644
--- a/vm/mterp/c/opcommon.c
+++ b/vm/mterp/c/opcommon.c
@@ -31,6 +31,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -56,6 +60,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -65,6 +73,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -91,6 +102,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -132,6 +146,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -167,6 +184,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -181,6 +202,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -214,6 +239,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -248,6 +276,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -263,6 +294,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -294,6 +328,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -303,6 +341,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -339,6 +381,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -353,6 +399,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -386,6 +436,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -395,6 +449,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -408,6 +466,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -422,6 +484,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -432,6 +498,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -441,6 +511,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -466,6 +540,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -492,6 +570,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -536,6 +619,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -554,6 +642,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -581,6 +676,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -599,6 +698,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -628,6 +733,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -652,5 +760,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
diff --git a/vm/mterp/common/asm-constants.h b/vm/mterp/common/asm-constants.h
index aeed88b..eeaf8c5 100644
--- a/vm/mterp/common/asm-constants.h
+++ b/vm/mterp/common/asm-constants.h
@@ -89,6 +89,58 @@ MTERP_SIZEOF(sizeofGlobal_activeProfilers, gDvm.activeProfilers, 4)
 MTERP_OFFSET(offGlue_pc,                MterpGlue, pc, 0)
 MTERP_OFFSET(offGlue_fp,                MterpGlue, fp, 4)
 MTERP_OFFSET(offGlue_retval,            MterpGlue, retval, 8)
+/*-----------------------------------------------------------------*/
+#ifdef WITH_TAINT_TRACKING
+/* Adjustements required for InterpState.rtaint */
+MTERP_OFFSET(offGlue_rtaint,		MterpGlue, rtaint, 16)
+MTERP_OFFSET(offGlue_method,            MterpGlue, method, 20)
+MTERP_OFFSET(offGlue_methodClassDex,    MterpGlue, methodClassDex, 24)
+MTERP_OFFSET(offGlue_self,              MterpGlue, self, 28)
+MTERP_OFFSET(offGlue_bailPtr,           MterpGlue, bailPtr, 32)
+MTERP_OFFSET(offGlue_interpStackEnd,    MterpGlue, interpStackEnd, 36)
+MTERP_OFFSET(offGlue_pSelfSuspendCount, MterpGlue, pSelfSuspendCount, 40)
+MTERP_OFFSET(offGlue_cardTable,         MterpGlue, cardTable, 40)
+MTERP_OFFSET(offGlue_pDebuggerActive,   MterpGlue, pDebuggerActive, 44)
+MTERP_OFFSET(offGlue_pActiveProfilers,  MterpGlue, pActiveProfilers, 48)
+#if defined(WITH_DEBUGGER) && defined(WITH_PROFILER)
+MTERP_OFFSET(offGlue_pDebuggerActive,   MterpGlue, pDebuggerActive, 44)
+MTERP_OFFSET(offGlue_pActiveProfilers,  MterpGlue, pActiveProfilers, 48)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 52)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 60)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 64)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 68)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 72)
+#endif
+#elif defined(WITH_DEBUGGER)
+MTERP_OFFSET(offGlue_pDebuggerActive,   MterpGlue, pDebuggerActive, 44)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 48)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 56)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 60)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 64)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 68)
+#endif
+#elif defined(WITH_PROFILER)
+MTERP_OFFSET(offGlue_pActiveProfilers,  MterpGlue, pActiveProfilers, 44)
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 48)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 56)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 60)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 64)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 68)
+#endif
+#else
+MTERP_OFFSET(offGlue_entryPoint,        MterpGlue, entryPoint, 44)
+#if defined(WITH_JIT)
+MTERP_OFFSET(offGlue_pJitProfTable,     MterpGlue, pJitProfTable, 52)
+MTERP_OFFSET(offGlue_jitState,          MterpGlue, jitState, 56)
+MTERP_OFFSET(offGlue_jitResume,         MterpGlue, jitResume, 60)
+MTERP_OFFSET(offGlue_jitResumePC,       MterpGlue, jitResumePC, 64)
+#endif
+#endif
+/*-----------------------------------------------------------------*/
+#else /* ndef WITH_TAINT_TRACKING */
 MTERP_OFFSET(offGlue_method,            MterpGlue, method, 16)
 MTERP_OFFSET(offGlue_methodClassDex,    MterpGlue, methodClassDex, 20)
 MTERP_OFFSET(offGlue_self,              MterpGlue, self, 24)
@@ -108,6 +160,7 @@ MTERP_OFFSET(offGlue_jitThreshold,      MterpGlue, jitThreshold, 76)
 MTERP_OFFSET(offGlue_ppJitProfTable,    MterpGlue, ppJitProfTable, 80)
 MTERP_OFFSET(offGlue_icRechainCount,    MterpGlue, icRechainCount, 84)
 #endif
+#endif
 /* make sure all JValue union members are stored at the same offset */
 MTERP_OFFSET(offGlue_retval_z,          MterpGlue, retval.z, 8)
 MTERP_OFFSET(offGlue_retval_i,          MterpGlue, retval.i, 8)
diff --git a/vm/mterp/config-armv7-a b/vm/mterp/config-armv7-a
index e66640c..c42cbe6 100644
--- a/vm/mterp/config-armv7-a
+++ b/vm/mterp/config-armv7-a
@@ -28,7 +28,7 @@ asm-stub armv5te/stub.S
 
 # file header and basic definitions
 import c/header.c
-import armv5te/header.S
+import armv5te_taint/header.S
 
 # C pre-processor defines for stub C instructions
 import cstubs/stubdefs.c
@@ -40,127 +40,116 @@ import armv7-a/platform.S
 import c/opcommon.c
 
 # arch-specific entry point to interpreter
-import armv5te/entry.S
+import armv5te_taint/entry.S
+#import armv5te/entry.S
 
 # opcode list; argument to op-start is default directory
-op-start armv5te
-    # handlers that take advantage of >= ARMv6T2 instructions
-    op OP_ADD_DOUBLE_2ADDR armv6t2
-    op OP_ADD_FLOAT_2ADDR armv6t2
-    op OP_ADD_INT_2ADDR armv6t2
-    op OP_ADD_INT_LIT16 armv6t2
-    op OP_ADD_LONG_2ADDR armv6t2
-    op OP_AND_INT_2ADDR armv6t2
-    op OP_AND_INT_LIT16 armv6t2
-    op OP_AND_LONG_2ADDR armv6t2
-    op OP_ARRAY_LENGTH armv6t2
-    op OP_CONST_4 armv6t2
-    op OP_DIV_DOUBLE_2ADDR armv6t2
-    op OP_DIV_FLOAT_2ADDR armv6t2
-    op OP_DIV_INT_2ADDR armv6t2
-    op OP_DIV_INT_LIT16 armv6t2
-    op OP_DIV_LONG_2ADDR armv6t2
-    op OP_DOUBLE_TO_FLOAT armv6t2
-    op OP_DOUBLE_TO_INT armv6t2
-    op OP_DOUBLE_TO_LONG armv6t2
-    op OP_FLOAT_TO_DOUBLE armv6t2
-    op OP_FLOAT_TO_INT armv6t2
-    op OP_FLOAT_TO_LONG armv6t2
-    op OP_IF_EQ armv6t2
-    op OP_IF_GE armv6t2
-    op OP_IF_GT armv6t2
-    op OP_IF_LE armv6t2
-    op OP_IF_LT armv6t2
-    op OP_IF_NE armv6t2
-    op OP_IGET armv6t2
-    op OP_IGET_QUICK armv6t2
-    op OP_IGET_WIDE armv6t2
-    op OP_IGET_WIDE_QUICK armv6t2
-    op OP_INT_TO_BYTE armv6t2
-    op OP_INT_TO_CHAR armv6t2
-    op OP_INT_TO_DOUBLE armv6t2
-    op OP_INT_TO_FLOAT armv6t2
-    op OP_INT_TO_LONG armv6t2
-    op OP_INT_TO_SHORT armv6t2
-    op OP_IPUT armv6t2
-    op OP_IPUT_QUICK armv6t2
-    op OP_IPUT_WIDE armv6t2
-    op OP_IPUT_WIDE_QUICK armv6t2
-    op OP_LONG_TO_DOUBLE armv6t2
-    op OP_LONG_TO_FLOAT armv6t2
-    op OP_MOVE armv6t2
-    op OP_MOVE_WIDE armv6t2
-    op OP_MUL_DOUBLE_2ADDR armv6t2
-    op OP_MUL_FLOAT_2ADDR armv6t2
-    op OP_MUL_INT_2ADDR armv6t2
-    op OP_MUL_INT_LIT16 armv6t2
-    op OP_MUL_LONG_2ADDR armv6t2
-    op OP_NEG_DOUBLE armv6t2
-    op OP_NEG_FLOAT armv6t2
-    op OP_NEG_INT armv6t2
-    op OP_NEG_LONG armv6t2
-    op OP_NOT_INT armv6t2
-    op OP_NOT_LONG armv6t2
-    op OP_OR_INT_2ADDR armv6t2
-    op OP_OR_INT_LIT16 armv6t2
-    op OP_OR_LONG_2ADDR armv6t2
-    op OP_REM_DOUBLE_2ADDR armv6t2
-    op OP_REM_FLOAT_2ADDR armv6t2
-    op OP_REM_INT_2ADDR armv6t2
-    op OP_REM_INT_LIT16 armv6t2
-    op OP_REM_LONG_2ADDR armv6t2
-    op OP_RSUB_INT armv6t2
-    op OP_SHL_INT_2ADDR armv6t2
-    op OP_SHL_LONG_2ADDR armv6t2
-    op OP_SHR_INT_2ADDR armv6t2
-    op OP_SHR_LONG_2ADDR armv6t2
-    op OP_SUB_DOUBLE_2ADDR armv6t2
-    op OP_SUB_FLOAT_2ADDR armv6t2
-    op OP_SUB_INT_2ADDR armv6t2
-    op OP_SUB_LONG_2ADDR armv6t2
-    op OP_USHR_INT_2ADDR armv6t2
-    op OP_USHR_LONG_2ADDR armv6t2
-    op OP_XOR_INT_2ADDR armv6t2
-    op OP_XOR_INT_LIT16 armv6t2
-    op OP_XOR_LONG_2ADDR armv6t2
-
-    # floating point handlers that use VFP
-    # these override the handlers specified earlier
-    op OP_ADD_DOUBLE arm-vfp
-    op OP_ADD_DOUBLE_2ADDR arm-vfp
-    op OP_ADD_FLOAT arm-vfp
-    op OP_ADD_FLOAT_2ADDR arm-vfp
-    op OP_CMPG_DOUBLE arm-vfp
-    op OP_CMPG_FLOAT arm-vfp
-    op OP_CMPL_DOUBLE arm-vfp
-    op OP_CMPL_FLOAT arm-vfp
-    op OP_DIV_DOUBLE arm-vfp
-    op OP_DIV_DOUBLE_2ADDR arm-vfp
-    op OP_DIV_FLOAT arm-vfp
-    op OP_DIV_FLOAT_2ADDR arm-vfp
-    op OP_DOUBLE_TO_FLOAT arm-vfp
-    op OP_DOUBLE_TO_INT arm-vfp
-    op OP_FLOAT_TO_DOUBLE arm-vfp
-    op OP_FLOAT_TO_INT arm-vfp
-    op OP_INT_TO_DOUBLE arm-vfp
-    op OP_INT_TO_FLOAT arm-vfp
-    op OP_MUL_DOUBLE arm-vfp
-    op OP_MUL_DOUBLE_2ADDR arm-vfp
-    op OP_MUL_FLOAT arm-vfp
-    op OP_MUL_FLOAT_2ADDR arm-vfp
-    op OP_SUB_DOUBLE arm-vfp
-    op OP_SUB_DOUBLE_2ADDR arm-vfp
-    op OP_SUB_FLOAT arm-vfp
-    op OP_SUB_FLOAT_2ADDR arm-vfp
+op-start armv5te_taint
+	# bincmp.S (unmodified)
+	op OP_IF_EQ armv6t2_taint
+	op OP_IF_GE armv6t2_taint
+	op OP_IF_GT armv6t2_taint
+	op OP_IF_LE armv6t2_taint
+	op OP_IF_LT armv6t2_taint
+	op OP_IF_NE armv6t2_taint
+    
+	# binop2addr.S
+	op OP_ADD_FLOAT_2ADDR armv6t2_taint    
+	op OP_ADD_INT_2ADDR armv6t2_taint
+	op OP_AND_INT_2ADDR armv6t2_taint
+	op OP_DIV_FLOAT_2ADDR armv6t2_taint
+	op OP_DIV_INT_2ADDR armv6t2_taint
+	op OP_MUL_FLOAT_2ADDR armv6t2_taint
+	op OP_MUL_INT_2ADDR armv6t2_taint
+	op OP_OR_INT_2ADDR armv6t2_taint
+	op OP_REM_FLOAT_2ADDR armv6t2_taint
+	op OP_REM_INT_2ADDR armv6t2_taint
+	op OP_SHL_INT_2ADDR armv6t2_taint
+	op OP_SHR_INT_2ADDR armv6t2_taint
+	op OP_SUB_FLOAT_2ADDR armv6t2_taint
+	op OP_SUB_INT_2ADDR armv6t2_taint
+	op OP_USHR_INT_2ADDR armv6t2_taint
+	op OP_XOR_INT_2ADDR armv6t2_taint
+
+	# unop.S
+	op OP_FLOAT_TO_INT armv6t2_taint
+	op OP_INT_TO_BYTE armv6t2_taint
+	op OP_INT_TO_CHAR armv6t2_taint
+	op OP_INT_TO_FLOAT armv6t2_taint
+	op OP_INT_TO_SHORT armv6t2_taint
+	op OP_NEG_FLOAT armv6t2_taint
+	op OP_NEG_INT armv6t2_taint
+	op OP_NOT_INT armv6t2_taint
+
+
+	# arm-vfp_taint
+
+	# fbinop.S
+	op OP_ADD_FLOAT arm-vfp_taint
+	op OP_DIV_FLOAT arm-vfp_taint
+	op OP_MUL_FLOAT arm-vfp_taint
+	op OP_SUB_FLOAT arm-vfp_taint
+
+	# funops.S
+	op OP_FLOAT_TO_INT arm-vfp_taint
+	op OP_INT_TO_FLOAT arm-vfp_taint
+
+	# fbinop2addr.S
+	op OP_ADD_FLOAT_2ADDR arm-vfp_taint
+	op OP_DIV_FLOAT_2ADDR arm-vfp_taint
+	op OP_MUL_FLOAT_2ADDR arm-vfp_taint
+	op OP_SUB_FLOAT_2ADDR arm-vfp_taint
+
+	# fbinopWide.S
+	op OP_ADD_DOUBLE arm-vfp_taint
+	op OP_DIV_DOUBLE arm-vfp_taint
+	op OP_MUL_DOUBLE arm-vfp_taint
+	op OP_SUB_DOUBLE arm-vfp_taint	
+
+	# fbinopWide2addr.S
+	op OP_ADD_DOUBLE_2ADDR arm-vfp_taint
+	op OP_DIV_DOUBLE_2ADDR arm-vfp_taint
+	op OP_MUL_DOUBLE_2ADDR arm-vfp_taint
+	op OP_SUB_DOUBLE_2ADDR arm-vfp_taint
+
+	# funopNarrower.S
+	op OP_DOUBLE_TO_INT arm-vfp_taint
+	op OP_DOUBLE_TO_FLOAT arm-vfp_taint
+
+	# funopWider.S
+	op OP_INT_TO_DOUBLE arm-vfp_taint
+	op OP_FLOAT_TO_DOUBLE arm-vfp_taint	
+
+	# cmp
+	op OP_CMPG_DOUBLE arm-vfp_taint
+	op OP_CMPG_FLOAT arm-vfp_taint
+	op OP_CMPL_DOUBLE arm-vfp_taint
+	op OP_CMPL_FLOAT arm-vfp_taint
+
+	# still using c versions for invoking native code
+	op OP_INVOKE_DIRECT_RANGE c
+	op OP_INVOKE_DIRECT c
+	op OP_INVOKE_INTERFACE_RANGE c
+	op OP_INVOKE_INTERFACE c
+	op OP_INVOKE_STATIC_RANGE c
+	op OP_INVOKE_STATIC c
+	op OP_INVOKE_SUPER_QUICK_RANGE c
+	op OP_INVOKE_SUPER_QUICK c
+	op OP_INVOKE_SUPER_RANGE c
+	op OP_INVOKE_SUPER c
+	op OP_INVOKE_VIRTUAL_QUICK_RANGE c
+	op OP_INVOKE_VIRTUAL_QUICK c
+	op OP_INVOKE_VIRTUAL_RANGE c
+	op OP_INVOKE_VIRTUAL c
 op-end
 
 # "helper" code for C; include if you use any of the C stubs (this generates
 # object code, so it's normally excluded)
-##import c/gotoTargets.c
+import c/gotoTargets.c
 
 # end of defs; include this when cstubs/stubdefs.c is included
 import cstubs/enddefs.c
 
 # common subroutines for asm
-import armv5te/footer.S
+import armv5te_taint/footer.S
 import armv5te/debug.c
diff --git a/vm/mterp/out/InterpAsm-armv7-a.S b/vm/mterp/out/InterpAsm-armv7-a.S
index ac5b2c3..d22a680 100644
--- a/vm/mterp/out/InterpAsm-armv7-a.S
+++ b/vm/mterp/out/InterpAsm-armv7-a.S
@@ -4,7 +4,7 @@
  * --> DO NOT EDIT <--
  */
 
-/* File: armv5te/header.S */
+/* File: armv5te_taint/header.S */
 /*
  * Copyright (C) 2008 The Android Open Source Project
  *
@@ -20,7 +20,6 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  */
-
 /*
  * ARMv5 definitions and declarations.
  */
@@ -182,19 +181,33 @@ unspecified registers or condition codes.
 /*
  * Get/set the 32-bit value from a Dalvik register.
  */
+#ifdef WITH_TAINT_TRACKING
+#define SET_TAINT_FP(_reg)		add		_reg, rFP, #4
+#define SET_TAINT_CLEAR(_reg)	mov		_reg, #0
+#define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #3]
+#define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #3]
+#define GET_VREG_TAINT(_reg, _vreg, _rFP)	ldr	_reg, [_rFP, _vreg, lsl #3]
+#define SET_VREG_TAINT(_reg, _vreg, _rFP)	str _reg, [_rFP, _vreg, lsl #3]
+#else
 #define GET_VREG(_reg, _vreg)   ldr     _reg, [rFP, _vreg, lsl #2]
 #define SET_VREG(_reg, _vreg)   str     _reg, [rFP, _vreg, lsl #2]
+#endif /*WITH_TAINT_TRACKING*/
 
 #if defined(WITH_JIT)
+#define GET_JIT_ENABLED(_reg)       ldr     _reg,[rGLUE,#offGlue_jitEnabled]
 #define GET_JIT_PROF_TABLE(_reg)    ldr     _reg,[rGLUE,#offGlue_pJitProfTable]
-#define GET_JIT_THRESHOLD(_reg)     ldr     _reg,[rGLUE,#offGlue_jitThreshold]
 #endif
 
 /*
  * Convert a virtual register index into an address.
  */
+#ifdef WITH_TAINT_TRACKING
+#define VREG_INDEX_TO_ADDR(_reg, _vreg) \
+        add     _reg, rFP, _vreg, lsl #3
+#else
 #define VREG_INDEX_TO_ADDR(_reg, _vreg) \
         add     _reg, rFP, _vreg, lsl #2
+#endif /*WITH_TAINT_TRACKING*/
 
 /*
  * This is a #include, not a %include, because we want the C pre-processor
@@ -202,10 +215,6 @@ unspecified registers or condition codes.
  */
 #include "../common/asm-constants.h"
 
-#if defined(WITH_JIT)
-#include "../common/jit-config.h"
-#endif
-
 /* File: armv7-a/platform.S */
 /*
  * ===========================================================================
@@ -259,7 +268,7 @@ unspecified registers or condition codes.
 #endif
 .endm
 
-/* File: armv5te/entry.S */
+/* File: armv5te_taint/entry.S */
 /*
  * Copyright (C) 2008 The Android Open Source Project
  *
@@ -322,35 +331,19 @@ dvmMterpStdRun:
 
     /* set up "named" registers, figure out entry point */
     mov     rGLUE, r0                   @ set rGLUE
-    ldr     r1, [r0, #offGlue_entryPoint]   @ enum is 4 bytes in aapcs-EABI
+    ldrb    r1, [r0, #offGlue_entryPoint]   @ InterpEntry enum is char
     LOAD_PC_FP_FROM_GLUE()              @ load rPC and rFP from "glue"
     adr     rIBASE, dvmAsmInstructionStart  @ set rIBASE
     cmp     r1, #kInterpEntryInstr      @ usual case?
     bne     .Lnot_instr                 @ no, handle it
 
 #if defined(WITH_JIT)
-.LentryInstr:
-    ldr     r10, [rGLUE, #offGlue_self] @ callee saved r10 <- glue->self
+.Lno_singleStep:
     /* Entry is always a possible trace start */
     GET_JIT_PROF_TABLE(r0)
     FETCH_INST()
-    mov     r1, #0                      @ prepare the value for the new state
-    str     r1, [r10, #offThread_inJitCodeCache] @ back to the interp land
-    cmp     r0,#0                       @ is profiling disabled?
-#if !defined(WITH_SELF_VERIFICATION)
-    bne     common_updateProfile        @ profiling is enabled
-#else
-    ldr     r2, [r10, #offThread_shadowSpace]   @ to find out the jit exit state
-    beq     1f                          @ profiling is disabled
-    ldr     r3, [r2, #offShadowSpace_jitExitState]  @ jit exit state
-    cmp     r3, #kSVSTraceSelect        @ hot trace following?
-    moveq   r2,#kJitTSelectRequestHot   @ ask for trace selection
-    beq     common_selectTrace          @ go build the trace
-    cmp     r3, #kSVSNoProfile          @ don't profile the next instruction?
-    beq     1f                          @ intrepret the next instruction
-    b       common_updateProfile        @ collect profiles
-#endif
-1:
+    cmp    r0,#0
+    bne    common_updateProfile
     GET_INST_OPCODE(ip)
     GOTO_OPCODE(ip)
 #else
@@ -370,21 +363,18 @@ dvmMterpStdRun:
 
 #if defined(WITH_JIT)
 .Lnot_throw:
-    ldr     r10,[rGLUE, #offGlue_jitResumeNPC]
-    ldr     r2,[rGLUE, #offGlue_jitResumeDPC]
+    ldr     r0,[rGLUE, #offGlue_jitResume]
+    ldr     r2,[rGLUE, #offGlue_jitResumePC]
     cmp     r1, #kInterpEntryResume     @ resuming after Jit single-step?
     bne     .Lbad_arg
     cmp     rPC,r2
-    bne     .LentryInstr                @ must have branched, don't resume
-#if defined(WITH_SELF_VERIFICATION)
-    @ glue->entryPoint will be set in dvmSelfVerificationSaveState
-    b       jitSVShadowRunStart         @ re-enter the translation after the
-                                        @ single-stepped instruction
-    @noreturn
-#endif
+    bne     .Lno_singleStep             @ must have branched, don't resume
     mov     r1, #kInterpEntryInstr
-    str     r1, [rGLUE, #offGlue_entryPoint]
-    bx      r10                         @ re-enter the translation
+    strb    r1, [rGLUE, #offGlue_entryPoint]
+    ldr     rINST, .LdvmCompilerTemplate
+    bx      r0                          @ re-enter the translation
+.LdvmCompilerTemplate:
+    .word   dvmCompilerTemplateStart
 #endif
 
 .Lbad_arg:
@@ -433,7 +423,7 @@ dvmAsmInstructionStart = .L_OP_NOP
 /* ------------------------------ */
     .balign 64
 .L_OP_NOP: /* 0x00 */
-/* File: armv5te/OP_NOP.S */
+/* File: armv5te_taint/OP_NOP.S */
     FETCH_ADVANCE_INST(1)               @ advance to next instr, load rINST
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     GOTO_OPCODE(ip)                     @ execute it
@@ -451,13 +441,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE: /* 0x01 */
-/* File: armv6t2/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
-    ubfx    r0, rINST, #8, #4           @ r0<- A from 11:8
+    mov     r0, rINST, lsr #8           @ r0<- A from 11:8
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -465,13 +461,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_FROM16: /* 0x02 */
-/* File: armv5te/OP_MOVE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_FROM16.S */
     /* for: move/from16, move-object/from16 */
     /* op vAA, vBBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     mov     r0, rINST, lsr #8           @ r0<- AA
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -479,13 +480,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_16: /* 0x03 */
-/* File: armv5te/OP_MOVE_16.S */
+/* File: armv5te_taint/OP_MOVE_16.S */
     /* for: move/16, move-object/16 */
     /* op vAAAA, vBBBB */
     FETCH(r1, 2)                        @ r1<- BBBB
     FETCH(r0, 1)                        @ r0<- AAAA
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AAAA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -493,56 +499,69 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE: /* 0x04 */
-/* File: armv6t2/OP_MOVE_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_WIDE.S */
     /* move-wide vA, vB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r2, rINST, #8, #4           @ r2<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[B]
+    and     r2, r2, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[A]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[B]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[A]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_FROM16: /* 0x05 */
-/* File: armv5te/OP_MOVE_WIDE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_FROM16.S */
     /* move-wide/from16 vAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 1)                        @ r3<- BBBB
     mov     r2, rINST, lsr #8           @ r2<- AA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_WIDE_16: /* 0x06 */
-/* File: armv5te/OP_MOVE_WIDE_16.S */
+/* File: armv5te_taint/OP_MOVE_WIDE_16.S */
     /* move-wide/16 vAAAA, vBBBB */
     /* NOTE: regs can overlap, e.g. "move v6,v7" or "move v7,v6" */
     FETCH(r3, 2)                        @ r3<- BBBB
     FETCH(r2, 1)                        @ r2<- AAAA
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BBBB]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AAAA]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[BBBB]
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BBBB]
+    add     r9, rFP, r2, lsl #3         @ r9<- &fp[AAAA]
+    ldmia   r3, {r0-r3}                 @ r0/r1<- fp[BBBB]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AAAA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ fp[AAAA]<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT: /* 0x07 */
-/* File: armv5te/OP_MOVE_OBJECT.S */
-/* File: armv5te/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
@@ -550,6 +569,11 @@ dalvik_inst:
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
     and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -558,14 +582,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT_FROM16: /* 0x08 */
-/* File: armv5te/OP_MOVE_OBJECT_FROM16.S */
-/* File: armv5te/OP_MOVE_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT_FROM16.S */
+/* File: armv5te_taint/OP_MOVE_FROM16.S */
     /* for: move/from16, move-object/from16 */
     /* op vAA, vBBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     mov     r0, rINST, lsr #8           @ r0<- AA
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -574,14 +603,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_OBJECT_16: /* 0x09 */
-/* File: armv5te/OP_MOVE_OBJECT_16.S */
-/* File: armv5te/OP_MOVE_16.S */
+/* File: armv5te_taint/OP_MOVE_OBJECT_16.S */
+/* File: armv5te_taint/OP_MOVE_16.S */
     /* for: move/16, move-object/16 */
     /* op vAAAA, vBBBB */
     FETCH(r1, 2)                        @ r1<- BBBB
     FETCH(r0, 1)                        @ r0<- AAAA
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[BBBB]
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r0)                    @ fp[AAAA]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -590,7 +624,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT: /* 0x0a */
-/* File: armv5te/OP_MOVE_RESULT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT.S */
     /* for: move-result, move-result-object */
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -598,27 +632,41 @@ dalvik_inst:
     ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_WIDE: /* 0x0b */
-/* File: armv5te/OP_MOVE_RESULT_WIDE.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_WIDE.S */
     /* move-result-wide vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
     ldmia   r3, {r0-r1}                 @ r0/r1<- retval.j
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r2, {r0-r1}                 @ fp[AA]<- r0/r1
+	ldr r3, [rGLUE, #offGlue_rtaint]
+	str	r0, [r2, #0]
+	str r3, [r2, #4]
+	str r1, [r2, #8]
+	str r3, [r2, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_RESULT_OBJECT: /* 0x0c */
-/* File: armv5te/OP_MOVE_RESULT_OBJECT.S */
-/* File: armv5te/OP_MOVE_RESULT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT_OBJECT.S */
+/* File: armv5te_taint/OP_MOVE_RESULT.S */
     /* for: move-result, move-result-object */
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -626,13 +674,18 @@ dalvik_inst:
     ldr     r0, [rGLUE, #offGlue_retval]    @ r0<- glue->retval.i
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[AA]<- r0
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [rGLUE, #offGlue_rtaint]
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r0, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MOVE_EXCEPTION: /* 0x0d */
-/* File: armv5te/OP_MOVE_EXCEPTION.S */
+/* File: armv5te_taint/OP_MOVE_EXCEPTION.S */
     /* move-exception vAA */
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
     mov     r2, rINST, lsr #8           @ r2<- AA
@@ -640,6 +693,11 @@ dalvik_inst:
     mov     r1, #0                      @ r1<- 0
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     SET_VREG(r3, r2)                    @ fp[AA]<- exception obj
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	SET_TAINT_CLEAR(r9)
+	SET_VREG_TAINT(r9, r2, r3)
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r1, [r0, #offThread_exception]  @ dvmClearException bypass
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -647,13 +705,15 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_VOID: /* 0x0e */
-/* File: armv5te/OP_RETURN_VOID.S */
+/* File: armv5te_taint/OP_RETURN_VOID.S */
+	SET_TAINT_CLEAR(r1)
+	str		r1, [rGLUE, #offGlue_rtaint]
     b       common_returnFromMethod
 
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN: /* 0x0f */
-/* File: armv5te/OP_RETURN.S */
+/* File: armv5te_taint/OP_RETURN.S */
     /*
      * Return a 32-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
@@ -663,30 +723,43 @@ dalvik_inst:
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     GET_VREG(r0, r2)                    @ r0<- vAA
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r3, r2, r1)
+	str		r3, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     str     r0, [rGLUE, #offGlue_retval] @ retval.i <- vAA
     b       common_returnFromMethod
 
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_WIDE: /* 0x10 */
-/* File: armv5te/OP_RETURN_WIDE.S */
+/* File: armv5te_taint/OP_RETURN_WIDE.S */
     /*
      * Return a 64-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
      */
     /* return-wide vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[AA]
+// end WITH_TAINT_TRACKING
     add     r3, rGLUE, #offGlue_retval  @ r3<- &glue->retval
-    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1 <- vAA/vAA+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r9, [r2, #4]
+	str		r9, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     stmia   r3, {r0-r1}                 @ retval<- r0/r1
     b       common_returnFromMethod
 
 /* ------------------------------ */
     .balign 64
 .L_OP_RETURN_OBJECT: /* 0x11 */
-/* File: armv5te/OP_RETURN_OBJECT.S */
-/* File: armv5te/OP_RETURN.S */
+/* File: armv5te_taint/OP_RETURN_OBJECT.S */
+/* File: armv5te_taint/OP_RETURN.S */
     /*
      * Return a 32-bit value.  Copies the return value into the "glue"
      * structure, then jumps to the return handler.
@@ -696,6 +769,11 @@ dalvik_inst:
     /* op vAA */
     mov     r2, rINST, lsr #8           @ r2<- AA
     GET_VREG(r0, r2)                    @ r0<- vAA
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r3, r2, r1)
+	str		r3, [rGLUE, #offGlue_rtaint]
+// end WITH_TAINT_TRACKING
     str     r0, [rGLUE, #offGlue_retval] @ retval.i <- vAA
     b       common_returnFromMethod
 
@@ -703,12 +781,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_4: /* 0x12 */
-/* File: armv6t2/OP_CONST_4.S */
+/* File: armv5te_taint/OP_CONST_4.S */
     /* const/4 vA, #+B */
     mov     r1, rINST, lsl #16          @ r1<- Bxxx0000
-    ubfx    r0, rINST, #8, #4           @ r0<- A
+    mov     r0, rINST, lsr #8           @ r0<- A+
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mov     r1, r1, asr #28             @ r1<- sssssssB (sign-extended)
+    and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r0, r2)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r1, r0)                    @ fp[A]<- r1
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -716,10 +800,15 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_16: /* 0x13 */
-/* File: armv5te/OP_CONST_16.S */
+/* File: armv5te_taint/OP_CONST_16.S */
     /* const/16 vAA, #+BBBB */
     FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r2)
+    SET_VREG_TAINT(r2, r3, r1)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -728,13 +817,18 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST: /* 0x14 */
-/* File: armv5te/OP_CONST.S */
+/* File: armv5te_taint/OP_CONST.S */
     /* const vAA, #+BBBBbbbb */
     mov     r3, rINST, lsr #8           @ r3<- AA
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (high)
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -742,11 +836,16 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_HIGH16: /* 0x15 */
-/* File: armv5te/OP_CONST_HIGH16.S */
+/* File: armv5te_taint/OP_CONST_HIGH16.S */
     /* const/high16 vAA, #+BBBB0000 */
     FETCH(r0, 1)                        @ r0<- 0000BBBB (zero-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
     mov     r0, r0, lsl #16             @ r0<- BBBB0000
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -755,37 +854,51 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_16: /* 0x16 */
-/* File: armv5te/OP_CONST_WIDE_16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_16.S */
     /* const-wide/16 vAA, #+BBBB */
     FETCH_S(r0, 1)                      @ r0<- ssssBBBB (sign-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    mov     r2, r0, asr #31             @ r1<- ssssssss
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_32: /* 0x17 */
-/* File: armv5te/OP_CONST_WIDE_32.S */
+/* File: armv5te_taint/OP_CONST_WIDE_32.S */
     /* const-wide/32 vAA, #+BBBBbbbb */
     FETCH(r0, 1)                        @ r0<- 0000bbbb (low)
     mov     r3, rINST, lsr #8           @ r3<- AA
     FETCH_S(r2, 2)                      @ r2<- ssssBBBB (high)
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     orr     r0, r0, r2, lsl #16         @ r0<- BBBBbbbb
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
-    mov     r1, r0, asr #31             @ r1<- ssssssss
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r9<- &fp[AA]
+    mov     r2, r0, asr #31             @ r2<- ssssssss
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE: /* 0x18 */
-/* File: armv5te/OP_CONST_WIDE.S */
+/* File: armv5te_taint/OP_CONST_WIDE.S */
     /* const-wide vAA, #+HHHHhhhhBBBBbbbb */
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (low middle)
@@ -793,32 +906,48 @@ dalvik_inst:
     orr     r0, r0, r1, lsl #16         @ r0<- BBBBbbbb (low word)
     FETCH(r3, 4)                        @ r3<- HHHH (high)
     mov     r9, rINST, lsr #8           @ r9<- AA
-    orr     r1, r2, r3, lsl #16         @ r1<- HHHHhhhh (high word)
+// begin WITH_TAINT_TRACKING
+    orr     r2, r2, r3, lsl #16         @ r2<- HHHHhhhh (high word)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(5)               @ advance rPC, load rINST
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_WIDE_HIGH16: /* 0x19 */
-/* File: armv5te/OP_CONST_WIDE_HIGH16.S */
+/* File: armv5te_taint/OP_CONST_WIDE_HIGH16.S */
     /* const-wide/high16 vAA, #+BBBB000000000000 */
     FETCH(r1, 1)                        @ r1<- 0000BBBB (zero-extended)
     mov     r3, rINST, lsr #8           @ r3<- AA
     mov     r0, #0                      @ r0<- 00000000
-    mov     r1, r1, lsl #16             @ r1<- BBBB0000
+// begin WITH_TAINT_TRACKING
+    mov     r2, r1, lsl #16             @ r1<- BBBB0000
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r3, lsl #3         @ r3<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ vAA<- r0/r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r1)
+	SET_TAINT_CLEAR(r3)
+    stmia   r9, {r0-r3}                 @ vAA<- r0/r1
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_STRING: /* 0x1a */
-/* File: armv5te/OP_CONST_STRING.S */
+/* File: armv5te_taint/OP_CONST_STRING.S */
     /* const/string vAA, String@BBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
@@ -827,6 +956,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
     cmp     r0, #0                      @ not yet resolved?
     beq     .LOP_CONST_STRING_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -835,7 +969,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_STRING_JUMBO: /* 0x1b */
-/* File: armv5te/OP_CONST_STRING_JUMBO.S */
+/* File: armv5te_taint/OP_CONST_STRING_JUMBO.S */
     /* const/string vAA, String@BBBBBBBB */
     FETCH(r0, 1)                        @ r0<- bbbb (low)
     FETCH(r1, 2)                        @ r1<- BBBB (high)
@@ -846,6 +980,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResStrings[BBBB]
     cmp     r0, #0
     beq     .LOP_CONST_STRING_JUMBO_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -854,7 +993,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CONST_CLASS: /* 0x1c */
-/* File: armv5te/OP_CONST_CLASS.S */
+/* File: armv5te_taint/OP_CONST_CLASS.S */
     /* const/class vAA, Class@BBBB */
     FETCH(r1, 1)                        @ r1<- BBBB
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- glue->methodClassDex
@@ -863,6 +1002,11 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- pResClasses[BBBB]
     cmp     r0, #0                      @ not yet resolved?
     beq     .LOP_CONST_CLASS_resolve
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -871,7 +1015,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MONITOR_ENTER: /* 0x1d */
-/* File: armv5te/OP_MONITOR_ENTER.S */
+/* File: armv5te_taint/OP_MONITOR_ENTER.S */
     /*
      * Synchronize on an object.
      */
@@ -896,7 +1040,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MONITOR_EXIT: /* 0x1e */
-/* File: armv5te/OP_MONITOR_EXIT.S */
+/* File: armv5te_taint/OP_MONITOR_EXIT.S */
     /*
      * Unlock an object.
      *
@@ -909,22 +1053,19 @@ dalvik_inst:
     EXPORT_PC()                         @ before fetch: export the PC
     GET_VREG(r1, r2)                    @ r1<- vAA (object)
     cmp     r1, #0                      @ null object?
-    beq     1f                          @ yes
+    beq     common_errNullObject        @ yes
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
     bl      dvmUnlockObject             @ r0<- success for unlock(self, obj)
     cmp     r0, #0                      @ failed?
-    FETCH_ADVANCE_INST(1)               @ before throw: advance rPC, load rINST
     beq     common_exceptionThrown      @ yes, exception is pending
+    FETCH_ADVANCE_INST(1)               @ before throw: advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
-1:
-    FETCH_ADVANCE_INST(1)               @ advance before throw
-    b      common_errNullObject
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CHECK_CAST: /* 0x1f */
-/* File: armv5te/OP_CHECK_CAST.S */
+/* File: armv5te_taint/OP_CHECK_CAST.S */
     /*
      * Check to see if a cast from one class to another is allowed.
      */
@@ -951,7 +1092,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INSTANCE_OF: /* 0x20 */
-/* File: armv5te/OP_INSTANCE_OF.S */
+/* File: armv5te_taint/OP_INSTANCE_OF.S */
     /*
      * Check to see if an object reference is an instance of a class.
      *
@@ -980,15 +1121,21 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ARRAY_LENGTH: /* 0x21 */
-/* File: armv6t2/OP_ARRAY_LENGTH.S */
+/* File: armv5te_taint/OP_ARRAY_LENGTH.S */
     /*
      * Return the length of an array.
      */
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    mov     r2, rINST, lsr #8           @ r2<- A+
     GET_VREG(r0, r1)                    @ r0<- vB (object ref)
+    and     r2, r2, #15                 @ r2<- A
     cmp     r0, #0                      @ is object null?
     beq     common_errNullObject        @ yup, fail
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- array length
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -998,7 +1145,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEW_INSTANCE: /* 0x22 */
-/* File: armv5te/OP_NEW_INSTANCE.S */
+/* File: armv5te_taint/OP_NEW_INSTANCE.S */
     /*
      * Create a new instance of a class.
      */
@@ -1022,7 +1169,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEW_ARRAY: /* 0x23 */
-/* File: armv5te/OP_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_NEW_ARRAY.S */
     /*
      * Allocate an array of objects, specified with the array class
      * and a count.
@@ -1047,7 +1194,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILLED_NEW_ARRAY: /* 0x24 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY.S */
     /*
      * Create a new array with elements filled from registers.
      *
@@ -1074,8 +1221,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILLED_NEW_ARRAY_RANGE: /* 0x25 */
-/* File: armv5te/OP_FILLED_NEW_ARRAY_RANGE.S */
-/* File: armv5te/OP_FILLED_NEW_ARRAY.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY_RANGE.S */
+/* File: armv5te_taint/OP_FILLED_NEW_ARRAY.S */
     /*
      * Create a new array with elements filled from registers.
      *
@@ -1103,7 +1250,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_FILL_ARRAY_DATA: /* 0x26 */
-/* File: armv5te/OP_FILL_ARRAY_DATA.S */
+/* File: armv5te_taint/OP_FILL_ARRAY_DATA.S */
     /* fill-array-data vAA, +BBBBBBBB */
     FETCH(r0, 1)                        @ r0<- bbbb (lo)
     FETCH(r1, 2)                        @ r1<- BBBB (hi)
@@ -1122,7 +1269,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_THROW: /* 0x27 */
-/* File: armv5te/OP_THROW.S */
+/* File: armv5te_taint/OP_THROW.S */
     /*
      * Throw an exception object in the current thread.
      */
@@ -1130,7 +1277,6 @@ dalvik_inst:
     mov     r2, rINST, lsr #8           @ r2<- AA
     GET_VREG(r1, r2)                    @ r1<- vAA (exception object)
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
-    EXPORT_PC()                         @ exception handler can throw
     cmp     r1, #0                      @ null object?
     beq     common_errNullObject        @ yes, throw an NPE instead
     @ bypass dvmSetException, just store it
@@ -1140,7 +1286,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO: /* 0x28 */
-/* File: armv5te/OP_GOTO.S */
+/* File: armv5te_taint/OP_GOTO.S */
     /*
      * Unconditional branch, 8-bit offset.
      *
@@ -1168,7 +1314,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO_16: /* 0x29 */
-/* File: armv5te/OP_GOTO_16.S */
+/* File: armv5te_taint/OP_GOTO_16.S */
     /*
      * Unconditional branch, 16-bit offset.
      *
@@ -1195,7 +1341,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_GOTO_32: /* 0x2a */
-/* File: armv5te/OP_GOTO_32.S */
+/* File: armv5te_taint/OP_GOTO_32.S */
     /*
      * Unconditional branch, 32-bit offset.
      *
@@ -1230,7 +1376,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_PACKED_SWITCH: /* 0x2b */
-/* File: armv5te/OP_PACKED_SWITCH.S */
+/* File: armv5te_taint/OP_PACKED_SWITCH.S */
     /*
      * Handle a packed-switch or sparse-switch instruction.  In both cases
      * we decode it and hand it off to a helper function.
@@ -1267,8 +1413,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPARSE_SWITCH: /* 0x2c */
-/* File: armv5te/OP_SPARSE_SWITCH.S */
-/* File: armv5te/OP_PACKED_SWITCH.S */
+/* File: armv5te_taint/OP_SPARSE_SWITCH.S */
+/* File: armv5te_taint/OP_PACKED_SWITCH.S */
     /*
      * Handle a packed-switch or sparse-switch instruction.  In both cases
      * we decode it and hand it off to a helper function.
@@ -1306,7 +1452,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPL_FLOAT: /* 0x2d */
-/* File: arm-vfp/OP_CMPL_FLOAT.S */
+/* File: arm-vfp_taint/OP_CMPL_FLOAT.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1345,7 +1491,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPG_FLOAT: /* 0x2e */
-/* File: arm-vfp/OP_CMPG_FLOAT.S */
+/* File: arm-vfp_taint/OP_CMPG_FLOAT.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1384,7 +1530,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPL_DOUBLE: /* 0x2f */
-/* File: arm-vfp/OP_CMPL_DOUBLE.S */
+/* File: arm-vfp_taint/OP_CMPL_DOUBLE.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1408,22 +1554,25 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-    fldd    d1, [r3]                    @ d1<- vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
     fcmped  d0, d1                      @ compare (vBB, vCC)
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     mvn     r0, #0                      @ r0<- -1 (default)
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fmstat                              @ export status flags
-    movgt   r0, #1                      @ (greater than) r1<- 1
-    moveq   r0, #0                      @ (equal) r1<- 0
     b       .LOP_CMPL_DOUBLE_finish          @ argh
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CMPG_DOUBLE: /* 0x30 */
-/* File: arm-vfp/OP_CMPG_DOUBLE.S */
+/* File: arm-vfp_taint/OP_CMPG_DOUBLE.S */
     /*
      * Compare two floating-point values.  Puts 0, 1, or -1 into the
      * destination register based on the results of the comparison.
@@ -1447,22 +1596,25 @@ dalvik_inst:
     mov     r3, r0, lsr #8              @ r3<- CC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-    fldd    d1, [r3]                    @ d1<- vCC
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+//    fldd    d1, [r3]                    @ d1<- vCC
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+// end WITH_TAINT_TRACKING
     fcmped  d0, d1                      @ compare (vBB, vCC)
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     mov     r0, #1                      @ r0<- 1 (default)
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fmstat                              @ export status flags
-    mvnmi   r0, #0                      @ (less than) r1<- -1
-    moveq   r0, #0                      @ (equal) r1<- 0
     b       .LOP_CMPG_DOUBLE_finish          @ argh
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_CMP_LONG: /* 0x31 */
-/* File: armv5te/OP_CMP_LONG.S */
+/* File: armv5te_taint/OP_CMP_LONG.S */
     /*
      * Compare two 64-bit values.  Puts 0, 1, or -1 into the destination
      * register based on the results of the comparison.
@@ -1488,10 +1640,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+	bl		cmp_long_taint_prop
+ // end WITH_TAINT_TRACKING
     cmp     r1, r3                      @ compare (vBB+1, vCC+1)
     blt     .LOP_CMP_LONG_less            @ signed compare on high part
     bgt     .LOP_CMP_LONG_greater
@@ -1503,8 +1654,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_EQ: /* 0x32 */
-/* File: armv6t2/OP_IF_EQ.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_EQ.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1538,8 +1689,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_NE: /* 0x33 */
-/* File: armv6t2/OP_IF_NE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_NE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1573,8 +1724,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LT: /* 0x34 */
-/* File: armv6t2/OP_IF_LT.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_LT.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1608,8 +1759,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GE: /* 0x35 */
-/* File: armv6t2/OP_IF_GE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_GE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1643,8 +1794,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GT: /* 0x36 */
-/* File: armv6t2/OP_IF_GT.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_GT.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1678,8 +1829,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LE: /* 0x37 */
-/* File: armv6t2/OP_IF_LE.S */
-/* File: armv6t2/bincmp.S */
+/* File: armv6t2_taint/OP_IF_LE.S */
+/* File: armv6t2_taint/bincmp.S */
     /*
      * Generic two-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1713,8 +1864,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_EQZ: /* 0x38 */
-/* File: armv5te/OP_IF_EQZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_EQZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1749,8 +1900,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_NEZ: /* 0x39 */
-/* File: armv5te/OP_IF_NEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_NEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1785,8 +1936,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LTZ: /* 0x3a */
-/* File: armv5te/OP_IF_LTZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_LTZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1821,8 +1972,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GEZ: /* 0x3b */
-/* File: armv5te/OP_IF_GEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_GEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1857,8 +2008,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_GTZ: /* 0x3c */
-/* File: armv5te/OP_IF_GTZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_GTZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1893,8 +2044,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IF_LEZ: /* 0x3d */
-/* File: armv5te/OP_IF_LEZ.S */
-/* File: armv5te/zcmp.S */
+/* File: armv5te_taint/OP_IF_LEZ.S */
+/* File: armv5te_taint/zcmp.S */
     /*
      * Generic one-operand compare-and-branch operation.  Provide a "revcmp"
      * fragment that specifies the *reverse* comparison to perform, e.g.
@@ -1929,55 +2080,55 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_3E: /* 0x3e */
-/* File: armv5te/OP_UNUSED_3E.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_3E.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_3F: /* 0x3f */
-/* File: armv5te/OP_UNUSED_3F.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_3F.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_40: /* 0x40 */
-/* File: armv5te/OP_UNUSED_40.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_40.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_41: /* 0x41 */
-/* File: armv5te/OP_UNUSED_41.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_41.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_42: /* 0x42 */
-/* File: armv5te/OP_UNUSED_42.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_42.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_43: /* 0x43 */
-/* File: armv5te/OP_UNUSED_43.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_43.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET: /* 0x44 */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -1994,20 +2145,27 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_WIDE: /* 0x45 */
-/* File: armv5te/OP_AGET_WIDE.S */
+/* File: armv5te_taint/OP_AGET_WIDE.S */
     /*
      * Array get, 64 bits.  vAA <- vBB[vCC].
      *
@@ -2022,6 +2180,9 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_WIDE_taint_prop		@ r10<- taint
+// end WITH_TAINT_TRACKING
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
@@ -2034,8 +2195,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_OBJECT: /* 0x46 */
-/* File: armv5te/OP_AGET_OBJECT.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_OBJECT.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2052,22 +2213,29 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_OBJECT_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_OBJECT_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldr   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_BOOLEAN: /* 0x47 */
-/* File: armv5te/OP_AGET_BOOLEAN.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2084,22 +2252,29 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_BOOLEAN_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_BOOLEAN_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_BYTE: /* 0x48 */
-/* File: armv5te/OP_AGET_BYTE.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_BYTE.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2116,22 +2291,29 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_BYTE_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrsb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_BYTE_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrsb   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_CHAR: /* 0x49 */
-/* File: armv5te/OP_AGET_CHAR.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_CHAR.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2148,22 +2330,29 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_CHAR_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_CHAR_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AGET_SHORT: /* 0x4a */
-/* File: armv5te/OP_AGET_SHORT.S */
-/* File: armv5te/OP_AGET.S */
+/* File: armv5te_taint/OP_AGET_SHORT.S */
+/* File: armv5te_taint/OP_AGET.S */
     /*
      * Array get, 32 bits or less.  vAA <- vBB[vCC].
      *
@@ -2180,21 +2369,28 @@ dalvik_inst:
     GET_VREG(r1, r3)                    @ r1<- vCC (requested index)
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AGET_SHORT_taint_prop_1
+// end WITH_TAINT_TRACKING
+	ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrsh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
+// begin WITH_TAINT_TRACKING
+//    bcs     common_errArrayIndex        @ index >= length, bail	// PJG: in subroutine
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl		.LOP_AGET_SHORT_taint_prop_2
+// end WITH_TAINT_TRACKING
+	ldrsh   r2, [r0, #offArrayObject_contents]  @ r2<- vBB[vCC]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r2, r9)                    @ vAA<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT: /* 0x4b */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2215,16 +2411,20 @@ dalvik_inst:
     add     r0, r0, r1, lsl #2     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_WIDE: /* 0x4c */
-/* File: armv5te/OP_APUT_WIDE.S */
+/* File: armv5te_taint/OP_APUT_WIDE.S */
     /*
      * Array put, 64 bits.  vBB[vCC] <- vAA.
      *
@@ -2240,9 +2440,14 @@ dalvik_inst:
     cmp     r0, #0                      @ null array object?
     beq     common_errNullObject        @ yes, bail
     ldr     r3, [r0, #offArrayObject_length]    @ r3<- arrayObj->length
+// begin WITH_TAINT_TRACKING
+	mov		r10, r0
+// end WITH_TAINT_TRACKING
     add     r0, r0, r1, lsl #3          @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     bcc     .LOP_APUT_WIDE_finish          @ okay, continue below
     b       common_errArrayIndex        @ index >= length, bail
     @ May want to swap the order of these two branches depending on how the
@@ -2252,7 +2457,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_OBJECT: /* 0x4d */
-/* File: armv5te/OP_APUT_OBJECT.S */
+/* File: armv5te_taint/OP_APUT_OBJECT.S */
     /*
      * Store an object into an array.  vBB[vCC] <- vAA.
      *
@@ -2264,13 +2469,19 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    GET_VREG(rINST, r2)                 @ rINST<- vBB (array object)
+    GET_VREG(r1, r2)                    @ r1<- vBB (array object)
     GET_VREG(r0, r3)                    @ r0<- vCC (requested index)
-    cmp     rINST, #0                   @ null array object?
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_1
+// end WITH_TAINT_TRACKING
+    cmp     r1, #0                      @ null array object?
     GET_VREG(r9, r9)                    @ r9<- vAA
     beq     common_errNullObject        @ yes, bail
-    ldr     r3, [rINST, #offArrayObject_length]   @ r3<- arrayObj->length
-    add     r10, rINST, r0, lsl #2      @ r10<- arrayObj + index*width
+// begin WITH_TAINT_TRACKING
+	bl	aput_object_taint_prop_2
+// end WITH_TAINT_TRACKING
+    ldr     r3, [r1, #offArrayObject_length]    @ r3<- arrayObj->length
+    add     r10, r1, r0, lsl #2         @ r10<- arrayObj + index*width
     cmp     r0, r3                      @ compare unsigned index, length
     bcc     .LOP_APUT_OBJECT_finish          @ we're okay, continue on
     b       common_errArrayIndex        @ index >= length, bail
@@ -2279,8 +2490,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_BOOLEAN: /* 0x4e */
-/* File: armv5te/OP_APUT_BOOLEAN.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2301,18 +2512,22 @@ dalvik_inst:
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_BOOLEAN_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strb  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_BYTE: /* 0x4f */
-/* File: armv5te/OP_APUT_BYTE.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_BYTE.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2333,18 +2548,22 @@ dalvik_inst:
     add     r0, r0, r1, lsl #0     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_BYTE_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strb  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_CHAR: /* 0x50 */
-/* File: armv5te/OP_APUT_CHAR.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_CHAR.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2365,18 +2584,22 @@ dalvik_inst:
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_CHAR_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strh  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_APUT_SHORT: /* 0x51 */
-/* File: armv5te/OP_APUT_SHORT.S */
-/* File: armv5te/OP_APUT.S */
+/* File: armv5te_taint/OP_APUT_SHORT.S */
+/* File: armv5te_taint/OP_APUT.S */
     /*
      * Array put, 32 bits or less.  vBB[vCC] <- vAA.
      *
@@ -2397,17 +2620,21 @@ dalvik_inst:
     add     r0, r0, r1, lsl #1     @ r0<- arrayObj + index*width
     cmp     r1, r3                      @ compare unsigned index, length
     bcs     common_errArrayIndex        @ index >= length, bail
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+	bl	.LOP_APUT_SHORT_taint_prop
+// end WITH_TAINT_TRACKING
     GET_VREG(r2, r9)                    @ r2<- vAA
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strh  r2, [r0, #offArrayObject_contents]  @ vBB[vCC]<- r2
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET: /* 0x52 */
-/* File: armv6t2/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2418,8 +2645,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2433,7 +2661,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE: /* 0x53 */
-/* File: armv6t2/OP_IGET_WIDE.S */
+/* File: armv5te_taint/OP_IGET_WIDE.S */
     /*
      * Wide 32-bit instance field get.
      */
@@ -2442,8 +2670,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_WIDE_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method] @ r2<- current method
@@ -2457,8 +2686,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT: /* 0x54 */
-/* File: armv5te/OP_IGET_OBJECT.S */
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET_OBJECT.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2469,8 +2698,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_OBJECT_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_OBJECT_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2485,9 +2715,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_BOOLEAN: /* 0x55 */
-/* File: armv5te/OP_IGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_IGET_BOOLEAN.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrb", "sqnum":"1" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2498,8 +2728,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_BOOLEAN_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_BOOLEAN_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2514,9 +2745,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_BYTE: /* 0x56 */
-/* File: armv5te/OP_IGET_BYTE.S */
+/* File: armv5te_taint/OP_IGET_BYTE.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrsb", "sqnum":"2" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2527,8 +2758,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_BYTE_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_BYTE_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2543,9 +2775,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_CHAR: /* 0x57 */
-/* File: armv5te/OP_IGET_CHAR.S */
+/* File: armv5te_taint/OP_IGET_CHAR.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrh", "sqnum":"3" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2556,8 +2788,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_CHAR_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_CHAR_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2572,9 +2805,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_SHORT: /* 0x58 */
-/* File: armv5te/OP_IGET_SHORT.S */
+/* File: armv5te_taint/OP_IGET_SHORT.S */
 @include "armv5te/OP_IGET.S" { "load":"ldrsh", "sqnum":"4" }
-/* File: armv5te/OP_IGET.S */
+/* File: armv5te_taint/OP_IGET.S */
     /*
      * General 32-bit instance field get.
      *
@@ -2585,8 +2818,9 @@ dalvik_inst:
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref CCCC
     ldr     r2, [r3, #offDvmDex_pResFields] @ r2<- pDvmDex->pResFields
-    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_IGET_SHORT_taint_prop
+// end WITH_TAINT_TRACKING
     cmp     r0, #0                      @ is resolved entry null?
     bne     .LOP_IGET_SHORT_finish          @ no, already resolved
 8:  ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -2601,7 +2835,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT: /* 0x59 */
-/* File: armv6t2/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
@@ -2627,7 +2861,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_WIDE: /* 0x5a */
-/* File: armv6t2/OP_IPUT_WIDE.S */
+/* File: armv5te_taint/OP_IPUT_WIDE.S */
     /* iput-wide vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
     ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- DvmDex
@@ -2648,11 +2882,12 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT: /* 0x5b */
-/* File: armv5te/OP_IPUT_OBJECT.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
-     * 32-bit instance field put.
+     * General 32-bit instance field put.
      *
-     * for: iput-object, iput-object-volatile
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
      */
     /* op vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -2671,16 +2906,17 @@ dalvik_inst:
     bne     .LOP_IPUT_OBJECT_finish          @ yes, finish up
     b       common_exceptionThrown
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_BOOLEAN: /* 0x5c */
-/* File: armv5te/OP_IPUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_IPUT_BOOLEAN.S */
 @include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"1" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
-     * for: iput, iput-boolean, iput-byte, iput-char, iput-short
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
      */
     /* op vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -2703,13 +2939,13 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_BYTE: /* 0x5d */
-/* File: armv5te/OP_IPUT_BYTE.S */
+/* File: armv5te_taint/OP_IPUT_BYTE.S */
 @include "armv5te/OP_IPUT.S" { "store":"strb", "sqnum":"2" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
-     * for: iput, iput-boolean, iput-byte, iput-char, iput-short
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
      */
     /* op vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -2732,13 +2968,13 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_CHAR: /* 0x5e */
-/* File: armv5te/OP_IPUT_CHAR.S */
+/* File: armv5te_taint/OP_IPUT_CHAR.S */
 @include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"3" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
-     * for: iput, iput-boolean, iput-byte, iput-char, iput-short
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
      */
     /* op vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -2761,13 +2997,13 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_SHORT: /* 0x5f */
-/* File: armv5te/OP_IPUT_SHORT.S */
+/* File: armv5te_taint/OP_IPUT_SHORT.S */
 @include "armv5te/OP_IPUT.S" { "store":"strh", "sqnum":"4" }
-/* File: armv5te/OP_IPUT.S */
+/* File: armv5te_taint/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
      *
-     * for: iput, iput-boolean, iput-byte, iput-char, iput-short
+     * for: iput, iput-object, iput-boolean, iput-byte, iput-char, iput-short
      */
     /* op vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -2790,7 +3026,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET: /* 0x60 */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2805,8 +3041,12 @@ dalvik_inst:
     beq     .LOP_SGET_resolve         @ yes, do resolve
 .LOP_SGET_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2815,7 +3055,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_WIDE: /* 0x61 */
-/* File: armv5te/OP_SGET_WIDE.S */
+/* File: armv5te_taint/OP_SGET_WIDE.S */
     /*
      * 64-bit SGET handler.
      */
@@ -2826,25 +3066,14 @@ dalvik_inst:
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
     cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SGET_WIDE_resolve         @ yes, do resolve
-.LOP_SGET_WIDE_finish:
-    mov     r9, rINST, lsr #8           @ r9<- AA
-    .if 0
-    add     r0, r0, #offStaticField_value @ r0<- pointer to data
-    bl      dvmQuasiAtomicRead64        @ r0/r1<- contents of field
-    .else
-    ldrd    r0, [r0, #offStaticField_value] @ r0/r1<- field value (aligned)
-    .endif
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+    b		.LOP_SGET_WIDE_finish
+
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_OBJECT: /* 0x62 */
-/* File: armv5te/OP_SGET_OBJECT.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_OBJECT.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2859,8 +3088,12 @@ dalvik_inst:
     beq     .LOP_SGET_OBJECT_resolve         @ yes, do resolve
 .LOP_SGET_OBJECT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2870,8 +3103,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_BOOLEAN: /* 0x63 */
-/* File: armv5te/OP_SGET_BOOLEAN.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_BOOLEAN.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2886,8 +3119,12 @@ dalvik_inst:
     beq     .LOP_SGET_BOOLEAN_resolve         @ yes, do resolve
 .LOP_SGET_BOOLEAN_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2897,8 +3134,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_BYTE: /* 0x64 */
-/* File: armv5te/OP_SGET_BYTE.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_BYTE.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2913,8 +3150,12 @@ dalvik_inst:
     beq     .LOP_SGET_BYTE_resolve         @ yes, do resolve
 .LOP_SGET_BYTE_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2924,8 +3165,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_CHAR: /* 0x65 */
-/* File: armv5te/OP_SGET_CHAR.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_CHAR.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2940,8 +3181,12 @@ dalvik_inst:
     beq     .LOP_SGET_CHAR_resolve         @ yes, do resolve
 .LOP_SGET_CHAR_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2951,8 +3196,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_SHORT: /* 0x66 */
-/* File: armv5te/OP_SGET_SHORT.S */
-/* File: armv5te/OP_SGET.S */
+/* File: armv5te_taint/OP_SGET_SHORT.S */
+/* File: armv5te_taint/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
      *
@@ -2967,8 +3212,12 @@ dalvik_inst:
     beq     .LOP_SGET_SHORT_resolve         @ yes, do resolve
 .LOP_SGET_SHORT_finish: @ field ptr in r0
     ldr     r1, [r0, #offStaticField_value] @ r1<- field value
-    @ no-op                             @ acquiring load
     mov     r2, rINST, lsr #8           @ r2<- AA
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r0, r2, r3)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r2)                    @ fp[AA]<- r1
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -2978,11 +3227,11 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT: /* 0x67 */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
-     * for: sput, sput-boolean, sput-byte, sput-char, sput-short
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -2996,46 +3245,56 @@ dalvik_inst:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_WIDE: /* 0x68 */
-/* File: armv5te/OP_SPUT_WIDE.S */
+/* File: armv5te_taint/OP_SPUT_WIDE.S */
     /*
      * 64-bit SPUT handler.
      */
     /* sput-wide vAA, field@BBBB */
-    ldr     r0, [rGLUE, #offGlue_methodClassDex]  @ r0<- DvmDex
+    ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
     FETCH(r1, 1)                        @ r1<- field ref BBBB
-    ldr     r0, [r0, #offDvmDex_pResFields] @ r0<- dvmDex->pResFields
+    ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
     mov     r9, rINST, lsr #8           @ r9<- AA
-    ldr     r2, [r0, r1, lsl #2]        @ r2<- resolved StaticField ptr
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    cmp     r2, #0                      @ is resolved entry null?
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
+// begin WITH_TAINT_TRACKING
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
+    cmp     r0, #0                      @ is resolved entry null?
     beq     .LOP_SPUT_WIDE_resolve         @ yes, do resolve
-.LOP_SPUT_WIDE_finish: @ field ptr in r2, AA in r9
+.LOP_SPUT_WIDE_finish: @ field ptr in r0, AA in r9
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
-    GET_INST_OPCODE(r10)                @ extract opcode from rINST
-    .if 0
-    add     r2, r2, #offStaticField_value @ r2<- pointer to data
-    bl      dvmQuasiAtomicSwap64        @ stores r0/r1 into addr r2
-    .else
-    strd    r0, [r2, #offStaticField_value] @ field<- vAA/vAA+1
-    .endif
-    GOTO_OPCODE(r10)                    @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr r1, [r9, #4]
+	ldr r2, [r9, #0]
+	ldr r3, [r9, #8]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    strd    r2, [r0, #offStaticField_value] @ field<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+    str		r1, [r0, #offStaticField_taint]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_OBJECT: /* 0x69 */
-/* File: armv5te/OP_SPUT_OBJECT.S */
+/* File: armv5te_taint/OP_SPUT_OBJECT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
-     * 32-bit SPUT handler for objects
+     * General 32-bit SPUT handler.
      *
-     * for: sput-object, sput-object-volatile
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -3043,25 +3302,30 @@ dalvik_inst:
     ldr     r2, [r2, #offDvmDex_pResFields] @ r2<- dvmDex->pResFields
     ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved StaticField ptr
     cmp     r0, #0                      @ is resolved entry null?
-    bne     .LOP_SPUT_OBJECT_finish          @ no, continue
-    ldr     r9, [rGLUE, #offGlue_method]    @ r9<- current method
-    EXPORT_PC()                         @ resolve() could throw, so export now
-    ldr     r0, [r9, #offMethod_clazz]  @ r0<- method->clazz
-    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
-    cmp     r0, #0                      @ success?
-    bne     .LOP_SPUT_OBJECT_finish          @ yes, finish
-    b       common_exceptionThrown      @ no, handle exception
+    beq     .LOP_SPUT_OBJECT_resolve         @ yes, do resolve
+.LOP_SPUT_OBJECT_finish:   @ field ptr in r0
+    mov     r2, rINST, lsr #8           @ r2<- AA
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    GET_VREG(r1, r2)                    @ r1<- fp[AA]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BOOLEAN: /* 0x6a */
-/* File: armv5te/OP_SPUT_BOOLEAN.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BOOLEAN.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
-     * for: sput, sput-boolean, sput-byte, sput-char, sput-short
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -3075,20 +3339,24 @@ dalvik_inst:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_BYTE: /* 0x6b */
-/* File: armv5te/OP_SPUT_BYTE.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_BYTE.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
-     * for: sput, sput-boolean, sput-byte, sput-char, sput-short
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -3102,20 +3370,24 @@ dalvik_inst:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_CHAR: /* 0x6c */
-/* File: armv5te/OP_SPUT_CHAR.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_CHAR.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
-     * for: sput, sput-boolean, sput-byte, sput-char, sput-short
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -3129,20 +3401,24 @@ dalvik_inst:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_SHORT: /* 0x6d */
-/* File: armv5te/OP_SPUT_SHORT.S */
-/* File: armv5te/OP_SPUT.S */
+/* File: armv5te_taint/OP_SPUT_SHORT.S */
+/* File: armv5te_taint/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
      *
-     * for: sput, sput-boolean, sput-byte, sput-char, sput-short
+     * for: sput, sput-object, sput-boolean, sput-byte, sput-char, sput-short
      */
     /* op vAA, field@BBBB */
     ldr     r2, [rGLUE, #offGlue_methodClassDex]    @ r2<- DvmDex
@@ -3156,342 +3432,154 @@ dalvik_inst:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_VREG(r1, r2)                    @ r1<- fp[AA]
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str     r1, [r0, #offStaticField_value] @ field<- vAA
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r2, r3)
+	str		r1, [r0, #offStaticField_taint]
+// END WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL: /* 0x6e */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER: /* 0x6f */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_resolve         @ do resolve now
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT: /* 0x70 */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodNoRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC: /* 0x71 */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodNoRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodNoRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE: /* 0x72 */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodNoRange @ jump to common handler
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_73: /* 0x73 */
-/* File: armv5te/OP_UNUSED_73.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_73.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_RANGE: /* 0x74 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL.S */
-    /*
-     * Handle a virtual method call.
-     *
-     * for: invoke-virtual, invoke-virtual/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ yes, continue on
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_VIRTUAL_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_RANGE: /* 0x75 */
-/* File: armv5te/OP_INVOKE_SUPER_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER.S */
-    /*
-     * Handle a "super" method call.
-     *
-     * for: invoke-super, invoke-super/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved baseMethod
-    cmp     r2, #0                      @ null "this"?
-    ldr     r9, [rGLUE, #offGlue_method] @ r9<- current method
-    beq     common_errNullObject        @ null "this", throw exception
-    cmp     r0, #0                      @ already resolved?
-    ldr     r9, [r9, #offMethod_clazz]  @ r9<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ resolved, continue on
-    b       .LOP_INVOKE_SUPER_RANGE_resolve         @ do resolve now
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT_RANGE: /* 0x76 */
-/* File: armv5te/OP_INVOKE_DIRECT_RANGE.S */
-/* File: armv5te/OP_INVOKE_DIRECT.S */
-    /*
-     * Handle a direct method call.
-     *
-     * (We could defer the "is 'this' pointer null" test to the common
-     * method invocation code, and use a flag to indicate that static
-     * calls don't count.  If we do this as part of copying the arguments
-     * out we could avoiding loading the first arg twice.)
-     *
-     * for: invoke-direct, invoke-direct/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr
-    beq     .LOP_INVOKE_DIRECT_RANGE_resolve         @ not resolved, do it now
-.LOP_INVOKE_DIRECT_RANGE_finish:
-    cmp     r2, #0                      @ null "this" ref?
-    bne     common_invokeMethodRange   @ no, continue on
-    b       common_errNullObject        @ yes, throw exception
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_DIRECT_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_STATIC_RANGE: /* 0x77 */
-/* File: armv5te/OP_INVOKE_STATIC_RANGE.S */
-/* File: armv5te/OP_INVOKE_STATIC.S */
-    /*
-     * Handle a static method call.
-     *
-     * for: invoke-static, invoke-static/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- pDvmDex
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r3, [r3, #offDvmDex_pResMethods]    @ r3<- pDvmDex->pResMethods
-    ldr     r0, [r3, r1, lsl #2]        @ r0<- resolved methodToCall
-    cmp     r0, #0                      @ already resolved?
-    EXPORT_PC()                         @ must export for invoke
-    bne     common_invokeMethodRange @ yes, continue on
-0:  ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_STATIC          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     common_invokeMethodRange @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_STATIC_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_INTERFACE_RANGE: /* 0x78 */
-/* File: armv5te/OP_INVOKE_INTERFACE_RANGE.S */
-/* File: armv5te/OP_INVOKE_INTERFACE.S */
-    /*
-     * Handle an interface method call.
-     *
-     * for: invoke-interface, invoke-interface/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r2, 2)                        @ r2<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r2, r2, #15                 @ r2<- C (or stays CCCC)
-    .endif
-    EXPORT_PC()                         @ must export for invoke
-    GET_VREG(r0, r2)                    @ r0<- first arg ("this")
-    ldr     r3, [rGLUE, #offGlue_methodClassDex]    @ r3<- methodClassDex
-    cmp     r0, #0                      @ null obj?
-    ldr     r2, [rGLUE, #offGlue_method]  @ r2<- method
-    beq     common_errNullObject        @ yes, fail
-    ldr     r0, [r0, #offObject_clazz]  @ r0<- thisPtr->clazz
-    bl      dvmFindInterfaceMethodInCache @ r0<- call(class, ref, method, dex)
-    cmp     r0, #0                      @ failed?
-    beq     common_exceptionThrown      @ yes, handle exception
-    b       common_invokeMethodRange @ jump to common handler
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_INTERFACE_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_79: /* 0x79 */
-/* File: armv5te/OP_UNUSED_79.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_79.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_7A: /* 0x7a */
-/* File: armv5te/OP_UNUSED_7A.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_7A.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_INT: /* 0x7b */
-/* File: armv6t2/OP_NEG_INT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NEG_INT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3504,6 +3592,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     rsb     r0, r0, #0                              @ r0<- op, r0-r3 changed
@@ -3516,8 +3609,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NOT_INT: /* 0x7c */
-/* File: armv6t2/OP_NOT_INT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NOT_INT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3530,6 +3623,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mvn     r0, r0                              @ r0<- op, r0-r3 changed
@@ -3542,8 +3640,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_LONG: /* 0x7d */
-/* File: armv6t2/OP_NEG_LONG.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NEG_LONG.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3552,25 +3650,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     rsbs    r0, r0, #0                           @ optional op; may set condition codes
     rsc     r1, r1, #0                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
+	b     .LOP_NEG_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NOT_LONG: /* 0x7e */
-/* File: armv6t2/OP_NOT_LONG.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NOT_LONG.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3579,25 +3681,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mvn     r0, r0                           @ optional op; may set condition codes
     mvn     r1, r1                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
+	b     .LOP_NOT_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_FLOAT: /* 0x7f */
-/* File: armv6t2/OP_NEG_FLOAT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_NEG_FLOAT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3610,6 +3716,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     add     r0, r0, #0x80000000                              @ r0<- op, r0-r3 changed
@@ -3622,8 +3733,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_NEG_DOUBLE: /* 0x80 */
-/* File: armv6t2/OP_NEG_DOUBLE.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_NEG_DOUBLE.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3632,25 +3743,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     add     r1, r1, #0x80000000                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
+	b     .LOP_NEG_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_LONG: /* 0x81 */
-/* File: armv6t2/OP_INT_TO_LONG.S */
-/* File: armv6t2/unopWider.S */
+/* File: armv5te_taint/OP_INT_TO_LONG.S */
+/* File: armv5te_taint/unopWider.S */
     /*
      * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0", where
@@ -3659,24 +3774,27 @@ dalvik_inst:
      * For: int-to-long, int-to-double, float-to-long, float-to-double
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r0, r3)                    @ r0<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r3, r2)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+// end WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     mov     r1, r0, asr #31                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+	b     .LOP_INT_TO_LONG_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_FLOAT: /* 0x82 */
-/* File: arm-vfp/OP_INT_TO_FLOAT.S */
-/* File: arm-vfp/funop.S */
+/* File: arm-vfp_taint/OP_INT_TO_FLOAT.S */
+/* File: arm-vfp_taint/funop.S */
     /*
      * Generic 32-bit unary floating-point operation.  Provide an "instr"
      * line that specifies an instruction that performs "s1 = op s0".
@@ -3688,20 +3806,26 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fsitos  s1, s0                              @ s1<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s1, [r9]                    @ vA<- s1
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_DOUBLE: /* 0x83 */
-/* File: arm-vfp/OP_INT_TO_DOUBLE.S */
-/* File: arm-vfp/funopWider.S */
+/* File: arm-vfp_taint/OP_INT_TO_DOUBLE.S */
+/* File: arm-vfp_taint/funopWider.S */
     /*
      * Generic 32bit-to-64bit floating point unary operation.  Provide an
      * "instr" line that specifies an instruction that performs "d0 = op s0".
@@ -3713,21 +3837,30 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fsitod  d0, s0                              @ d0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
-    fstd    d0, [r9]                    @ vA<- d0
+// begin WITH_TAINT_TRACKING
+//    fstd    d0, [r9]                    @ vA<- d0
+	fsts	s0, [r9]
+	fsts	s1, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_INT: /* 0x84 */
-/* File: armv5te/OP_LONG_TO_INT.S */
+/* File: armv5te_taint/OP_LONG_TO_INT.S */
 /* we ignore the high word, making this equivalent to a 32-bit reg move */
-/* File: armv5te/OP_MOVE.S */
+/* File: armv5te_taint/OP_MOVE.S */
     /* for move, move-object, long-to-int */
     /* op vA, vB */
     mov     r1, rINST, lsr #12          @ r1<- B from 15:12
@@ -3735,6 +3868,11 @@ dalvik_inst:
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     GET_VREG(r2, r1)                    @ r2<- fp[B]
     and     r0, r0, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r1, r1, r3)
+	SET_VREG_TAINT(r1, r0, r3)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
     SET_VREG(r2, r0)                    @ fp[A]<- r2
     GOTO_OPCODE(ip)                     @ execute next instruction
@@ -3743,8 +3881,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_FLOAT: /* 0x85 */
-/* File: armv6t2/OP_LONG_TO_FLOAT.S */
-/* File: armv6t2/unopNarrower.S */
+/* File: armv5te_taint/OP_LONG_TO_FLOAT.S */
+/* File: armv5te_taint/unopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0/r1", where
@@ -3757,23 +3895,33 @@ dalvik_inst:
      */
     /* unop vA, vB */
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1
+    mov     r9, rINST, lsr #8           @ r9<- A+
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    and     r9, r9, #15
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vB/vB+1
+	ldr		r0, [r3, #0]
+	ldr		r10, [r3, #4]
+	ldr		r1, [r3, #8]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_l2f                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r10, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+    /* 10-11 instructions */
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_LONG_TO_DOUBLE: /* 0x86 */
-/* File: armv6t2/OP_LONG_TO_DOUBLE.S */
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_LONG_TO_DOUBLE.S */
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3782,25 +3930,29 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_l2d                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
+	b     .LOP_LONG_TO_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_INT: /* 0x87 */
-/* File: arm-vfp/OP_FLOAT_TO_INT.S */
-/* File: arm-vfp/funop.S */
+/* File: arm-vfp_taint/OP_FLOAT_TO_INT.S */
+/* File: arm-vfp_taint/funop.S */
     /*
      * Generic 32-bit unary floating-point operation.  Provide an "instr"
      * line that specifies an instruction that performs "s1 = op s0".
@@ -3812,21 +3964,27 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     ftosizs s1, s0                              @ s1<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s1, [r9]                    @ vA<- s1
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_LONG: /* 0x88 */
-/* File: armv6t2/OP_FLOAT_TO_LONG.S */
-@include "armv6t2/unopWider.S" {"instr":"bl      __aeabi_f2lz"}
-/* File: armv6t2/unopWider.S */
+/* File: armv5te_taint/OP_FLOAT_TO_LONG.S */
+@include "armv5te/unopWider.S" {"instr":"bl      __aeabi_f2lz"}
+/* File: armv5te_taint/unopWider.S */
     /*
      * Generic 32bit-to-64bit unary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = op r0", where
@@ -3835,25 +3993,28 @@ dalvik_inst:
      * For: int-to-long, int-to-double, float-to-long, float-to-double
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r0, r3)                    @ r0<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r3, r2)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+// end WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     bl      f2l_doconv                              @ r0<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 9-10 instructions */
+	b     .LOP_FLOAT_TO_LONG_finish
 
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_FLOAT_TO_DOUBLE: /* 0x89 */
-/* File: arm-vfp/OP_FLOAT_TO_DOUBLE.S */
-/* File: arm-vfp/funopWider.S */
+/* File: arm-vfp_taint/OP_FLOAT_TO_DOUBLE.S */
+/* File: arm-vfp_taint/funopWider.S */
     /*
      * Generic 32bit-to-64bit floating point unary operation.  Provide an
      * "instr" line that specifies an instruction that performs "d0 = op s0".
@@ -3865,20 +4026,29 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     flds    s0, [r3]                    @ s0<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fcvtds  d0, s0                              @ d0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
-    fstd    d0, [r9]                    @ vA<- d0
+// begin WITH_TAINT_TRACKING
+//    fstd    d0, [r9]                    @ vA<- d0
+	fsts	s0, [r9]
+	fsts	s1, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_INT: /* 0x8a */
-/* File: arm-vfp/OP_DOUBLE_TO_INT.S */
-/* File: arm-vfp/funopNarrower.S */
+/* File: arm-vfp_taint/OP_DOUBLE_TO_INT.S */
+/* File: arm-vfp_taint/funopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary floating point operation.  Provide an
      * "instr" line that specifies an instruction that performs "s0 = op d0".
@@ -3889,22 +4059,30 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
-    fldd    d0, [r3]                    @ d0<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r3]                    @ d0<- vB
+	flds	s0, [r3]
+	flds	s1, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     ftosizd  s0, d0                              @ s0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s0, [r9]                    @ vA<- s0
+// begin WITH_TAINT_TRACKING
+    str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_LONG: /* 0x8b */
-/* File: armv6t2/OP_DOUBLE_TO_LONG.S */
-@include "armv6t2/unopWide.S" {"instr":"bl      __aeabi_d2lz"}
-/* File: armv6t2/unopWide.S */
+/* File: armv5te_taint/OP_DOUBLE_TO_LONG.S */
+@include "armv5te/unopWide.S" {"instr":"bl      __aeabi_d2lz"}
+/* File: armv5te_taint/unopWide.S */
     /*
      * Generic 64-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0/r1".
@@ -3913,26 +4091,30 @@ dalvik_inst:
      * For: neg-long, not-long, neg-double, long-to-double, double-to-long
      */
     /* unop vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vAA
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r10, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      d2l_doconv                              @ r0/r1<- op, r2-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-    /* 10-11 instructions */
+	b     .LOP_DOUBLE_TO_LONG_finish
 
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DOUBLE_TO_FLOAT: /* 0x8c */
-/* File: arm-vfp/OP_DOUBLE_TO_FLOAT.S */
-/* File: arm-vfp/funopNarrower.S */
+/* File: arm-vfp_taint/OP_DOUBLE_TO_FLOAT.S */
+/* File: arm-vfp_taint/funopNarrower.S */
     /*
      * Generic 64bit-to-32bit unary floating point operation.  Provide an
      * "instr" line that specifies an instruction that performs "s0 = op d0".
@@ -3943,21 +4125,29 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
-    fldd    d0, [r3]                    @ d0<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r3]                    @ d0<- vB
+	flds	s0, [r3]
+	flds	s1, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     and     r9, r9, #15                 @ r9<- A
     fcvtsd  s0, d0                              @ s0<- op
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     fsts    s0, [r9]                    @ vA<- s0
+// begin WITH_TAINT_TRACKING
+    str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_BYTE: /* 0x8d */
-/* File: armv6t2/OP_INT_TO_BYTE.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_BYTE.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3970,6 +4160,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     sxtb    r0, r0                              @ r0<- op, r0-r3 changed
@@ -3982,8 +4177,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_CHAR: /* 0x8e */
-/* File: armv6t2/OP_INT_TO_CHAR.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_CHAR.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -3996,6 +4191,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     uxth    r0, r0                              @ r0<- op, r0-r3 changed
@@ -4008,8 +4208,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INT_TO_SHORT: /* 0x8f */
-/* File: armv6t2/OP_INT_TO_SHORT.S */
-/* File: armv6t2/unop.S */
+/* File: armv6t2_taint/OP_INT_TO_SHORT.S */
+/* File: armv6t2_taint/unop.S */
     /*
      * Generic 32-bit unary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = op r0".
@@ -4022,6 +4222,11 @@ dalvik_inst:
     mov     r3, rINST, lsr #12          @ r3<- B
     ubfx    r9, rINST, #8, #4           @ r9<- A
     GET_VREG(r0, r3)                    @ r0<- vB
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r2, r3, r1)			@ r2<- vB.taint
+	SET_VREG_TAINT(r2, r9, r1)
+// END WITH_TAINT_TRACKING
                                @ optional op; may set condition codes
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     sxth    r0, r0                              @ r0<- op, r0-r3 changed
@@ -4034,8 +4239,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT: /* 0x90 */
-/* File: armv5te/OP_ADD_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_ADD_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4063,6 +4268,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_ADD_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     add     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4072,11 +4280,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_INT: /* 0x91 */
-/* File: armv5te/OP_SUB_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SUB_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4104,6 +4313,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SUB_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     sub     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4113,12 +4325,13 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT: /* 0x92 */
-/* File: armv5te/OP_MUL_INT.S */
+/* File: armv5te_taint/OP_MUL_INT.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4146,6 +4359,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_MUL_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     mul     r0, r1, r0                              @ r0<- op, r0-r3 changed
@@ -4155,11 +4371,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT: /* 0x93 */
-/* File: armv5te/OP_DIV_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_DIV_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4187,6 +4404,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_DIV_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl     __aeabi_idiv                              @ r0<- op, r0-r3 changed
@@ -4196,12 +4416,13 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT: /* 0x94 */
-/* File: armv5te/OP_REM_INT.S */
+/* File: armv5te_taint/OP_REM_INT.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4229,6 +4450,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_REM_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      __aeabi_idivmod                              @ r1<- op, r0-r3 changed
@@ -4238,11 +4462,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT: /* 0x95 */
-/* File: armv5te/OP_AND_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_AND_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4270,6 +4495,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_AND_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     and     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4279,11 +4507,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT: /* 0x96 */
-/* File: armv5te/OP_OR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_OR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4311,6 +4540,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_OR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     orr     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4320,11 +4552,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT: /* 0x97 */
-/* File: armv5te/OP_XOR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_XOR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4352,6 +4585,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_XOR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     eor     r0, r0, r1                              @ r0<- op, r0-r3 changed
@@ -4361,11 +4597,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT: /* 0x98 */
-/* File: armv5te/OP_SHL_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SHL_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4393,6 +4630,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SHL_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, asl r1                              @ r0<- op, r0-r3 changed
@@ -4402,11 +4642,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT: /* 0x99 */
-/* File: armv5te/OP_SHR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_SHR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4434,6 +4675,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_SHR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, asr r1                              @ r0<- op, r0-r3 changed
@@ -4443,11 +4687,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT: /* 0x9a */
-/* File: armv5te/OP_USHR_INT.S */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/OP_USHR_INT.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -4475,6 +4720,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_USHR_INT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r1, r1, #31                           @ optional op; may set condition codes
     mov     r0, r0, lsr r1                              @ r0<- op, r0-r3 changed
@@ -4484,11 +4732,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_LONG: /* 0x9b */
-/* File: armv5te/OP_ADD_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_ADD_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4509,11 +4758,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_ADD_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4523,16 +4770,23 @@ dalvik_inst:
     adds    r0, r0, r2                           @ optional op; may set condition codes
     adc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_LONG: /* 0x9c */
-/* File: armv5te/OP_SUB_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_SUB_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4553,11 +4807,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_SUB_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4567,15 +4819,22 @@ dalvik_inst:
     subs    r0, r0, r2                           @ optional op; may set condition codes
     sbc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_LONG: /* 0x9d */
-/* File: armv5te/OP_MUL_LONG.S */
+/* File: armv5te_taint/OP_MUL_LONG.S */
     /*
      * Signed 64-bit integer multiply.
      *
@@ -4598,24 +4857,25 @@ dalvik_inst:
     FETCH(r0, 1)                        @ r0<- CCBB
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		mul_long_taint_prop
+// end WITH_TAINT_TRACKING
     mul     ip, r2, r1                  @  ip<- ZxW
     umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
     mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
     mov     r0, rINST, lsr #8           @ r0<- AA
     add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
-    add     r0, rFP, r0, lsl #2         @ r0<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    add     r0, rFP, r0, lsl #3         @ r0<- &fp[AA]
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     b       .LOP_MUL_LONG_finish
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_LONG: /* 0x9e */
-/* File: armv5te/OP_DIV_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_DIV_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4636,11 +4896,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_DIV_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4650,17 +4908,24 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_LONG: /* 0x9f */
-/* File: armv5te/OP_REM_LONG.S */
+/* File: armv5te_taint/OP_REM_LONG.S */
 /* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4681,11 +4946,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4695,16 +4958,23 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+    str		r2, [r9, #0]
+    str		r10, [r9, #4]
+    str		r3, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_LONG: /* 0xa0 */
-/* File: armv5te/OP_AND_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_AND_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4725,11 +4995,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_AND_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4739,16 +5007,23 @@ dalvik_inst:
     and     r0, r0, r2                           @ optional op; may set condition codes
     and     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_LONG: /* 0xa1 */
-/* File: armv5te/OP_OR_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_OR_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4769,11 +5044,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_OR_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4783,16 +5056,23 @@ dalvik_inst:
     orr     r0, r0, r2                           @ optional op; may set condition codes
     orr     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_LONG: /* 0xa2 */
-/* File: armv5te/OP_XOR_LONG.S */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/OP_XOR_LONG.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -4813,11 +5093,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_XOR_LONG_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -4827,15 +5105,22 @@ dalvik_inst:
     eor     r0, r0, r2                           @ optional op; may set condition codes
     eor     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_LONG: /* 0xa3 */
-/* File: armv5te/OP_SHL_LONG.S */
+/* File: armv5te_taint/OP_SHL_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4847,11 +5132,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r1, r1, asl r2              @  r1<- r1 << r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4864,7 +5147,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_LONG: /* 0xa4 */
-/* File: armv5te/OP_SHR_LONG.S */
+/* File: armv5te_taint/OP_SHR_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4876,11 +5159,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r0<- r0 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4893,7 +5174,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_LONG: /* 0xa5 */
-/* File: armv5te/OP_USHR_LONG.S */
+/* File: armv5te_taint/OP_USHR_LONG.S */
     /*
      * Long integer shift.  This is different from the generic 32/64-bit
      * binary operations because vAA/vBB are 64-bit but vCC (the shift
@@ -4905,11 +5186,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r3, r0, #255                @ r3<- BB
     mov     r0, r0, lsr #8              @ r0<- CC
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[BB]
-    GET_VREG(r2, r0)                    @ r2<- vCC
-    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    and     r2, r2, #63                 @ r0<- r0 & 0x3f
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -4922,8 +5201,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_FLOAT: /* 0xa6 */
-/* File: arm-vfp/OP_ADD_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_ADD_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -4940,20 +5219,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fadds   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_FLOAT: /* 0xa7 */
-/* File: arm-vfp/OP_SUB_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_SUB_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -4970,20 +5248,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fsubs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_FLOAT: /* 0xa8 */
-/* File: arm-vfp/OP_MUL_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_MUL_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -5000,20 +5277,19 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fmuls   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_FLOAT: /* 0xa9 */
-/* File: arm-vfp/OP_DIV_FLOAT.S */
-/* File: arm-vfp/fbinop.S */
+/* File: arm-vfp_taint/OP_DIV_FLOAT.S */
+/* File: arm-vfp_taint/fbinop.S */
     /*
      * Generic 32-bit floating-point operation.  Provide an "instr" line that
      * specifies an instruction that performs "s2 = s0 op s1".  Because we
@@ -5030,21 +5306,20 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
     flds    s1, [r3]                    @ s1<- vCC
     flds    s0, [r2]                    @ s0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fdivs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_FLOAT_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_FLOAT: /* 0xaa */
-/* File: armv5te/OP_REM_FLOAT.S */
+/* File: armv5te_taint/OP_REM_FLOAT.S */
 /* EABI doesn't define a float remainder function, but libm does */
-/* File: armv5te/binop.S */
+/* File: armv5te_taint/binop.S */
     /*
      * Generic 32-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0 op r1".
@@ -5072,6 +5347,9 @@ dalvik_inst:
     beq     common_errDivideByZero
     .endif
 
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_REM_FLOAT_taint_prop
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
                                @ optional op; may set condition codes
     bl      fmodf                              @ r0<- op, r0-r3 changed
@@ -5081,11 +5359,12 @@ dalvik_inst:
     /* 11-14 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_DOUBLE: /* 0xab */
-/* File: arm-vfp/OP_ADD_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_ADD_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5100,22 +5379,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    faddd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_DOUBLE: /* 0xac */
-/* File: arm-vfp/OP_SUB_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_SUB_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5130,22 +5412,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fsubd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_DOUBLE: /* 0xad */
-/* File: arm-vfp/OP_MUL_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_MUL_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5160,22 +5445,25 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fmuld   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_DOUBLE: /* 0xae */
-/* File: arm-vfp/OP_DIV_DOUBLE.S */
-/* File: arm-vfp/fbinopWide.S */
+/* File: arm-vfp_taint/OP_DIV_DOUBLE.S */
+/* File: arm-vfp_taint/fbinopWide.S */
     /*
      * Generic 64-bit double-precision floating point binary operation.
      * Provide an "instr" line that specifies an instruction that performs
@@ -5190,23 +5478,26 @@ dalvik_inst:
     and     r2, r0, #255                @ r2<- BB
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vCC
     VREG_INDEX_TO_ADDR(r2, r2)          @ r2<- &vBB
-    fldd    d1, [r3]                    @ d1<- vCC
-    fldd    d0, [r2]                    @ d0<- vBB
-
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    fdivd   d2, d0, d1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vCC
+//    fldd    d0, [r2]                    @ d0<- vBB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	flds	s0, [r2]
+	flds	s1, [r2, #8]
+	ldr		r0, [r3, #4]
+	ldr		r1, [r2, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_DOUBLE_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_DOUBLE: /* 0xaf */
-/* File: armv5te/OP_REM_DOUBLE.S */
+/* File: armv5te_taint/OP_REM_DOUBLE.S */
 /* EABI doesn't define a double remainder function, but libm does */
-/* File: armv5te/binopWide.S */
+/* File: armv5te_taint/binopWide.S */
     /*
      * Generic 64-bit binary operation.  Provide an "instr" line that
      * specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5227,11 +5518,9 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- AA
     and     r2, r0, #255                @ r2<- BB
     mov     r3, r0, lsr #8              @ r3<- CC
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
-    add     r2, rFP, r2, lsl #2         @ r2<- &fp[BB]
-    add     r3, rFP, r3, lsl #2         @ r3<- &fp[CC]
-    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
-    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_DOUBLE_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5241,16 +5530,23 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      fmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 14-17 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_2ADDR: /* 0xb0 */
-/* File: armv6t2/OP_ADD_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_ADD_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5274,6 +5570,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_ADD_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5284,11 +5582,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_INT_2ADDR: /* 0xb1 */
-/* File: armv6t2/OP_SUB_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SUB_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5312,6 +5611,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SUB_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5322,12 +5623,13 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_2ADDR: /* 0xb2 */
-/* File: armv6t2/OP_MUL_INT_2ADDR.S */
+/* File: armv6t2_taint/OP_MUL_INT_2ADDR.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5351,6 +5653,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_MUL_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5361,11 +5665,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_2ADDR: /* 0xb3 */
-/* File: armv6t2/OP_DIV_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_DIV_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5389,6 +5694,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_DIV_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5399,12 +5706,13 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_2ADDR: /* 0xb4 */
-/* File: armv6t2/OP_REM_INT_2ADDR.S */
+/* File: armv6t2_taint/OP_REM_INT_2ADDR.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5428,6 +5736,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_REM_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5438,11 +5748,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_2ADDR: /* 0xb5 */
-/* File: armv6t2/OP_AND_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_AND_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5466,6 +5777,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_AND_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5476,11 +5789,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_2ADDR: /* 0xb6 */
-/* File: armv6t2/OP_OR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_OR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5504,6 +5818,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_OR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5514,11 +5830,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_2ADDR: /* 0xb7 */
-/* File: armv6t2/OP_XOR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_XOR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5542,6 +5859,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_XOR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -5552,11 +5871,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT_2ADDR: /* 0xb8 */
-/* File: armv6t2/OP_SHL_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SHL_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5580,6 +5900,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SHL_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5590,11 +5912,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT_2ADDR: /* 0xb9 */
-/* File: armv6t2/OP_SHR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_SHR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5618,6 +5941,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_SHR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5628,11 +5953,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT_2ADDR: /* 0xba */
-/* File: armv6t2/OP_USHR_INT_2ADDR.S */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/OP_USHR_INT_2ADDR.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -5656,6 +5982,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_USHR_INT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -5666,11 +5994,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_LONG_2ADDR: /* 0xbb */
-/* File: armv6t2/OP_ADD_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_ADD_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5686,12 +6015,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_ADD_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5701,16 +6030,23 @@ dalvik_inst:
     adds    r0, r0, r2                           @ optional op; may set condition codes
     adc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_LONG_2ADDR: /* 0xbc */
-/* File: armv6t2/OP_SUB_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_SUB_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5726,12 +6062,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_SUB_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5741,15 +6077,22 @@ dalvik_inst:
     subs    r0, r0, r2                           @ optional op; may set condition codes
     sbc     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_LONG_2ADDR: /* 0xbd */
-/* File: armv6t2/OP_MUL_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_MUL_LONG_2ADDR.S */
     /*
      * Signed 64-bit integer multiply, "/2addr" version.
      *
@@ -5759,27 +6102,33 @@ dalvik_inst:
      * again we stuff it into rINST.
      */
     /* mul-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     rINST, rFP, r9, lsl #2      @ rINST<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
-    mul     ip, r2, r1                  @  ip<- ZxW
+// begin WITH_TAINT_TRACKING
+	bl		mul_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
     umull   r9, r10, r2, r0             @  r9/r10 <- ZxX
     mla     r2, r0, r3, ip              @  r2<- YxX + (ZxW)
     mov     r0, rINST                   @ r0<- &fp[A] (free up rINST)
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     add     r10, r2, r10                @  r10<- r10 + low(ZxW + (YxX))
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_LONG_2ADDR: /* 0xbe */
-/* File: armv6t2/OP_DIV_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_DIV_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5795,12 +6144,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_DIV_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5810,17 +6159,24 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_LONG_2ADDR: /* 0xbf */
-/* File: armv6t2/OP_REM_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_REM_LONG_2ADDR.S */
 /* ldivmod returns quotient in r0/r1 and remainder in r2/r3 */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5836,12 +6192,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 1
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5851,16 +6207,23 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      __aeabi_ldivmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r2,r3}     @ vAA/vAA+1<- r2/r3
+    str		r2, [r9, #0]
+    str		r10, [r9, #4]
+    str		r3, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_LONG_2ADDR: /* 0xc0 */
-/* File: armv6t2/OP_AND_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_AND_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5876,12 +6239,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_AND_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5891,16 +6254,23 @@ dalvik_inst:
     and     r0, r0, r2                           @ optional op; may set condition codes
     and     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_LONG_2ADDR: /* 0xc1 */
-/* File: armv6t2/OP_OR_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_OR_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5916,12 +6286,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_OR_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5931,16 +6301,23 @@ dalvik_inst:
     orr     r0, r0, r2                           @ optional op; may set condition codes
     orr     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_LONG_2ADDR: /* 0xc2 */
-/* File: armv6t2/OP_XOR_LONG_2ADDR.S */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/OP_XOR_LONG_2ADDR.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -5956,12 +6333,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_XOR_LONG_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -5971,26 +6348,34 @@ dalvik_inst:
     eor     r0, r0, r2                           @ optional op; may set condition codes
     eor     r1, r1, r3                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_LONG_2ADDR: /* 0xc3 */
-/* File: armv6t2/OP_SHL_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_SHL_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* shl-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		shl_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r1, r1, asl r2              @  r1<- r1 << r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6004,18 +6389,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_LONG_2ADDR: /* 0xc4 */
-/* File: armv6t2/OP_SHR_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_SHR_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* shr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		shr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6029,18 +6415,19 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_LONG_2ADDR: /* 0xc5 */
-/* File: armv6t2/OP_USHR_LONG_2ADDR.S */
+/* File: armv5te_taint/OP_USHR_LONG_2ADDR.S */
     /*
      * Long integer shift, 2addr version.  vA is 64-bit value/result, vB is
      * 32-bit shift distance.
      */
     /* ushr-long/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r3, rINST, lsr #12          @ r3<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    and     r9, r9, #15
     GET_VREG(r2, r3)                    @ r2<- vB
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    and     r2, r2, #63                 @ r2<- r2 & 0x3f
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+// begin WITH_TAINT_TRACKING
+	bl		ushr_long_2addr_taint_prop
+// end WITH_TAINT_TRACKING
 
     mov     r0, r0, lsr r2              @  r0<- r2 >> r2
     rsb     r3, r2, #32                 @  r3<- 32 - r2
@@ -6054,8 +6441,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_FLOAT_2ADDR: /* 0xc6 */
-/* File: arm-vfp/OP_ADD_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_ADD_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6069,21 +6456,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fadds   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_FLOAT_2ADDR: /* 0xc7 */
-/* File: arm-vfp/OP_SUB_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_SUB_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6097,21 +6487,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fsubs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_FLOAT_2ADDR: /* 0xc8 */
-/* File: arm-vfp/OP_MUL_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_MUL_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6125,21 +6518,24 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fmuls   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_FLOAT_2ADDR: /* 0xc9 */
-/* File: arm-vfp/OP_DIV_FLOAT_2ADDR.S */
-/* File: arm-vfp/fbinop2addr.S */
+/* File: arm-vfp_taint/OP_DIV_FLOAT_2ADDR.S */
+/* File: arm-vfp_taint/fbinop2addr.S */
     /*
      * Generic 32-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6153,22 +6549,25 @@ dalvik_inst:
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
     flds    s1, [r3]                    @ s1<- vB
+// begin WITH_TAINT_TRACKING
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
     flds    s0, [r9]                    @ s0<- vA
-
-    fdivs   s2, s0, s1                              @ s2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fsts    s2, [r9]                    @ vAA<- s2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	ldr		r1, [r9, #4]
+	orr		r0, r0, r1
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_FLOAT_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_FLOAT_2ADDR: /* 0xca */
-/* File: armv6t2/OP_REM_FLOAT_2ADDR.S */
+/* File: armv6t2_taint/OP_REM_FLOAT_2ADDR.S */
 /* EABI doesn't define a float remainder function, but libm does */
-/* File: armv6t2/binop2addr.S */
+/* File: armv6t2_taint/binop2addr.S */
     /*
      * Generic 32-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6192,6 +6591,8 @@ dalvik_inst:
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+
+	bl		.LOP_REM_FLOAT_2ADDR_taint_prop
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6202,11 +6603,12 @@ dalvik_inst:
     /* 10-13 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_DOUBLE_2ADDR: /* 0xcb */
-/* File: arm-vfp/OP_ADD_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_ADD_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6220,22 +6622,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    faddd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_ADD_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_SUB_DOUBLE_2ADDR: /* 0xcc */
-/* File: arm-vfp/OP_SUB_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_SUB_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6249,22 +6657,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fsubd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_SUB_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_DOUBLE_2ADDR: /* 0xcd */
-/* File: arm-vfp/OP_MUL_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_MUL_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6278,22 +6692,28 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fmuld   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_MUL_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_DOUBLE_2ADDR: /* 0xce */
-/* File: arm-vfp/OP_DIV_DOUBLE_2ADDR.S */
-/* File: arm-vfp/fbinopWide2addr.S */
+/* File: arm-vfp_taint/OP_DIV_DOUBLE_2ADDR.S */
+/* File: arm-vfp_taint/fbinopWide2addr.S */
     /*
      * Generic 64-bit floating point "/2addr" binary operation.  Provide
      * an "instr" line that specifies an instruction that performs
@@ -6307,23 +6727,29 @@ dalvik_inst:
     mov     r9, rINST, lsr #8           @ r9<- A+
     VREG_INDEX_TO_ADDR(r3, r3)          @ r3<- &vB
     and     r9, r9, #15                 @ r9<- A
-    fldd    d1, [r3]                    @ d1<- vB
+// begin WITH_TAINT_TRACKING
+//    fldd    d1, [r3]                    @ d1<- vB
+	flds	s2, [r3]
+	flds	s3, [r3, #8]
+	ldr		r0, [r3, #4]
+// end WITH_TAINT_TRACKING
     VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vA
     FETCH_ADVANCE_INST(1)               @ advance rPC, load rINST
-    fldd    d0, [r9]                    @ d0<- vA
-
-    fdivd   d2, d0, d1                              @ d2<- op
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    fstd    d2, [r9]                    @ vAA<- d2
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    fldd    d0, [r9]                    @ d0<- vA
+    flds	s0, [r9]
+    flds	s1, [r9, #8]
+    ldr		r1, [r9, #4]
+// end WITH_TAINT_TRACKING
+	b     .LOP_DIV_DOUBLE_2ADDR_finish
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_DOUBLE_2ADDR: /* 0xcf */
-/* File: armv6t2/OP_REM_DOUBLE_2ADDR.S */
+/* File: armv5te_taint/OP_REM_DOUBLE_2ADDR.S */
 /* EABI doesn't define a double remainder function, but libm does */
-/* File: armv6t2/binopWide2addr.S */
+/* File: armv5te_taint/binopWide2addr.S */
     /*
      * Generic 64-bit "/2addr" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0-r1 op r2-r3".
@@ -6339,12 +6765,12 @@ dalvik_inst:
      *      rem-double/2addr
      */
     /* binop/2addr vA, vB */
+    mov     r9, rINST, lsr #8           @ r9<- A+
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
-    add     r1, rFP, r1, lsl #2         @ r1<- &fp[B]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[A]
-    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
-    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    and     r9, r9, #15
+// begin WITH_TAINT_TRACKING
+    bl		.LOP_REM_DOUBLE_2ADDR_taint_prop
+// end WITH_TAINT_TRACKING
     .if 0
     orrs    ip, r2, r3                  @ second arg (r2-r3) is zero?
     beq     common_errDivideByZero
@@ -6354,16 +6780,23 @@ dalvik_inst:
                                @ optional op; may set condition codes
     bl      fmod                              @ result<- op, r0-r3 changed
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0,r1}     @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
     /* 12-15 instructions */
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_LIT16: /* 0xd0 */
-/* File: armv6t2/OP_ADD_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_ADD_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6379,8 +6812,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6397,9 +6836,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RSUB_INT: /* 0xd1 */
-/* File: armv6t2/OP_RSUB_INT.S */
+/* File: armv5te_taint/OP_RSUB_INT.S */
 /* this op is "rsub-int", but can be thought of as "rsub-int/lit16" */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6415,8 +6854,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6433,9 +6878,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_LIT16: /* 0xd2 */
-/* File: armv6t2/OP_MUL_INT_LIT16.S */
+/* File: armv5te_taint/OP_MUL_INT_LIT16.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6451,8 +6896,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6469,8 +6920,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_LIT16: /* 0xd3 */
-/* File: armv6t2/OP_DIV_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_DIV_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6486,8 +6937,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 1
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6504,9 +6961,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_LIT16: /* 0xd4 */
-/* File: armv6t2/OP_REM_INT_LIT16.S */
+/* File: armv5te_taint/OP_REM_INT_LIT16.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6522,8 +6979,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 1
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6540,8 +7003,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_LIT16: /* 0xd5 */
-/* File: armv6t2/OP_AND_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_AND_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6557,8 +7020,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6575,8 +7044,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_LIT16: /* 0xd6 */
-/* File: armv6t2/OP_OR_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_OR_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6592,8 +7061,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6610,8 +7085,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_LIT16: /* 0xd7 */
-/* File: armv6t2/OP_XOR_INT_LIT16.S */
-/* File: armv6t2/binopLit16.S */
+/* File: armv5te_taint/OP_XOR_INT_LIT16.S */
+/* File: armv5te_taint/binopLit16.S */
     /*
      * Generic 32-bit "lit16" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6627,8 +7102,14 @@ dalvik_inst:
     /* binop/lit16 vA, vB, #+CCCC */
     FETCH_S(r1, 1)                      @ r1<- ssssCCCC (sign-extended)
     mov     r2, rINST, lsr #12          @ r2<- B
-    ubfx    r9, rINST, #8, #4           @ r9<- A
+    mov     r9, rINST, lsr #8           @ r9<- A+
     GET_VREG(r0, r2)                    @ r0<- vB
+    and     r9, r9, #15
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r3)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r3)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r3)
+// END WITH_TAINT_TRACKING
     .if 0
     cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
@@ -6645,8 +7126,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_ADD_INT_LIT8: /* 0xd8 */
-/* File: armv5te/OP_ADD_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_ADD_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6670,6 +7151,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6683,8 +7169,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_RSUB_INT_LIT8: /* 0xd9 */
-/* File: armv5te/OP_RSUB_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_RSUB_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6708,6 +7194,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6721,9 +7212,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_MUL_INT_LIT8: /* 0xda */
-/* File: armv5te/OP_MUL_INT_LIT8.S */
+/* File: armv5te_taint/OP_MUL_INT_LIT8.S */
 /* must be "mul r0, r1, r0" -- "r0, r0, r1" is illegal */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6747,6 +7238,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6760,8 +7256,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_DIV_INT_LIT8: /* 0xdb */
-/* File: armv5te/OP_DIV_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_DIV_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6785,6 +7281,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6798,9 +7299,9 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_REM_INT_LIT8: /* 0xdc */
-/* File: armv5te/OP_REM_INT_LIT8.S */
+/* File: armv5te_taint/OP_REM_INT_LIT8.S */
 /* idivmod returns quotient in r0 and remainder in r1 */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6824,6 +7325,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6837,8 +7343,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_AND_INT_LIT8: /* 0xdd */
-/* File: armv5te/OP_AND_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_AND_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6862,6 +7368,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6875,8 +7386,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_OR_INT_LIT8: /* 0xde */
-/* File: armv5te/OP_OR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_OR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6900,6 +7411,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6913,8 +7429,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_XOR_INT_LIT8: /* 0xdf */
-/* File: armv5te/OP_XOR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_XOR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6938,6 +7454,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
                                @ optional op; may set condition codes
@@ -6951,8 +7472,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHL_INT_LIT8: /* 0xe0 */
-/* File: armv5te/OP_SHL_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_SHL_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -6976,6 +7497,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -6989,8 +7515,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SHR_INT_LIT8: /* 0xe1 */
-/* File: armv5te/OP_SHR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_SHR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7014,6 +7540,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -7027,8 +7558,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_USHR_INT_LIT8: /* 0xe2 */
-/* File: armv5te/OP_USHR_INT_LIT8.S */
-/* File: armv5te/binopLit8.S */
+/* File: armv5te_taint/OP_USHR_INT_LIT8.S */
+/* File: armv5te_taint/binopLit8.S */
     /*
      * Generic 32-bit "lit8" binary operation.  Provide an "instr" line
      * that specifies an instruction that performs "result = r0 op r1".
@@ -7052,6 +7583,11 @@ dalvik_inst:
     @cmp     r1, #0                      @ is second operand zero?
     beq     common_errDivideByZero
     .endif
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r10)					@ r3<- rFP+4
+	GET_VREG_TAINT(r2, r2, r10)			@ r2<- vB.taint
+    SET_VREG_TAINT(r2, r9, r10)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
 
     and     r1, r1, #31                           @ optional op; may set condition codes
@@ -7065,7 +7601,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_VOLATILE: /* 0xe3 */
-/* File: armv5te/OP_IGET_VOLATILE.S */
+/* File: armv5te_taint/OP_IGET_VOLATILE.S */
 /* File: armv5te/OP_IGET.S */
     /*
      * General 32-bit instance field get.
@@ -7093,7 +7629,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_VOLATILE: /* 0xe4 */
-/* File: armv5te/OP_IPUT_VOLATILE.S */
+/* File: armv5te_taint/OP_IPUT_VOLATILE.S */
 /* File: armv5te/OP_IPUT.S */
     /*
      * General 32-bit instance field put.
@@ -7121,7 +7657,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_VOLATILE: /* 0xe5 */
-/* File: armv5te/OP_SGET_VOLATILE.S */
+/* File: armv5te_taint/OP_SGET_VOLATILE.S */
 /* File: armv5te/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
@@ -7148,7 +7684,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_VOLATILE: /* 0xe6 */
-/* File: armv5te/OP_SPUT_VOLATILE.S */
+/* File: armv5te_taint/OP_SPUT_VOLATILE.S */
 /* File: armv5te/OP_SPUT.S */
     /*
      * General 32-bit SPUT handler.
@@ -7175,7 +7711,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT_VOLATILE: /* 0xe7 */
-/* File: armv5te/OP_IGET_OBJECT_VOLATILE.S */
+/* File: armv5te_taint/OP_IGET_OBJECT_VOLATILE.S */
 /* File: armv5te/OP_IGET.S */
     /*
      * General 32-bit instance field get.
@@ -7203,7 +7739,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE_VOLATILE: /* 0xe8 */
-/* File: armv5te/OP_IGET_WIDE_VOLATILE.S */
+/* File: armv5te_taint/OP_IGET_WIDE_VOLATILE.S */
 /* File: armv5te/OP_IGET_WIDE.S */
     /*
      * Wide 32-bit instance field get.
@@ -7229,7 +7765,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_WIDE_VOLATILE: /* 0xe9 */
-/* File: armv5te/OP_IPUT_WIDE_VOLATILE.S */
+/* File: armv5te_taint/OP_IPUT_WIDE_VOLATILE.S */
 /* File: armv5te/OP_IPUT_WIDE.S */
     /* iput-wide vA, vB, field@CCCC */
     mov     r0, rINST, lsr #12          @ r0<- B
@@ -7252,7 +7788,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_WIDE_VOLATILE: /* 0xea */
-/* File: armv5te/OP_SGET_WIDE_VOLATILE.S */
+/* File: armv5te_taint/OP_SGET_WIDE_VOLATILE.S */
 /* File: armv5te/OP_SGET_WIDE.S */
     /*
      * 64-bit SGET handler.
@@ -7282,7 +7818,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_WIDE_VOLATILE: /* 0xeb */
-/* File: armv5te/OP_SPUT_WIDE_VOLATILE.S */
+/* File: armv5te_taint/OP_SPUT_WIDE_VOLATILE.S */
 /* File: armv5te/OP_SPUT_WIDE.S */
     /*
      * 64-bit SPUT handler.
@@ -7312,7 +7848,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_BREAKPOINT: /* 0xec */
-/* File: armv5te/OP_BREAKPOINT.S */
+/* File: armv5te_taint/OP_BREAKPOINT.S */
 /* File: armv5te/unused.S */
     bl      common_abort
 
@@ -7320,7 +7856,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_THROW_VERIFICATION_ERROR: /* 0xed */
-/* File: armv5te/OP_THROW_VERIFICATION_ERROR.S */
+/* File: armv5te_taint/OP_THROW_VERIFICATION_ERROR.S */
     /*
      * Handle a throw-verification-error instruction.  This throws an
      * exception for an error discovered during verification.  The
@@ -7337,22 +7873,21 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_EXECUTE_INLINE: /* 0xee */
-/* File: armv5te/OP_EXECUTE_INLINE.S */
+/* File: armv5te_taint/OP_EXECUTE_INLINE.S */
     /*
      * Execute a "native inline" instruction.
      *
-     * We need to call an InlineOp4Func:
-     *  bool (func)(u4 arg0, u4 arg1, u4 arg2, u4 arg3, JValue* pResult)
+     * We need to call:
+     *  dvmPerformInlineOp4Std(arg0, arg1, arg2, arg3, &retval, ref)
      *
-     * The first four args are in r0-r3, pointer to return value storage
-     * is on the stack.  The function's return value is a flag that tells
-     * us if an exception was thrown.
+     * The first four args are in r0-r3, but the last two must be pushed
+     * onto the stack.
      */
     /* [opt] execute-inline vAA, {vC, vD, vE, vF}, inline@BBBB */
     FETCH(r10, 1)                       @ r10<- BBBB
     add     r1, rGLUE, #offGlue_retval  @ r1<- &glue->retval
     EXPORT_PC()                         @ can throw
-    sub     sp, sp, #8                  @ make room for arg, +64 bit align
+    sub     sp, sp, #8                  @ make room for arg(s)
     mov     r0, rINST, lsr #12          @ r0<- B
     str     r1, [sp]                    @ push &glue->retval
     bl      .LOP_EXECUTE_INLINE_continue        @ make call; will return after
@@ -7366,7 +7901,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_EXECUTE_INLINE_RANGE: /* 0xef */
-/* File: armv5te/OP_EXECUTE_INLINE_RANGE.S */
+/* File: armv5te_taint/OP_EXECUTE_INLINE_RANGE.S */
     /*
      * Execute a "native inline" instruction, using "/range" semantics.
      * Same idea as execute-inline, but we get the args differently.
@@ -7396,7 +7931,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_DIRECT_EMPTY: /* 0xf0 */
-/* File: armv5te/OP_INVOKE_DIRECT_EMPTY.S */
+/* File: armv5te_taint/OP_INVOKE_DIRECT_EMPTY.S */
     /*
      * invoke-direct-empty is a no-op in a "standard" interpreter.
      */
@@ -7407,109 +7942,161 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_F1: /* 0xf1 */
-/* File: armv5te/OP_UNUSED_F1.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_F1.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_QUICK: /* 0xf2 */
-/* File: armv6t2/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_WIDE_QUICK: /* 0xf3 */
-/* File: armv6t2/OP_IGET_WIDE_QUICK.S */
+/* File: armv5te_taint/OP_IGET_WIDE_QUICK.S */
     /* iget-wide-quick vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(ip, 1)                        @ ip<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
-    ldrd    r0, [r3, ip]                @ r0<- obj.field (64 bits, aligned)
+// begin WITH_TAINT_TRACKING
+	add		r10, r1, #8
+    ldrd    r0, [r3, r1]                @ r0<- obj.field (64 bits, aligned)
+    ldr		r10, [r3, r10]
+    orr		r10, r9, r10
+// end WITH_TAINT_TRACKING
+    and     r2, r2, #15
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+	bl		iget_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IGET_OBJECT_QUICK: /* 0xf4 */
-/* File: armv5te/OP_IGET_OBJECT_QUICK.S */
-/* File: armv5te/OP_IGET_QUICK.S */
+/* File: armv5te_taint/OP_IGET_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IGET_QUICK.S */
     /* For: iget-quick, iget-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
     GET_VREG(r3, r2)                    @ r3<- object we're operating on
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r9, r2, r0)
+// end WITH_TAINT_TRACKING
     FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
     mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
     ldr     r0, [r3, r1]                @ r0<- obj.field (always 32 bits)
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// begin WITH_TAINT_TRACKING
+	bl		.LOP_IGET_OBJECT_QUICK_taint_prop
+//    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST // PJG: in subroutine
+// end WITH_TAINT_TRACKING
     and     r2, r2, #15
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_VREG_TAINT(r10, r2, r0)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_QUICK: /* 0xf5 */
-/* File: armv6t2/OP_IPUT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_QUICK.S */
     /* For: iput-quick, iput-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
-    FETCH(r1, 1)                        @ r1<- field byte offset
     GET_VREG(r3, r2)                    @ r3<- fp[B], the object pointer
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    FETCH(r1, 1)                        @ r1<- field byte offset
     cmp     r3, #0                      @ check object for null
+    mov     r2, rINST, lsr #8           @ r2<- A(+)
     beq     common_errNullObject        @ object was null
+    and     r2, r2, #15
     GET_VREG(r0, r2)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_WIDE_QUICK: /* 0xf6 */
-/* File: armv6t2/OP_IPUT_WIDE_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_WIDE_QUICK.S */
     /* iput-wide-quick vA, vB, offset@CCCC */
+    mov     r0, rINST, lsr #8           @ r0<- A(+)
     mov     r1, rINST, lsr #12          @ r1<- B
-    ubfx    r0, rINST, #8, #4           @ r0<- A
+    and     r0, r0, #15
     GET_VREG(r2, r1)                    @ r2<- fp[B], the object pointer
-    add     r3, rFP, r0, lsl #2         @ r3<- &fp[A]
-    cmp     r2, #0                      @ check object for null
-    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+// begin WITH_TAINT_TRACKING
+	bl iput_wide_quick_taint_prop
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH(r3, 1)                        @ r3<- field byte offset
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     strd    r0, [r2, r3]                @ obj.field (64 bits, aligned)<- r0/r1
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r9, [r2, r3]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT_QUICK: /* 0xf7 */
-/* File: armv5te/OP_IPUT_OBJECT_QUICK.S */
-    /* For: iput-object-quick */
+/* File: armv5te_taint/OP_IPUT_OBJECT_QUICK.S */
+/* File: armv5te_taint/OP_IPUT_QUICK.S */
+    /* For: iput-quick, iput-object-quick */
     /* op vA, vB, offset@CCCC */
     mov     r2, rINST, lsr #12          @ r2<- B
     GET_VREG(r3, r2)                    @ r3<- fp[B], the object pointer
@@ -7519,126 +8106,68 @@ dalvik_inst:
     beq     common_errNullObject        @ object was null
     and     r2, r2, #15
     GET_VREG(r0, r2)                    @ r0<- fp[A]
-    ldr     r2, [rGLUE, #offGlue_cardTable]  @ r2<- card table base
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r9)
+	GET_VREG_TAINT(r10, r2, r9)
+// end WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     str     r0, [r3, r1]                @ obj.field (always 32 bits)<- r0
-    cmp     r0, #0
-    strneb  r2, [r2, r3, lsr #GC_CARD_SHIFT] @ mark card based on obj head
+// begin WITH_TAINT_TRACKING
+	add		r1, r1, #4
+	str		r10, [r3, r1]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK: /* 0xf8 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!0)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodNoRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_VIRTUAL_QUICK_RANGE: /* 0xf9 */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_VIRTUAL_QUICK.S */
-    /*
-     * Handle an optimized virtual method call.
-     *
-     * for: [opt] invoke-virtual-quick, invoke-virtual-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r3, 2)                        @ r3<- FEDC or CCCC
-    FETCH(r1, 1)                        @ r1<- BBBB
-    .if     (!1)
-    and     r3, r3, #15                 @ r3<- C (or stays CCCC)
-    .endif
-    GET_VREG(r2, r3)                    @ r2<- vC ("this" ptr)
-    cmp     r2, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r2, [r2, #offObject_clazz]  @ r2<- thisPtr->clazz
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- thisPtr->clazz->vtable
-    EXPORT_PC()                         @ invoke must export
-    ldr     r0, [r2, r1, lsl #2]        @ r3<- vtable[BBBB]
-    bl      common_invokeMethodRange @ continue on
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_VIRTUAL_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK: /* 0xfa */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!0)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodNoRange @ continue on
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_INVOKE_SUPER_QUICK_RANGE: /* 0xfb */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK_RANGE.S */
-/* File: armv5te/OP_INVOKE_SUPER_QUICK.S */
-    /*
-     * Handle an optimized "super" method call.
-     *
-     * for: [opt] invoke-super-quick, invoke-super-quick/range
-     */
-    /* op vB, {vD, vE, vF, vG, vA}, class@CCCC */
-    /* op vAA, {vCCCC..v(CCCC+AA-1)}, meth@BBBB */
-    FETCH(r10, 2)                       @ r10<- GFED or CCCC
-    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
-    .if     (!1)
-    and     r10, r10, #15               @ r10<- D (or stays CCCC)
-    .endif
-    FETCH(r1, 1)                        @ r1<- BBBB
-    ldr     r2, [r2, #offMethod_clazz]  @ r2<- method->clazz
-    EXPORT_PC()                         @ must export for invoke
-    ldr     r2, [r2, #offClassObject_super]     @ r2<- method->clazz->super
-    GET_VREG(r3, r10)                   @ r3<- "this"
-    ldr     r2, [r2, #offClassObject_vtable]    @ r2<- ...clazz->super->vtable
-    cmp     r3, #0                      @ null "this" ref?
-    ldr     r0, [r2, r1, lsl #2]        @ r0<- super->vtable[BBBB]
-    beq     common_errNullObject        @ "this" is null, throw exception
-    bl      common_invokeMethodRange @ continue on
-
-
+    /* (stub) */
+    SAVE_PC_FP_TO_GLUE()            @ only need to export these two
+    mov     r0, rGLUE               @ glue is first arg to function
+    bl      dvmMterp_OP_INVOKE_SUPER_QUICK_RANGE      @ call
+    LOAD_PC_FP_FROM_GLUE()          @ retrieve updated values
+    FETCH_INST()                    @ load next instruction from rPC
+    GET_INST_OPCODE(ip)             @ ...trim down to just the opcode
+    GOTO_OPCODE(ip)                 @ ...and jump to the handler
 /* ------------------------------ */
     .balign 64
 .L_OP_IPUT_OBJECT_VOLATILE: /* 0xfc */
-/* File: armv5te/OP_IPUT_OBJECT_VOLATILE.S */
+/* File: armv5te_taint/OP_IPUT_OBJECT_VOLATILE.S */
 /* File: armv5te/OP_IPUT_OBJECT.S */
     /*
      * 32-bit instance field put.
@@ -7666,7 +8195,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SGET_OBJECT_VOLATILE: /* 0xfd */
-/* File: armv5te/OP_SGET_OBJECT_VOLATILE.S */
+/* File: armv5te_taint/OP_SGET_OBJECT_VOLATILE.S */
 /* File: armv5te/OP_SGET.S */
     /*
      * General 32-bit SGET handler.
@@ -7693,7 +8222,7 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_SPUT_OBJECT_VOLATILE: /* 0xfe */
-/* File: armv5te/OP_SPUT_OBJECT_VOLATILE.S */
+/* File: armv5te_taint/OP_SPUT_OBJECT_VOLATILE.S */
 /* File: armv5te/OP_SPUT_OBJECT.S */
     /*
      * 32-bit SPUT handler for objects
@@ -7720,8 +8249,8 @@ dalvik_inst:
 /* ------------------------------ */
     .balign 64
 .L_OP_UNUSED_FF: /* 0xff */
-/* File: armv5te/OP_UNUSED_FF.S */
-/* File: armv5te/unused.S */
+/* File: armv5te_taint/OP_UNUSED_FF.S */
+/* File: armv5te_taint/unused.S */
     bl      common_abort
 
 
@@ -7756,6 +8285,11 @@ dvmAsmSisterStart:
     bl      dvmResolveString            @ r0<- String reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7775,6 +8309,11 @@ dvmAsmSisterStart:
     bl      dvmResolveString            @ r0<- String reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7795,6 +8334,11 @@ dvmAsmSisterStart:
     bl      dvmResolveClass             @ r0<- Class reference
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yup, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r9)                    @ vAA<- r0
@@ -7862,6 +8406,11 @@ dvmAsmSisterStart:
      */
 .LOP_INSTANCE_OF_store:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7874,6 +8423,11 @@ dvmAsmSisterStart:
     mov     r0, #1                      @ indicate success
     @ could b OP_INSTANCE_OF_store, but copying is faster and cheaper
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r9, r2)
+// END WITH_TAINT_TRACKING
     SET_VREG(r0, r9)                    @ vA<- r0
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7906,6 +8460,11 @@ dvmAsmSisterStart:
     mov     r3, rINST, lsr #8           @ r3<- AA
     cmp     r0, #0                      @ failed?
     beq     common_exceptionThrown      @ yes, handle the exception
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	SET_TAINT_CLEAR(r1)
+    SET_VREG_TAINT(r1, r3, r2)
+// END WITH_TAINT_TRACKING
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r3)                    @ vAA<- r0
@@ -7976,6 +8535,11 @@ dvmAsmSisterStart:
     beq     common_exceptionThrown      @ yes, handle the exception
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
+// BEGIN WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r3)
+    SET_VREG_TAINT(r3, r2, r1)
+// END WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ vA<- r0
     GOTO_OPCODE(ip)                     @ jump to next instruction
@@ -7990,15 +8554,15 @@ dvmAsmSisterStart:
 .LOP_FILLED_NEW_ARRAY_continue:
     ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
     mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    ldrb    r3, [r3, #1]                @ r3<- descriptor[1]
     .if     0
     mov     r1, r10                     @ r1<- AA (length)
     .else
     mov     r1, r10, lsr #4             @ r1<- B (length)
     .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
+    cmp     r3, #'I'                    @ array of ints?
+    cmpne   r3, #'L'                    @ array of objects?
+    cmpne   r3, #'['                    @ array of arrays?
     mov     r9, r1                      @ save length in r9
     bne     .LOP_FILLED_NEW_ARRAY_notimpl         @ no, not handled yet
     bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
@@ -8006,8 +8570,10 @@ dvmAsmSisterStart:
     beq     common_exceptionThrown      @ alloc failed, handle exception
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rGLUE, #offGlue_retval]      @ retval.l <- new array
-    str     rINST, [rGLUE, #offGlue_retval+4] @ retval.h <- type
+    str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -8016,6 +8582,11 @@ dvmAsmSisterStart:
     @ copy values from registers into the array
     @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
     .if     0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r3)
+	str		r3, [rGLUE, #offGlue_rtaint]	@ rtaint <- clear
+	str		r3, [r2]
+// end WITH_TAINT_TRACKING
     add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
 1:  ldr     r3, [r2], #4                @ r3<- *r2++
     subs    r9, r9, #1                  @ count--
@@ -8039,13 +8610,8 @@ dvmAsmSisterStart:
     .endif
 
 2:
-    ldr     r0, [rGLUE, #offGlue_retval]     @ r0<- object
-    ldr     r1, [rGLUE, #offGlue_retval+4]   @ r1<- type
-    ldr     r2, [rGLUE, #offGlue_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    GOTO_OPCODE(ip)                     @ execute it
 
     /*
      * Throw an exception indicating that we have not implemented this
@@ -8074,15 +8640,15 @@ dvmAsmSisterStart:
 .LOP_FILLED_NEW_ARRAY_RANGE_continue:
     ldr     r3, [r0, #offClassObject_descriptor] @ r3<- arrayClass->descriptor
     mov     r2, #ALLOC_DONT_TRACK       @ r2<- alloc flags
-    ldrb    rINST, [r3, #1]             @ rINST<- descriptor[1]
+    ldrb    r3, [r3, #1]                @ r3<- descriptor[1]
     .if     1
     mov     r1, r10                     @ r1<- AA (length)
     .else
     mov     r1, r10, lsr #4             @ r1<- B (length)
     .endif
-    cmp     rINST, #'I'                 @ array of ints?
-    cmpne   rINST, #'L'                 @ array of objects?
-    cmpne   rINST, #'['                 @ array of arrays?
+    cmp     r3, #'I'                    @ array of ints?
+    cmpne   r3, #'L'                    @ array of objects?
+    cmpne   r3, #'['                    @ array of arrays?
     mov     r9, r1                      @ save length in r9
     bne     .LOP_FILLED_NEW_ARRAY_RANGE_notimpl         @ no, not handled yet
     bl      dvmAllocArrayByClass        @ r0<- call(arClass, length, flags)
@@ -8090,8 +8656,10 @@ dvmAsmSisterStart:
     beq     common_exceptionThrown      @ alloc failed, handle exception
 
     FETCH(r1, 2)                        @ r1<- FEDC or CCCC
-    str     r0, [rGLUE, #offGlue_retval]      @ retval.l <- new array
-    str     rINST, [rGLUE, #offGlue_retval+4] @ retval.h <- type
+    str     r0, [rGLUE, #offGlue_retval]    @ retval.l <- new array
+// begin WITH_TAINT_TRACKING
+	add		r2, r0, #offArrayObject_taint
+// end WITH_TAINT_TRACKING
     add     r0, r0, #offArrayObject_contents @ r0<- newArray->contents
     subs    r9, r9, #1                  @ length--, check for neg
     FETCH_ADVANCE_INST(3)               @ advance to next instr, load rINST
@@ -8100,6 +8668,11 @@ dvmAsmSisterStart:
     @ copy values from registers into the array
     @ r0=array, r1=CCCC/FEDC, r9=length (from AA or B), r10=AA/BA
     .if     1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_CLEAR(r3)
+	str		r3, [rGLUE, #offGlue_rtaint]	@ rtaint <- clear
+	str		r3, [r2]
+// end WITH_TAINT_TRACKING
     add     r2, rFP, r1, lsl #2         @ r2<- &fp[CCCC]
 1:  ldr     r3, [r2], #4                @ r3<- *r2++
     subs    r9, r9, #1                  @ count--
@@ -8123,13 +8696,8 @@ dvmAsmSisterStart:
     .endif
 
 2:
-    ldr     r0, [rGLUE, #offGlue_retval]     @ r0<- object
-    ldr     r1, [rGLUE, #offGlue_retval+4]   @ r1<- type
-    ldr     r2, [rGLUE, #offGlue_cardTable]  @ r2<- card table base
-    GET_INST_OPCODE(ip)                      @ ip<- opcode from rINST
-    cmp     r1, #'I'                         @ Is int array?
-    strneb  r2, [r2, r0, lsr #GC_CARD_SHIFT] @ Mark card based on object head
-    GOTO_OPCODE(ip)                          @ execute it
+    GET_INST_OPCODE(ip)                 @ ip<- opcode from rINST
+    GOTO_OPCODE(ip)                     @ execute it
 
     /*
      * Throw an exception indicating that we have not implemented this
@@ -8151,21 +8719,47 @@ dvmAsmSisterStart:
 /* continuation for OP_CMPL_FLOAT */
 .LOP_CMPL_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_CMPG_FLOAT */
 .LOP_CMPG_FLOAT_finish:
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_CMPL_DOUBLE */
 .LOP_CMPL_DOUBLE_finish:
+    fmstat                              @ export status flags
+    movgt   r0, #1                      @ (greater than) r1<- 1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_CMPG_DOUBLE */
 .LOP_CMPG_DOUBLE_finish:
+    fmstat                              @ export status flags
+    mvnmi   r0, #0                      @ (less than) r1<- -1
+    moveq   r0, #0                      @ (equal) r1<- 0
     SET_VREG(r0, r9)                    @ vAA<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_TAINT_CLEAR(r0)
+	SET_VREG_TAINT(r0, r9, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_CMP_LONG */
@@ -8176,6 +8770,11 @@ dvmAsmSisterStart:
     @ instead, we just replicate the tail end.
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r9)                    @ vAA<- r1
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
@@ -8186,57 +8785,258 @@ dvmAsmSisterStart:
 .LOP_CMP_LONG_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     SET_VREG(r1, r9)                    @ vAA<- r1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r0)
+	SET_TAINT_CLEAR(r1)
+	SET_VREG_TAINT(r1, r9, r0)
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+cmp_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+	ldr		r2, [r3, #0]
+	ldr		r3, [r3, #8]
+	bx		lr
+
+/* continuation for OP_AGET */
+
+.LOP_AGET_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
 
 /* continuation for OP_AGET_WIDE */
 
 .LOP_AGET_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldrd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
-    add     r9, rFP, r9, lsl #2         @ r9<- &fp[AA]
+// begin WITH_TAINT_TRACKING
+    ldrd    r0, [r0, #offArrayObject_contents]  @ r0/r1<- vBB[vCC]
+    mov		r2, r1
+    mov		r1, r10
+    mov		r3, r10
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
+    stmia   r9, {r0-r3}                 @ vAA/vAA+1<- r2/r3
+// begin WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_AGET_WIDE_taint_prop:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r10, r3, r10)
+	orr		r10, r10, r2					@ r10<- r10 | r1
+	bx		lr
+
+/* continuation for OP_AGET_OBJECT */
+
+.LOP_AGET_OBJECT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_OBJECT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BOOLEAN */
+
+.LOP_AGET_BOOLEAN_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BOOLEAN_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_BYTE */
+
+.LOP_AGET_BYTE_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_BYTE_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_CHAR */
+
+.LOP_AGET_CHAR_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_CHAR_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_AGET_SHORT */
+
+.LOP_AGET_SHORT_taint_prop_1:
+	ldr		r2, [r0, #offArrayObject_taint]
+	SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+	orr		r2, r3, r2					@ r2<- r2 | r1
+	bx		lr
+
+.LOP_AGET_SHORT_taint_prop_2:
+    bcs     common_errArrayIndex        @ index >= length, bail
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	SET_TAINT_FP(r3)
+	SET_VREG_TAINT(r2, r9, r3)
+    bx		lr
+
+/* continuation for OP_APUT */
+
+.LOP_APUT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
 /* continuation for OP_APUT_WIDE */
 
 .LOP_APUT_WIDE_finish:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+//    ldmia   r9, {r2-r3}                 @ r2/r3<- vAA/vAA+1
+	ldr		r2, [r9, #0]
+	ldr		r3, [r9, #8]
+	ldr		r1, [r9, #4]				@ r1<- array taint
+	ldr     r9, [r10, #offArrayObject_taint]
+	orr		r1, r1, r9					@ r1<- r1 | r9
+	str		r1, [r10, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
     strd    r2, [r0, #offArrayObject_contents]  @ r2/r3<- vBB[vCC]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_APUT_OBJECT */
     /*
      * On entry:
-     *  rINST = vBB (arrayObj)
+     *  r1 = vBB (arrayObj)
      *  r9 = vAA (obj)
      *  r10 = offset into array (vBB + vCC * width)
      */
 .LOP_APUT_OBJECT_finish:
+// begin WITH_TAINT_TRACKING
+	str		r2, [r1, #offArrayObject_taint]
+// end WITH_TAINT_TRACKING
     cmp     r9, #0                      @ storing null reference?
     beq     .LOP_APUT_OBJECT_skip_check      @ yes, skip type checks
     ldr     r0, [r9, #offObject_clazz]  @ r0<- obj->clazz
-    ldr     r1, [rINST, #offObject_clazz]  @ r1<- arrayObj->clazz
+    ldr     r1, [r1, #offObject_clazz]  @ r1<- arrayObj->clazz
     bl      dvmCanPutArrayElement       @ test object type vs. array type
     cmp     r0, #0                      @ okay?
     beq     common_errArrayStore        @ no
-    mov     r1, rINST                   @ r1<- arrayObj
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldr     r2, [rGLUE, #offGlue_cardTable]     @ get biased CT base
-    add     r10, #offArrayObject_contents   @ r0<- pointer to slot
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    str     r9, [r10]                   @ vBB[vCC]<- vAA
-    strb    r2, [r2, r1, lsr #GC_CARD_SHIFT] @ mark card using object head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
 .LOP_APUT_OBJECT_skip_check:
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str     r9, [r10, #offArrayObject_contents] @ vBB[vCC]<- vAA
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+aput_object_taint_prop_1:
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r2, r9, r3)
+	bx		lr
+
+aput_object_taint_prop_2:
+	ldr     r3, [r1, #offArrayObject_taint]
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	bx		lr
+
+/* continuation for OP_APUT_BOOLEAN */
+
+.LOP_APUT_BOOLEAN_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_BYTE */
+
+.LOP_APUT_BYTE_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_CHAR */
+
+.LOP_APUT_CHAR_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
+/* continuation for OP_APUT_SHORT */
+
+.LOP_APUT_SHORT_taint_prop:
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	GET_VREG(r1, r2)                    @ r1<- vBB (array object)
+	ldr		r2, [r1, #offArrayObject_taint]
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r3, r9, r3)
+	orr		r2, r2, r3					@ r2<- r2 | r3
+	str		r2, [r1, #offArrayObject_taint]
+	bx		lr
+
 /* continuation for OP_IGET */
 
     /*
@@ -8250,12 +9050,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
+    mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_WIDE */
 
     /*
@@ -8267,14 +9084,33 @@ dvmAsmSisterStart:
     cmp     r9, #0                      @ check object for null
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
+    mov     r2, rINST, lsr #8           @ r2<- A+
     ldrd    r0, [r9, r3]                @ r0/r1<- obj.field (64-bit align ok)
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    and     r2, r2, #15                 @ r2<- A
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #8
+	ldr		r3, [r9, r3]
+	orr		r10, r3, r10
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    add     r3, rFP, r2, lsl #2         @ r3<- &fp[A]
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+iget_wide_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_OBJECT */
 
     /*
@@ -8288,14 +9124,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_OBJECT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_BOOLEAN */
 
     /*
@@ -8309,14 +9160,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BOOLEAN_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_BYTE */
 
     /*
@@ -8330,14 +9196,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_BYTE_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_CHAR */
 
     /*
@@ -8351,14 +9232,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_CHAR_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IGET_SHORT */
 
     /*
@@ -8372,14 +9268,29 @@ dvmAsmSisterStart:
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
     beq     common_errNullObject        @ object was null
     ldr   r0, [r9, r3]                @ r0<- obj.field (8/16/32 bits)
-    @ no-op                             @ acquiring load
+// begin WITH_TAINT_TRACKING
+	add r3, r3, #4
+	ldr		r3, [r9, r3]
+	orr		r3, r3, r10
+// end WITH_TAINT_TRACKING
     mov     r2, rINST, lsr #8           @ r2<- A+
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     and     r2, r2, #15                 @ r2<- A
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     SET_VREG(r0, r2)                    @ fp[A]<- r0
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r1)
+	SET_VREG_TAINT(r3, r2, r1)
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+.LOP_IGET_SHORT_taint_prop:
+    GET_VREG(r9, r0)                    @ r9<- fp[B], the object pointer
+	SET_TAINT_FP(r3)
+	GET_VREG_TAINT(r10, r0, r3)
+    ldr     r0, [r2, r1, lsl #2]        @ r0<- resolved InstField ptr
+	bx		lr
+
 /* continuation for OP_IPUT */
 
     /*
@@ -8389,14 +9300,23 @@ dvmAsmSisterStart:
      */
 .LOP_IPUT_finish:
     @bl      common_squeak0
+    mov     r1, rINST, lsr #8           @ r1<- A+
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    ubfx    r1, rINST, #8, #4           @ r1<- A
+    and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_WIDE */
@@ -8407,15 +9327,27 @@ dvmAsmSisterStart:
      *  r9 holds object
      */
 .LOP_IPUT_WIDE_finish:
-    ubfx    r2, rINST, #8, #4           @ r2<- A
+    mov     r2, rINST, lsr #8           @ r2<- A+
     cmp     r9, #0                      @ check object for null
+    and     r2, r2, #15                 @ r2<- A
     ldr     r3, [r0, #offInstField_byteOffset]  @ r3<- byte offset of field
-    add     r2, rFP, r2, lsl #2         @ r3<- &fp[A]
+// begin WITH_TAINT_TRACKING
+    add     r2, rFP, r2, lsl #3         @ r3<- &fp[A]
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+// begin WITH_TAINT_TRACKING
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r2, #0]
+	ldr		r1, [r2, #8]
+	ldr		r10, [r2, #4]
+// end WITH_TAINT_TRACKING
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     strd    r0, [r9, r3]                @ obj.field (64 bits, aligned)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #8
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_OBJECT */
@@ -8432,14 +9364,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
-    ldr     r2, [rGLUE, #offGlue_cardTable]  @ r2<- card table base
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
-    str     r0, [r9, r3]                @ obj.field (32 bits)<- r0
-    cmp     r0, #0                      @ stored a null reference?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card if not
+    str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_BOOLEAN */
@@ -8456,11 +9392,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_BYTE */
@@ -8477,11 +9420,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_CHAR */
@@ -8498,11 +9448,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_IPUT_SHORT */
@@ -8519,11 +9476,18 @@ dvmAsmSisterStart:
     and     r1, r1, #15                 @ r1<- A
     cmp     r9, #0                      @ check object for null
     GET_VREG(r0, r1)                    @ r0<- fp[A]
+// begin WITH_TAINT_TRACKING
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r10, r1, r2)
+// end WITH_TAINT_TRACKING
     beq     common_errNullObject        @ object was null
     FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
     str  r0, [r9, r3]                @ obj.field (8/16/32 bits)<- r0
+// begin WITH_TAINT_TRACKING
+	add		r3, r3, #4
+	str		r10, [r9, r3]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
 /* continuation for OP_SGET */
@@ -8543,11 +9507,25 @@ dvmAsmSisterStart:
 
 /* continuation for OP_SGET_WIDE */
 
+.LOP_SGET_WIDE_finish:
+    mov     r1, rINST, lsr #8           @ r1<- AA
+    ldrd    r2, [r0, #offStaticField_value] @ r2/r3<- field value (aligned)
+// begin WITH_TAINT_TRACKING
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[AA]
+    ldr		r0, [r0, #offStaticField_taint] @ r0<- taint value
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+//    stmia   r1, {r2-r3}                 @ vAA/vAA+1<- r2/r3
+	str		r2, [r1, #0]
+	str		r0, [r1, #4]
+	str		r3, [r1, #8]
+	str		r0, [r1, #12]
+// end WITH_TAINT_TRACKING
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
     /*
      * Continuation if the field has not yet been resolved.
      *  r1: BBBB field ref
-     *
-     * Returns StaticField pointer in r0.
      */
 .LOP_SGET_WIDE_resolve:
     ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -8654,8 +9632,6 @@ dvmAsmSisterStart:
      * Continuation if the field has not yet been resolved.
      *  r1: BBBB field ref
      *  r9: &fp[AA]
-     *
-     * Returns StaticField pointer in r2.
      */
 .LOP_SPUT_WIDE_resolve:
     ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
@@ -8663,23 +9639,23 @@ dvmAsmSisterStart:
     ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
     bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
     cmp     r0, #0                      @ success?
-    mov     r2, r0                      @ copy to r2
     bne     .LOP_SPUT_WIDE_finish          @ yes, finish
     b       common_exceptionThrown      @ no, handle exception
 
 /* continuation for OP_SPUT_OBJECT */
-.LOP_SPUT_OBJECT_finish:   @ field ptr in r0
-    mov     r2, rINST, lsr #8           @ r2<- AA
-    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
-    GET_VREG(r1, r2)                    @ r1<- fp[AA]
-    ldr     r2, [rGLUE, #offGlue_cardTable]  @ r2<- card table base
-    ldr     r9, [r0, #offField_clazz]   @ r9<- field->clazz
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    @ no-op                             @ releasing store
-    str     r1, [r0, #offStaticField_value]  @ field<- vAA
-    cmp     r1, #0                      @ stored a null object?
-    strneb  r2, [r2, r9, lsr #GC_CARD_SHIFT]  @ mark card based on obj head
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+    /*
+     * Continuation if the field has not yet been resolved.
+     *  r1: BBBB field ref
+     */
+.LOP_SPUT_OBJECT_resolve:
+    ldr     r2, [rGLUE, #offGlue_method]    @ r2<- current method
+    EXPORT_PC()                         @ resolve() could throw, so export now
+    ldr     r0, [r2, #offMethod_clazz]  @ r0<- method->clazz
+    bl      dvmResolveStaticField       @ r0<- resolved StaticField ptr
+    cmp     r0, #0                      @ success?
+    bne     .LOP_SPUT_OBJECT_finish          @ yes, finish
+    b       common_exceptionThrown      @ no, handle exception
 
 /* continuation for OP_SPUT_BOOLEAN */
 
@@ -8741,141 +9717,83 @@ dvmAsmSisterStart:
     bne     .LOP_SPUT_SHORT_finish          @ yes, finish
     b       common_exceptionThrown      @ no, handle exception
 
-/* continuation for OP_INVOKE_VIRTUAL */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-/* continuation for OP_INVOKE_SUPER */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodNoRange @ continue on
-
-.LOP_INVOKE_SUPER_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_NEG_LONG */
 
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
+.LOP_NEG_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-/* continuation for OP_INVOKE_DIRECT */
+/* continuation for OP_NOT_LONG */
 
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+.LOP_NOT_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-/* continuation for OP_INVOKE_VIRTUAL_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r10 = C or CCCC (index of first arg, which is the "this" ptr)
-     */
-.LOP_INVOKE_VIRTUAL_RANGE_continue:
-    GET_VREG(r1, r10)                   @ r1<- "this" ptr
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    cmp     r1, #0                      @ is "this" null?
-    beq     common_errNullObject        @ null "this", throw exception
-    ldr     r3, [r1, #offObject_clazz]  @ r1<- thisPtr->clazz
-    ldr     r3, [r3, #offClassObject_vtable]    @ r3<- thisPtr->clazz->vtable
-    ldr     r0, [r3, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
-
-/* continuation for OP_INVOKE_SUPER_RANGE */
-
-    /*
-     * At this point:
-     *  r0 = resolved base method
-     *  r9 = method->clazz
-     */
-.LOP_INVOKE_SUPER_RANGE_continue:
-    ldr     r1, [r9, #offClassObject_super]     @ r1<- method->clazz->super
-    ldrh    r2, [r0, #offMethod_methodIndex]    @ r2<- baseMethod->methodIndex
-    ldr     r3, [r1, #offClassObject_vtableCount]   @ r3<- super->vtableCount
-    EXPORT_PC()                         @ must export for invoke
-    cmp     r2, r3                      @ compare (methodIndex, vtableCount)
-    bcs     .LOP_INVOKE_SUPER_RANGE_nsm             @ method not present in superclass
-    ldr     r1, [r1, #offClassObject_vtable]    @ r1<- ...clazz->super->vtable
-    ldr     r0, [r1, r2, lsl #2]        @ r3<- vtable[methodIndex]
-    bl      common_invokeMethodRange @ continue on
-
-.LOP_INVOKE_SUPER_RANGE_resolve:
-    mov     r0, r9                      @ r0<- method->clazz
-    mov     r2, #METHOD_VIRTUAL         @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    bne     .LOP_INVOKE_SUPER_RANGE_continue        @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+/* continuation for OP_NEG_DOUBLE */
 
-    /*
-     * Throw a NoSuchMethodError with the method name as the message.
-     *  r0 = resolved base method
-     */
-.LOP_INVOKE_SUPER_RANGE_nsm:
-    ldr     r1, [r0, #offMethod_name]   @ r1<- method name
-    b       common_errNoSuchMethod
+.LOP_NEG_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
 
-/* continuation for OP_INVOKE_DIRECT_RANGE */
+/* continuation for OP_INT_TO_LONG */
 
-    /*
-     * On entry:
-     *  r1 = reference (BBBB or CCCC)
-     *  r10 = "this" register
-     */
-.LOP_INVOKE_DIRECT_RANGE_resolve:
-    ldr     r3, [rGLUE, #offGlue_method] @ r3<- glue->method
-    ldr     r0, [r3, #offMethod_clazz]  @ r0<- method->clazz
-    mov     r2, #METHOD_DIRECT          @ resolver method type
-    bl      dvmResolveMethod            @ r0<- call(clazz, ref, flags)
-    cmp     r0, #0                      @ got null?
-    GET_VREG(r2, r10)                   @ r2<- "this" ptr (reload)
-    bne     .LOP_INVOKE_DIRECT_RANGE_finish          @ no, continue
-    b       common_exceptionThrown      @ yes, handle exception
+.LOP_INT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
+
+/* continuation for OP_LONG_TO_DOUBLE */
+
+.LOP_LONG_TO_DOUBLE_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
+
+/* continuation for OP_FLOAT_TO_LONG */
+
+.LOP_FLOAT_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vA/vA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 10-11 instructions */
 
 /* continuation for OP_FLOAT_TO_LONG */
 /*
@@ -8915,6 +9833,19 @@ f2l_doconv:
     ldmfd   sp!, {r4, pc}
 
 /* continuation for OP_DOUBLE_TO_LONG */
+
+.LOP_DOUBLE_TO_LONG_finish:
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+    /* 12-13 instructions */
+
+/* continuation for OP_DOUBLE_TO_LONG */
 /*
  * Convert the double in r0/r1 to a long in r0/r1.
  *
@@ -8964,58 +9895,970 @@ d2l_doconv:
     add     sp, sp, #4
     ldmfd   sp!, {r4, r5, pc}
 
+/* continuation for OP_ADD_INT */
+
+.LOP_ADD_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SUB_INT */
+
+.LOP_SUB_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_MUL_INT */
+
+.LOP_MUL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_DIV_INT */
+
+.LOP_DIV_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_REM_INT */
+
+.LOP_REM_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_AND_INT */
+
+.LOP_AND_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_OR_INT */
+
+.LOP_OR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_XOR_INT */
+
+.LOP_XOR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHL_INT */
+
+.LOP_SHL_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_SHR_INT */
+
+.LOP_SHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_USHR_INT */
+
+.LOP_USHR_INT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_LONG */
+
+.LOP_ADD_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG */
+
+.LOP_SUB_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
 /* continuation for OP_MUL_LONG */
 
 .LOP_MUL_LONG_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
-    GOTO_OPCODE(ip)                     @ jump to next instruction
+// begin WITH_TAINT_TRACKING
+//    stmia   r0, {r9-r10}                @ vAA/vAA+1<- r9/r10
+    str		r9, [r0, #0]
+    str		r10, [r0, #8]
+    str		r10, [r0, #12]
+    ldmfd   sp!, {r10}
+    str		r10, [r0, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+mul_long_taint_prop:
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	bx		lr
+
+/* continuation for OP_DIV_LONG */
+
+.LOP_DIV_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG */
+
+.LOP_REM_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG */
+
+.LOP_AND_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG */
+
+.LOP_OR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG */
+
+.LOP_XOR_LONG_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
 
 /* continuation for OP_SHL_LONG */
 
 .LOP_SHL_LONG_finish:
     mov     r0, r0, asl r2              @  r0<- r0 << r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
+
 /* continuation for OP_SHR_LONG */
 
 .LOP_SHR_LONG_finish:
     mov     r1, r1, asr r2              @  r1<- r1 >> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
+
 /* continuation for OP_USHR_LONG */
 
 .LOP_USHR_LONG_finish:
     mov     r1, r1, lsr r2              @  r1<- r1 >>> r2
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+	str		r0, [r9, #0]
+	str		r10, [r9, #4]
+	str		r1, [r9, #8]
+	str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_taint_prop:
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[BB]
+    GET_VREG(r2, r0)                    @ r2<- vCC
+	SET_TAINT_FP(r1)
+	GET_VREG_TAINT(r0, r0, r1)
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+	ldr		r1, [r3, #4]
+	orr		r10, r0, r1
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+    and     r2, r2, #63                 @ r0<- r0 & 0x3f
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    bx		lr
+
+/* continuation for OP_ADD_FLOAT */
+
+.LOP_ADD_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_FLOAT */
+
+.LOP_SUB_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_FLOAT */
+
+.LOP_MUL_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_FLOAT */
+
+.LOP_DIV_FLOAT_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_FLOAT */
+
+.LOP_REM_FLOAT_taint_prop:
+    SET_TAINT_FP(r10)
+    GET_VREG_TAINT(r3, r3, r10)
+    GET_VREG_TAINT(r2, r2, r10)
+    orr		r2, r3, r2
+    SET_VREG_TAINT(r2, r9, r10)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE */
+
+.LOP_ADD_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    faddd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE */
+
+.LOP_SUB_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fsubd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_MUL_DOUBLE */
+
+.LOP_MUL_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fmuld   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_DOUBLE */
+
+.LOP_DIV_DOUBLE_finish:
+    FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+    fdivd   d2, d0, d1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    VREG_INDEX_TO_ADDR(r9, r9)          @ r9<- &vAA
+// begin WITH_TAINT_TRACKING
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE */
+
+.LOP_REM_DOUBLE_taint_prop:
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[AA]
+    stmfd   sp!, {r9}
+    add     r2, rFP, r2, lsl #3         @ r2<- &fp[BB]
+    add     r3, rFP, r3, lsl #3         @ r3<- &fp[CC]
+//    ldmia   r2, {r0-r1}                 @ r0/r1<- vBB/vBB+1
+    ldr		r0, [r2, #0]
+    ldr		r9, [r2, #4]
+    ldr		r1, [r2, #8]
+//    ldmia   r3, {r2-r3}                 @ r2/r3<- vCC/vCC+1
+    ldr		r2, [r3, #0]
+    ldr		r10, [r3, #4]
+    ldr		r3, [r3, #8]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_ADD_INT_2ADDR */
+
+.LOP_ADD_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SUB_INT_2ADDR */
+
+.LOP_SUB_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_MUL_INT_2ADDR */
+
+.LOP_MUL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_DIV_INT_2ADDR */
+
+.LOP_DIV_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_REM_INT_2ADDR */
+
+.LOP_REM_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_AND_INT_2ADDR */
+
+.LOP_AND_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_OR_INT_2ADDR */
+
+.LOP_OR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_XOR_INT_2ADDR */
+
+.LOP_XOR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHL_INT_2ADDR */
+
+.LOP_SHL_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_SHR_INT_2ADDR */
+
+.LOP_SHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_USHR_INT_2ADDR */
+
+.LOP_USHR_INT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_LONG_2ADDR */
+
+.LOP_ADD_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_SUB_LONG_2ADDR */
+
+.LOP_SUB_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_MUL_LONG_2ADDR */
+
+mul_long_2addr_taint_prop:
+    and     r9, r9, #15
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     rINST, rFP, r9, lsl #3      @ rINST<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r9, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   rINST, {r0-r1}              @ r0/r1<- vAA/vAA+1
+    ldr		r0, [rINST, #0]
+    ldr		r10, [rINST, #4]
+    ldr		r1, [rINST, #8]
+	orr		r10, r9, r10
+	stmfd   sp!, {r10}
+	mul     ip, r2, r1                  @  ip<- ZxW
+	bx		lr
+
+/* continuation for OP_DIV_LONG_2ADDR */
+
+.LOP_DIV_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_REM_LONG_2ADDR */
+
+.LOP_REM_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_AND_LONG_2ADDR */
+
+.LOP_AND_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_OR_LONG_2ADDR */
+
+.LOP_OR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
+/* continuation for OP_XOR_LONG_2ADDR */
+
+.LOP_XOR_LONG_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
 /* continuation for OP_SHL_LONG_2ADDR */
 
 .LOP_SHL_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+shl_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
+
 /* continuation for OP_SHR_LONG_2ADDR */
 
 .LOP_SHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+// OP_SHR_LONG_2ADDR.S
+shr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
+
 /* continuation for OP_USHR_LONG_2ADDR */
 
 .LOP_USHR_LONG_2ADDR_finish:
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+// begin WITH_TAINT_TRACKING
+//    stmia   r9, {r0-r1}                 @ vAA/vAA+1<- r0/r1
+    str		r0, [r9, #0]
+    str		r10, [r9, #4]
+    str		r1, [r9, #8]
+    str		r10, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+ushr_long_2addr_taint_prop:
+	SET_TAINT_FP(r0)
+	GET_VREG_TAINT(r0, r3, r0)
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+    and     r2, r2, #63                 @ r2<- r2 & 0x3f
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+	ldr		r10, [r9, #4]
+	orr		r10, r0, r10
+	ldr		r0, [r9, #0]
+	ldr		r1, [r9, #8]
+	bx		lr
+
+/* continuation for OP_ADD_FLOAT_2ADDR */
+
+.LOP_ADD_FLOAT_2ADDR_finish:
+    fadds   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_FLOAT_2ADDR */
+
+.LOP_SUB_FLOAT_2ADDR_finish:
+    fsubs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
+/* continuation for OP_MUL_FLOAT_2ADDR */
+
+.LOP_MUL_FLOAT_2ADDR_finish:
+    fmuls   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_FLOAT_2ADDR */
+
+.LOP_DIV_FLOAT_2ADDR_finish:
+    fdivs   s2, s0, s1                              @ s2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    fsts    s2, [r9]                    @ vAA<- s2
+// begin WITH_TAINT_TRACKING
+	str		r0, [r9, #4]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_FLOAT_2ADDR */
+
+.LOP_REM_FLOAT_2ADDR_taint_prop:
+	SET_TAINT_FP(r2)
+	GET_VREG_TAINT(r3, r3, r2)
+	GET_VREG_TAINT(r10, r9, r2)
+	orr		r10, r3, r10
+	SET_VREG_TAINT(r10, r9, r2)
+	bx		lr
+
+/* continuation for OP_ADD_DOUBLE_2ADDR */
+
+.LOP_ADD_DOUBLE_2ADDR_finish:
+    faddd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_SUB_DOUBLE_2ADDR */
+
+.LOP_SUB_DOUBLE_2ADDR_finish:
+    fsubd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_MUL_DOUBLE_2ADDR */
+
+.LOP_MUL_DOUBLE_2ADDR_finish:
+    fmuld   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_DIV_DOUBLE_2ADDR */
+
+.LOP_DIV_DOUBLE_2ADDR_finish:
+    fdivd   d2, d0, d1                              @ d2<- op
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+// begin WITH_TAINT_TRACKING
+	orr		r0, r0, r1
+//    fstd    d2, [r9]                    @ vAA<- d2
+	fsts	s4, [r9]
+	fsts	s5, [r9, #8]
+	str		r0, [r9, #4]
+	str		r0, [r9, #12]
+// end WITH_TAINT_TRACKING
+    GOTO_OPCODE(ip)                     @ jump to next instruction
+
+/* continuation for OP_REM_DOUBLE_2ADDR */
+
+.LOP_REM_DOUBLE_2ADDR_taint_prop:
+    add     r1, rFP, r1, lsl #3         @ r1<- &fp[B]
+    add     r9, rFP, r9, lsl #3         @ r9<- &fp[A]
+//    ldmia   r1, {r2-r3}                 @ r2/r3<- vBB/vBB+1
+    ldr		r2, [r1, #0]
+    ldr		r10, [r1, #4]
+    ldr		r3, [r1, #8]
+//    ldmia   r9, {r0-r1}                 @ r0/r1<- vAA/vAA+1
+    ldr		r0, [r9, #0]
+    ldr		r1, [r9, #8]
+    stmfd   sp!, {r9}
+    ldr		r9, [r9, #4]
+    orr		r10, r9, r10
+    ldmfd   sp!, {r9}
+	bx		lr
+
 /* continuation for OP_IGET_VOLATILE */
 
     /*
@@ -9214,15 +11057,17 @@ d2l_doconv:
     FETCH(r9, 2)                        @ r9<- FEDC
     add     pc, pc, r0, lsl #3          @ computed goto, 2 instrs each
     bl      common_abort                @ (skipped due to ARM prefetch)
+// begin WITH_TAINT_TRACKING
 4:  and     ip, r9, #0xf000             @ isolate F
-    ldr     r3, [rFP, ip, lsr #10]      @ r3<- vF (shift right 12, left 2)
+    ldr     r3, [rFP, ip, lsr #9]      @ r3<- vF (shift right 12, left 2)
 3:  and     ip, r9, #0x0f00             @ isolate E
-    ldr     r2, [rFP, ip, lsr #6]       @ r2<- vE
+    ldr     r2, [rFP, ip, lsr #5]       @ r2<- vE
 2:  and     ip, r9, #0x00f0             @ isolate D
-    ldr     r1, [rFP, ip, lsr #2]       @ r1<- vD
+    ldr     r1, [rFP, ip, lsr #1]       @ r1<- vD
 1:  and     ip, r9, #0x000f             @ isolate C
-    ldr     r0, [rFP, ip, lsl #2]       @ r0<- vC
+    ldr     r0, [rFP, ip, lsl #3]       @ r0<- vC
 0:
+// end WITH_TAINT_TRACKING
     ldr     r9, .LOP_EXECUTE_INLINE_table       @ table of InlineOperation
     LDR_PC  "[r9, r10, lsl #4]"         @ sizeof=16, "func" is first entry
     @ (not reached)
@@ -9259,6 +11104,47 @@ d2l_doconv:
 .LOP_EXECUTE_INLINE_RANGE_table:
     .word   gDvmInlineOpsTable
 
+/* continuation for OP_IGET_QUICK */
+
+.LOP_IGET_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IGET_WIDE_QUICK */
+
+iget_wide_quick_taint_prop:
+    add     r3, rFP, r2, lsl #3         @ r3<- &fp[A]
+    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+//    stmia   r3, {r0-r1}                 @ fp[A]<- r0/r1
+	str		r0, [r3, #0]
+	str		r10, [r3, #4]
+	str		r1, [r3, #8]
+	str		r10, [r3, #12]
+	bx		lr
+
+/* continuation for OP_IGET_OBJECT_QUICK */
+
+.LOP_IGET_OBJECT_QUICK_taint_prop:
+	add		r1, r1, #4
+	ldr		r10, [r3, r1]
+	orr		r10, r9, r10
+	FETCH_ADVANCE_INST(2)               @ advance rPC, load rINST
+	bx		lr
+
+/* continuation for OP_IPUT_WIDE_QUICK */
+
+iput_wide_quick_taint_prop:
+    add     r3, rFP, r0, lsl #3         @ r3<- &fp[A]
+    cmp     r2, #0                      @ check object for null
+//    ldmia   r3, {r0-r1}                 @ r0/r1<- fp[A]
+	ldr		r0, [r3, #0]
+	ldr		r1, [r3, #8]
+	ldr		r9, [r3, #4]
+	bx		lr
+
 /* continuation for OP_IPUT_OBJECT_VOLATILE */
 
     /*
@@ -9316,7 +11202,7 @@ d2l_doconv:
     .global dvmAsmSisterEnd
 dvmAsmSisterEnd:
 
-/* File: armv5te/footer.S */
+/* File: armv5te_taint/footer.S */
 
 /*
  * ===========================================================================
@@ -9330,76 +11216,6 @@ dvmAsmSisterEnd:
     .align  2
 
 #if defined(WITH_JIT)
-#if defined(WITH_SELF_VERIFICATION)
-    .global dvmJitToInterpPunt
-dvmJitToInterpPunt:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r2,#kSVSPunt                 @ r2<- interpreter entry point
-    mov    r3, #0
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpSingleStep
-dvmJitToInterpSingleStep:
-    str    lr,[rGLUE,#offGlue_jitResumeNPC]
-    str    r1,[rGLUE,#offGlue_jitResumeDPC]
-    mov    r2,#kSVSSingleStep           @ r2<- interpreter entry point
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpNoChainNoProfile
-dvmJitToInterpNoChainNoProfile:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r0,rPC                       @ pass our target PC
-    mov    r2,#kSVSNoProfile            @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpTraceSelectNoChain
-dvmJitToInterpTraceSelectNoChain:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r0,rPC                       @ pass our target PC
-    mov    r2,#kSVSTraceSelect          @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpTraceSelect
-dvmJitToInterpTraceSelect:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    ldr    r0,[lr, #-1]                 @ pass our target PC
-    mov    r2,#kSVSTraceSelect          @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpBackwardBranch
-dvmJitToInterpBackwardBranch:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    ldr    r0,[lr, #-1]                 @ pass our target PC
-    mov    r2,#kSVSBackwardBranch       @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpNormal
-dvmJitToInterpNormal:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    ldr    r0,[lr, #-1]                 @ pass our target PC
-    mov    r2,#kSVSNormal               @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-
-    .global dvmJitToInterpNoChain
-dvmJitToInterpNoChain:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r0,rPC                       @ pass our target PC
-    mov    r2,#kSVSNoChain              @ r2<- interpreter entry point
-    mov    r3, #0                       @ 0 means !inJitCodeCache
-    str    r3, [r10, #offThread_inJitCodeCache] @ Back to the interp land
-    b      jitSVShadowRunEnd            @ doesn't return
-#else
 /*
  * Return from the translation cache to the interpreter when the compiler is
  * having issues translating/executing a Dalvik instruction. We have to skip
@@ -9409,15 +11225,12 @@ dvmJitToInterpNoChain:
  */
     .global dvmJitToInterpPunt
 dvmJitToInterpPunt:
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
     mov    rPC, r0
-#if defined(WITH_JIT_TUNING)
+#ifdef EXIT_STATS
     mov    r0,lr
     bl     dvmBumpPunt;
 #endif
     EXPORT_PC()
-    mov    r0, #0
-    str    r0, [r10, #offThread_inJitCodeCache] @ Back to the interp land
     adrl   rIBASE, dvmAsmInstructionStart
     FETCH_INST()
     GET_INST_OPCODE(ip)
@@ -9432,59 +11245,35 @@ dvmJitToInterpPunt:
  */
     .global dvmJitToInterpSingleStep
 dvmJitToInterpSingleStep:
-    str    lr,[rGLUE,#offGlue_jitResumeNPC]
-    str    r1,[rGLUE,#offGlue_jitResumeDPC]
+    str    lr,[rGLUE,#offGlue_jitResume]
+    str    r1,[rGLUE,#offGlue_jitResumePC]
     mov    r1,#kInterpEntryInstr
     @ enum is 4 byte in aapcs-EABI
     str    r1, [rGLUE, #offGlue_entryPoint]
     mov    rPC,r0
     EXPORT_PC()
-
     adrl   rIBASE, dvmAsmInstructionStart
     mov    r2,#kJitSingleStep     @ Ask for single step and then revert
     str    r2,[rGLUE,#offGlue_jitState]
     mov    r1,#1                  @ set changeInterp to bail to debug interp
     b      common_gotoBail
 
-/*
- * Return from the translation cache and immediately request
- * a translation for the exit target.  Commonly used for callees.
- */
-    .global dvmJitToInterpTraceSelectNoChain
-dvmJitToInterpTraceSelectNoChain:
-#if defined(WITH_JIT_TUNING)
-    bl     dvmBumpNoChain
-#endif
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r0,rPC
-    bl     dvmJitGetCodeAddr        @ Is there a translation?
-    str    r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
-    mov    r1, rPC                  @ arg1 of translation may need this
-    mov    lr, #0                   @  in case target is HANDLER_INTERPRET
-    cmp    r0,#0                    @ !0 means translation exists
-    bxne   r0                       @ continue native execution if so
-    b      2f                       @ branch over to use the interpreter
 
 /*
  * Return from the translation cache and immediately request
  * a translation for the exit target.  Commonly used following
  * invokes.
  */
-    .global dvmJitToInterpTraceSelect
-dvmJitToInterpTraceSelect:
-    ldr    rPC,[lr, #-1]           @ get our target PC
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    add    rINST,lr,#-5            @ save start of chain branch
-    add    rINST, #-4              @  .. which is 9 bytes back
+    .global dvmJitToTraceSelect
+dvmJitToTraceSelect:
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
     mov    r0,rPC
-    bl     dvmJitGetCodeAddr       @ Is there a translation?
-    str    r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
+    bl     dvmJitGetCodeAddr        @ Is there a translation?
     cmp    r0,#0
     beq    2f
     mov    r1,rINST
     bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
-    mov    r1, rPC                  @ arg1 of translation may need this
-    mov    lr, #0                   @ in case target is HANDLER_INTERPRET
     cmp    r0,#0                    @ successful chain?
     bxne   r0                       @ continue native execution
     b      toInterpreter            @ didn't chain - resume with interpreter
@@ -9495,7 +11284,6 @@ dvmJitToInterpTraceSelect:
     GET_JIT_PROF_TABLE(r0)
     FETCH_INST()
     cmp    r0, #0
-    movne  r2,#kJitTSelectRequestHot   @ ask for trace selection
     bne    common_selectTrace
     GET_INST_OPCODE(ip)
     GOTO_OPCODE(ip)
@@ -9516,22 +11304,17 @@ dvmJitToInterpTraceSelect:
  */
     .global dvmJitToInterpNormal
 dvmJitToInterpNormal:
-    ldr    rPC,[lr, #-1]           @ get our target PC
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    add    rINST,lr,#-5            @ save start of chain branch
-    add    rINST,#-4               @ .. which is 9 bytes back
-#if defined(WITH_JIT_TUNING)
+    ldr    rPC,[r14, #-1]           @ get our target PC
+    add    rINST,r14,#-5            @ save start of chain branch
+#ifdef EXIT_STATS
     bl     dvmBumpNormal
 #endif
     mov    r0,rPC
     bl     dvmJitGetCodeAddr        @ Is there a translation?
-    str    r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
     cmp    r0,#0
     beq    toInterpreter            @ go if not, otherwise do chain
     mov    r1,rINST
     bl     dvmJitChain              @ r0<- dvmJitChain(codeAddr,chainAddr)
-    mov    r1, rPC                  @ arg1 of translation may need this
-    mov    lr, #0                   @  in case target is HANDLER_INTERPRET
     cmp    r0,#0                    @ successful chain?
     bxne   r0                       @ continue native execution
     b      toInterpreter            @ didn't chain - resume with interpreter
@@ -9540,43 +11323,15 @@ dvmJitToInterpNormal:
  * Return from the translation cache to the interpreter to do method invocation.
  * Check if translation exists for the callee, but don't chain to it.
  */
-    .global dvmJitToInterpNoChainNoProfile
-dvmJitToInterpNoChainNoProfile:
-#if defined(WITH_JIT_TUNING)
-    bl     dvmBumpNoChain
-#endif
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
-    mov    r0,rPC
-    bl     dvmJitGetCodeAddr        @ Is there a translation?
-    str    r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
-    mov    r1, rPC                  @ arg1 of translation may need this
-    mov    lr, #0                   @  in case target is HANDLER_INTERPRET
-    cmp    r0,#0
-    bxne   r0                       @ continue native execution if so
-    EXPORT_PC()
-    adrl   rIBASE, dvmAsmInstructionStart
-    FETCH_INST()
-    GET_INST_OPCODE(ip)                 @ extract opcode from rINST
-    GOTO_OPCODE(ip)                     @ jump to next instruction
-
-/*
- * Return from the translation cache to the interpreter to do method invocation.
- * Check if translation exists for the callee, but don't chain to it.
- */
     .global dvmJitToInterpNoChain
 dvmJitToInterpNoChain:
-#if defined(WITH_JIT_TUNING)
+#ifdef EXIT_STATS
     bl     dvmBumpNoChain
 #endif
-    ldr    r10, [rGLUE, #offGlue_self]  @ callee saved r10 <- glue->self
     mov    r0,rPC
     bl     dvmJitGetCodeAddr        @ Is there a translation?
-    str    r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
-    mov    r1, rPC                  @ arg1 of translation may need this
-    mov    lr, #0                   @  in case target is HANDLER_INTERPRET
     cmp    r0,#0
     bxne   r0                       @ continue native execution if so
-#endif
 
 /*
  * No translation, restore interpreter regs and start interpreting.
@@ -9590,7 +11345,6 @@ toInterpreter:
     FETCH_INST()
     GET_JIT_PROF_TABLE(r0)
     @ NOTE: intended fallthrough
-
 /*
  * Common code to update potential trace start counter, and initiate
  * a trace-build if appropriate.  On entry, rPC should point to the
@@ -9605,11 +11359,11 @@ common_testUpdateProfile:
 
 common_updateProfile:
     eor     r3,rPC,rPC,lsr #12 @ cheap, but fast hash function
-    lsl     r3,r3,#(32 - JIT_PROF_SIZE_LOG_2)          @ shift out excess bits
-    ldrb    r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ get counter
+    lsl     r3,r3,#23          @ shift out excess 511
+    ldrb    r1,[r0,r3,lsr #23] @ get counter
     GET_INST_OPCODE(ip)
     subs    r1,r1,#1           @ decrement counter
-    strb    r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ and store it
+    strb    r1,[r0,r3,lsr #23] @ and store it
     GOTO_OPCODE_IFNE(ip)       @ if not threshold, fallthrough otherwise */
 
 /*
@@ -9618,108 +11372,25 @@ common_updateProfile:
  * is already a native translation in place (and, if so,
  * jump to it now).
  */
-    GET_JIT_THRESHOLD(r1)
-    ldr     r10, [rGLUE, #offGlue_self] @ callee saved r10 <- glue->self
-    strb    r1,[r0,r3,lsr #(32 - JIT_PROF_SIZE_LOG_2)] @ reset counter
+    mov     r1,#255
+    strb    r1,[r0,r3,lsr #23] @ reset counter
     EXPORT_PC()
     mov     r0,rPC
     bl      dvmJitGetCodeAddr           @ r0<- dvmJitGetCodeAddr(rPC)
-    str     r0, [r10, #offThread_inJitCodeCache] @ set the inJitCodeCache flag
-    mov     r1, rPC                     @ arg1 of translation may need this
-    mov     lr, #0                      @  in case target is HANDLER_INTERPRET
     cmp     r0,#0
-#if !defined(WITH_SELF_VERIFICATION)
-    bxne    r0                          @ jump to the translation
-    mov     r2,#kJitTSelectRequest      @ ask for trace selection
-    @ fall-through to common_selectTrace
-#else
-    moveq   r2,#kJitTSelectRequest      @ ask for trace selection
     beq     common_selectTrace
-    /*
-     * At this point, we have a target translation.  However, if
-     * that translation is actually the interpret-only pseudo-translation
-     * we want to treat it the same as no translation.
-     */
-    mov     r10, r0                     @ save target
-    bl      dvmCompilerGetInterpretTemplate
-    cmp     r0, r10                     @ special case?
-    bne     jitSVShadowRunStart         @ set up self verification shadow space
-    @ Need to clear the inJitCodeCache flag
-    ldr    r10, [rGLUE, #offGlue_self]  @ r10 <- glue->self
-    mov    r3, #0                       @ 0 means not in the JIT code cache
-    str    r3, [r10, #offThread_inJitCodeCache] @ back to the interp land
-    GET_INST_OPCODE(ip)
-    GOTO_OPCODE(ip)
-    /* no return */
-#endif
-
-/*
- * On entry:
- *  r2 is jit state, e.g. kJitTSelectRequest or kJitTSelectRequestHot
- */
+    bxne    r0                          @ jump to the translation
 common_selectTrace:
+    mov     r2,#kJitTSelectRequest      @ ask for trace selection
     str     r2,[rGLUE,#offGlue_jitState]
-    mov     r2,#kInterpEntryInstr       @ normal entry reason
-    str     r2,[rGLUE,#offGlue_entryPoint]
     mov     r1,#1                       @ set changeInterp
     b       common_gotoBail
 
-#if defined(WITH_SELF_VERIFICATION)
-/*
- * Save PC and registers to shadow memory for self verification mode
- * before jumping to native translation.
- * On entry:
- *    rPC, rFP, rGLUE: the values that they should contain
- *    r10: the address of the target translation.
- */
-jitSVShadowRunStart:
-    mov     r0,rPC                      @ r0<- program counter
-    mov     r1,rFP                      @ r1<- frame pointer
-    mov     r2,rGLUE                    @ r2<- InterpState pointer
-    mov     r3,r10                      @ r3<- target translation
-    bl      dvmSelfVerificationSaveState @ save registers to shadow space
-    ldr     rFP,[r0,#offShadowSpace_shadowFP] @ rFP<- fp in shadow space
-    add     rGLUE,r0,#offShadowSpace_interpState @ rGLUE<- rGLUE in shadow space
-    bx      r10                         @ jump to the translation
-
-/*
- * Restore PC, registers, and interpState to original values
- * before jumping back to the interpreter.
- */
-jitSVShadowRunEnd:
-    mov    r1,rFP                        @ pass ending fp
-    bl     dvmSelfVerificationRestoreState @ restore pc and fp values
-    ldr    rPC,[r0,#offShadowSpace_startPC] @ restore PC
-    ldr    rFP,[r0,#offShadowSpace_fp]   @ restore FP
-    ldr    rGLUE,[r0,#offShadowSpace_glue] @ restore InterpState
-    ldr    r1,[r0,#offShadowSpace_svState] @ get self verification state
-    cmp    r1,#0                         @ check for punt condition
-    beq    1f
-    mov    r2,#kJitSelfVerification      @ ask for self verification
-    str    r2,[rGLUE,#offGlue_jitState]
-    mov    r2,#kInterpEntryInstr         @ normal entry reason
-    str    r2,[rGLUE,#offGlue_entryPoint]
-    mov    r1,#1                         @ set changeInterp
-    b      common_gotoBail
-
-1:                                       @ exit to interpreter without check
-    EXPORT_PC()
-    adrl   rIBASE, dvmAsmInstructionStart
-    FETCH_INST()
-    GET_INST_OPCODE(ip)
-    GOTO_OPCODE(ip)
-#endif
-
 #endif
 
 /*
  * Common code when a backward branch is taken.
  *
- * TODO: we could avoid a branch by just setting r0 and falling through
- * into the common_periodicChecks code, and having a test on r0 at the
- * end determine if we should return to the caller or update & branch to
- * the next instr.
- *
  * On entry:
  *  r9 is PC adjustment *in bytes*
  */
@@ -9742,91 +11413,63 @@ common_backwardBranch:
 
 /*
  * Need to see if the thread needs to be suspended or debugger/profiler
- * activity has begun.  If so, we suspend the thread or side-exit to
- * the debug interpreter as appropriate.
- *
- * The common case is no activity on any of these, so we want to figure
- * that out quickly.  If something is up, we can then sort out what.
+ * activity has begun.
  *
- * We want to be fast if the VM was built without debugger or profiler
- * support, but we also need to recognize that the system is usually
- * shipped with both of these enabled.
+ * TODO: if JDWP isn't running, zero out pDebuggerActive pointer so we don't
+ * have to do the second ldr.
  *
  * TODO: reduce this so we're just checking a single location.
  *
  * On entry:
- *  r0 is reentry type, e.g. kInterpEntryInstr (for debugger/profiling)
+ *  r0 is reentry type, e.g. kInterpEntryInstr
  *  r9 is trampoline PC adjustment *in bytes*
  */
 common_periodicChecks:
     ldr     r3, [rGLUE, #offGlue_pSelfSuspendCount] @ r3<- &suspendCount
 
+#if defined(WITH_DEBUGGER)
     ldr     r1, [rGLUE, #offGlue_pDebuggerActive]   @ r1<- &debuggerActive
+#endif
+#if defined(WITH_PROFILER)
     ldr     r2, [rGLUE, #offGlue_pActiveProfilers]  @ r2<- &activeProfilers
+#endif
 
-    ldr     ip, [r3]                    @ ip<- suspendCount (int)
+    ldr     r3, [r3]                    @ r3<- suspendCount (int)
 
-    cmp     r1, #0                      @ debugger enabled?
-    ldrneb  r1, [r1]                    @ yes, r1<- debuggerActive (boolean)
+#if defined(WITH_DEBUGGER)
+    ldrb    r1, [r1]                    @ r1<- debuggerActive (boolean)
+#endif
+#if defined (WITH_PROFILER)
     ldr     r2, [r2]                    @ r2<- activeProfilers (int)
-    orrne   ip, ip, r1                  @ ip<- suspendCount | debuggerActive
-    orrs    ip, ip, r2                  @ ip<- suspend|debugger|profiler; set Z
+#endif
 
-    bxeq    lr                          @ all zero, return
+    cmp     r3, #0                      @ suspend pending?
+    bne     2f                          @ yes, do full suspension check
+
+#if defined(WITH_DEBUGGER) || defined(WITH_PROFILER)
+# if defined(WITH_DEBUGGER) && defined(WITH_PROFILER)
+    orrs    r1, r1, r2                  @ r1<- r1 | r2
+    cmp     r1, #0                      @ debugger attached or profiler started?
+# elif defined(WITH_DEBUGGER)
+    cmp     r1, #0                      @ debugger attached?
+# elif defined(WITH_PROFILER)
+    cmp     r2, #0                      @ profiler started?
+# endif
+    bne     3f                          @ debugger/profiler, switch interp
+#endif
 
-    /*
-     * One or more interesting events have happened.  Figure out what.
-     *
-     * If debugging or profiling are compiled in, we need to disambiguate.
-     *
-     * r0 still holds the reentry type.
-     */
-    ldr     ip, [r3]                    @ ip<- suspendCount (int)
-    cmp     ip, #0                      @ want suspend?
-    beq     1f                          @ no, must be debugger/profiler
+    bx      lr                          @ nothing to do, return
 
-    stmfd   sp!, {r0, lr}               @ preserve r0 and lr
-#if defined(WITH_JIT)
-    /*
-     * Refresh the Jit's cached copy of profile table pointer.  This pointer
-     * doubles as the Jit's on/off switch.
-     */
-    ldr     r3, [rGLUE, #offGlue_ppJitProfTable] @ r3<-&gDvmJit.pJitProfTable
-    ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
-    ldr     r3, [r3] @ r3 <- pJitProfTable
-    EXPORT_PC()                         @ need for precise GC
-    str     r3, [rGLUE, #offGlue_pJitProfTable] @ refresh Jit's on/off switch
-#else
+2:  @ check suspend
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- glue->self
     EXPORT_PC()                         @ need for precise GC
-#endif
-    bl      dvmCheckSuspendPending      @ do full check, suspend if necessary
-    ldmfd   sp!, {r0, lr}               @ restore r0 and lr
-
-    /*
-     * Reload the debugger/profiler enable flags.  We're checking to see
-     * if either of these got set while we were suspended.
-     *
-     * We can't really avoid the #ifdefs here, because the fields don't
-     * exist when the feature is disabled.
-     */
-    ldr     r1, [rGLUE, #offGlue_pDebuggerActive]   @ r1<- &debuggerActive
-    cmp     r1, #0                      @ debugger enabled?
-    ldrneb  r1, [r1]                    @ yes, r1<- debuggerActive (boolean)
-    ldr     r2, [rGLUE, #offGlue_pActiveProfilers]  @ r2<- &activeProfilers
-    ldr     r2, [r2]                    @ r2<- activeProfilers (int)
+    b       dvmCheckSuspendPending      @ suspend if necessary, then return
 
-    orrs    r1, r1, r2
-    beq     2f
-
-1:  @ debugger/profiler enabled, bail out; glue->entryPoint was set above
-    str     r0, [rGLUE, #offGlue_entryPoint]    @ store r0, need for debug/prof
+3:  @ debugger/profiler enabled, bail out
     add     rPC, rPC, r9                @ update rPC
+    str     r0, [rGLUE, #offGlue_entryPoint]
     mov     r1, #1                      @ "want switch" = true
-    b       common_gotoBail             @ side exit
-
-2:
-    bx      lr                          @ nothing to do, return
+    b       common_gotoBail
 
 
 /*
@@ -9930,7 +11573,7 @@ common_invokeMethodNoRange:
     sub     r3, r10, r3, lsl #2         @ r3<- bottom (newsave - outsSize)
     cmp     r3, r9                      @ bottom < interpStackEnd?
     ldr     r3, [r0, #offMethod_accessFlags] @ r3<- methodToCall->accessFlags
-    blo     .LstackOverflow             @ yes, this frame will overflow stack
+    blt     .LstackOverflow             @ yes, this frame will overflow stack
 
     @ set up newSaveArea
 #ifdef EASY_GDB
@@ -10016,31 +11659,20 @@ dalvik_mterp:
     @ldr     pc, [r2, #offMethod_nativeFunc] @ pc<- methodToCall->nativeFunc
     LDR_PC_LR "[r2, #offMethod_nativeFunc]"
 
-#if defined(WITH_JIT)
-    ldr     r3, [rGLUE, #offGlue_ppJitProfTable] @ Refresh Jit's on/off status
-#endif
-
     @ native return; r9=self, r10=newSaveArea
     @ equivalent to dvmPopJniLocals
     ldr     r0, [r10, #offStackSaveArea_localRefCookie] @ r0<- saved top
     ldr     r1, [r9, #offThread_exception] @ check for exception
-#if defined(WITH_JIT)
-    ldr     r3, [r3]                    @ r3 <- gDvmJit.pProfTable
-#endif
     str     rFP, [r9, #offThread_curFrame]  @ self->curFrame = fp
     cmp     r1, #0                      @ null?
     str     r0, [r9, #offThread_jniLocal_topCookie] @ new top <- old top
-#if defined(WITH_JIT)
-    str     r3, [rGLUE, #offGlue_pJitProfTable] @ refresh cached on/off switch
-#endif
     bne     common_exceptionThrown      @ no, handle exception
 
     FETCH_ADVANCE_INST(3)               @ advance rPC, load rINST
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
     GOTO_OPCODE(ip)                     @ jump to next instruction
 
-.LstackOverflow:    @ r0=methodToCall
-    mov     r1, r0                      @ r1<- methodToCall
+.LstackOverflow:
     ldr     r0, [rGLUE, #offGlue_self]  @ r0<- self
     bl      dvmHandleStackOverflow
     b       common_exceptionThrown
@@ -10104,13 +11736,15 @@ common_returnFromMethod:
     ldr     r1, [r10, #offClassObject_pDvmDex]   @ r1<- method->clazz->pDvmDex
     str     rFP, [r3, #offThread_curFrame]  @ self->curFrame = fp
 #if defined(WITH_JIT)
-    ldr     r10, [r0, #offStackSaveArea_returnAddr] @ r10 = saveArea->returnAddr
+    ldr     r3, [r0, #offStackSaveArea_returnAddr] @ r3 = saveArea->returnAddr
+    GET_JIT_PROF_TABLE(r0)
     mov     rPC, r9                     @ publish new rPC
     str     r1, [rGLUE, #offGlue_methodClassDex]
-    str     r10, [r3, #offThread_inJitCodeCache]  @ may return to JIT'ed land
-    cmp     r10, #0                      @ caller is compiled code
-    blxne   r10
+    cmp     r3, #0                      @ caller is compiled code
+    blxne   r3
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
+    cmp     r0,#0
+    bne     common_updateProfile
     GOTO_OPCODE(ip)                     @ jump to next instruction
 #else
     GET_INST_OPCODE(ip)                 @ extract opcode from rINST
@@ -10148,6 +11782,11 @@ common_exceptionThrown:
     mov     r9, #0
     bl      common_periodicChecks
 
+#if defined(WITH_JIT)
+    mov     r2,#kJitTSelectAbort        @ abandon trace selection in progress
+    str     r2,[rGLUE,#offGlue_jitState]
+#endif
+
     ldr     r10, [rGLUE, #offGlue_self] @ r10<- glue->self
     ldr     r9, [r10, #offThread_exception] @ r9<- self->exception
     mov     r1, r10                     @ r1<- self
@@ -10178,7 +11817,6 @@ common_exceptionThrown:
     beq     1f                          @ no, skip ahead
     mov     rFP, r0                     @ save relPc result in rFP
     mov     r0, r10                     @ r0<- self
-    mov     r1, r9                      @ r1<- exception
     bl      dvmCleanupStackOverflow     @ call(self)
     mov     r0, rFP                     @ restore result
 1:
@@ -10216,7 +11854,6 @@ common_exceptionThrown:
     ldrb    r1, [r10, #offThread_stackOverflowed]
     cmp     r1, #0                      @ did we overflow earlier?
     movne   r0, r10                     @ if yes: r0<- self
-    movne   r1, r9                      @ if yes: r1<- exception
     blne    dvmCleanupStackOverflow     @ if yes: call(self)
 
     @ may want to show "not caught locally" debug messages here
diff --git a/vm/mterp/out/InterpC-allstubs.c b/vm/mterp/out/InterpC-allstubs.c
index ce6192c..4f6d18a 100644
--- a/vm/mterp/out/InterpC-allstubs.c
+++ b/vm/mterp/out/InterpC-allstubs.c
@@ -161,6 +161,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -180,6 +205,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -197,6 +236,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -216,6 +269,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -233,6 +300,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -241,6 +322,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -284,6 +414,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -449,6 +621,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1168,6 +1449,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1192,6 +1476,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1208,6 +1496,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1219,6 +1510,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1230,6 +1524,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1242,6 +1539,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1252,6 +1552,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1262,6 +1565,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1274,6 +1580,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1287,6 +1596,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1300,6 +1612,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1311,6 +1626,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1319,6 +1637,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1330,6 +1651,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1340,6 +1664,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1350,6 +1677,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1359,6 +1689,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1367,6 +1700,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1377,6 +1713,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1390,6 +1729,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1400,6 +1742,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1413,6 +1758,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1423,6 +1771,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1432,6 +1783,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1445,6 +1799,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1461,6 +1818,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1471,6 +1831,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1490,6 +1853,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1512,6 +1878,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1532,6 +1901,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1651,6 +2023,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -1669,6 +2044,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1716,6 +2094,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1753,6 +2134,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2097,6 +2481,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         dvmSetObjectArrayElement(arrayObj,
                                  GET_REGISTER(vsrc2),
                                  (Object *)GET_REGISTER(vdst));
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2505,6 +2894,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2536,6 +2929,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2651,6 +3048,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2677,6 +3078,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2692,6 +3097,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2734,6 +3142,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3227,6 +3638,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -3904,6 +4318,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3914,8 +4331,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -3934,9 +4374,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3951,6 +4438,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -3972,13 +4460,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
@@ -4001,8 +4499,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -4073,6 +4578,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG)
             if (gDvm.debuggerActive) {
@@ -4130,3 +4644,6 @@ GOTO_TARGET_END
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
diff --git a/vm/mterp/out/InterpC-armv7-a.c b/vm/mterp/out/InterpC-armv7-a.c
index d40fd7c..153f6cf 100644
--- a/vm/mterp/out/InterpC-armv7-a.c
+++ b/vm/mterp/out/InterpC-armv7-a.c
@@ -161,6 +161,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -180,6 +205,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -197,6 +236,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -216,6 +269,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -233,6 +300,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -241,6 +322,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -284,6 +414,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -449,6 +621,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1168,6 +1449,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1192,9 +1476,1180 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
+/* File: c/OP_INVOKE_VIRTUAL.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeVirtual, false);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeSuper, false);
+OP_END
+
+/* File: c/OP_INVOKE_DIRECT.c */
+HANDLE_OPCODE(OP_INVOKE_DIRECT /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeDirect, false);
+OP_END
+
+/* File: c/OP_INVOKE_STATIC.c */
+HANDLE_OPCODE(OP_INVOKE_STATIC /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeStatic, false);
+OP_END
+
+/* File: c/OP_INVOKE_INTERFACE.c */
+HANDLE_OPCODE(OP_INVOKE_INTERFACE /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeInterface, false);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeVirtual, true);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeSuper, true);
+OP_END
+
+/* File: c/OP_INVOKE_DIRECT_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_DIRECT_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeDirect, true);
+OP_END
+
+/* File: c/OP_INVOKE_STATIC_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_STATIC_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeStatic, true);
+OP_END
+
+/* File: c/OP_INVOKE_INTERFACE_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_INTERFACE_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeInterface, true);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_QUICK.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_QUICK /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeVirtualQuick, false);
+OP_END
+
+/* File: c/OP_INVOKE_VIRTUAL_QUICK_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_VIRTUAL_QUICK_RANGE/*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeVirtualQuick, true);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_QUICK.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_QUICK /*vB, {vD, vE, vF, vG, vA}, meth@CCCC*/)
+    GOTO_invoke(invokeSuperQuick, false);
+OP_END
+
+/* File: c/OP_INVOKE_SUPER_QUICK_RANGE.c */
+HANDLE_OPCODE(OP_INVOKE_SUPER_QUICK_RANGE /*{vCCCC..v(CCCC+AA-1)}, meth@BBBB*/)
+    GOTO_invoke(invokeSuperQuick, true);
+OP_END
+
+/* File: c/gotoTargets.c */
+/*
+ * C footer.  This has some common code shared by the various targets.
+ */
+
+/*
+ * Everything from here on is a "goto target".  In the basic interpreter
+ * we jump into these targets and then jump directly to the handler for
+ * next instruction.  Here, these are subroutines that return to the caller.
+ */
+
+GOTO_TARGET(filledNewArray, bool methodCallRange)
+    {
+        ClassObject* arrayClass;
+        ArrayObject* newArray;
+        u4* contents;
+        char typeCh;
+        int i;
+        u4 arg5;
+
+        EXPORT_PC();
+
+        ref = FETCH(1);             /* class ref */
+        vdst = FETCH(2);            /* first 4 regs -or- range base */
+
+        if (methodCallRange) {
+            vsrc1 = INST_AA(inst);  /* #of elements */
+            arg5 = -1;              /* silence compiler warning */
+            ILOGV("|filled-new-array-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+        } else {
+            arg5 = INST_A(inst);
+            vsrc1 = INST_B(inst);   /* #of elements */
+            ILOGV("|filled-new-array args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1, ref, vdst, arg5);
+        }
+
+        /*
+         * Resolve the array class.
+         */
+        arrayClass = dvmDexGetResolvedClass(methodClassDex, ref);
+        if (arrayClass == NULL) {
+            arrayClass = dvmResolveClass(curMethod->clazz, ref, false);
+            if (arrayClass == NULL)
+                GOTO_exceptionThrown();
+        }
+        /*
+        if (!dvmIsArrayClass(arrayClass)) {
+            dvmThrowException("Ljava/lang/RuntimeError;",
+                "filled-new-array needs array class");
+            GOTO_exceptionThrown();
+        }
+        */
+        /* verifier guarantees this is an array class */
+        assert(dvmIsArrayClass(arrayClass));
+        assert(dvmIsClassInitialized(arrayClass));
+
+        /*
+         * Create an array of the specified type.
+         */
+        LOGVV("+++ filled-new-array type is '%s'\n", arrayClass->descriptor);
+        typeCh = arrayClass->descriptor[1];
+        if (typeCh == 'D' || typeCh == 'J') {
+            /* category 2 primitives not allowed */
+            dvmThrowException("Ljava/lang/RuntimeError;",
+                "bad filled array req");
+            GOTO_exceptionThrown();
+        } else if (typeCh != 'L' && typeCh != '[' && typeCh != 'I') {
+            /* TODO: requires multiple "fill in" loops with different widths */
+            LOGE("non-int primitives not implemented\n");
+            dvmThrowException("Ljava/lang/InternalError;",
+                "filled-new-array not implemented for anything but 'int'");
+            GOTO_exceptionThrown();
+        }
+
+        newArray = dvmAllocArrayByClass(arrayClass, vsrc1, ALLOC_DONT_TRACK);
+        if (newArray == NULL)
+            GOTO_exceptionThrown();
+
+        /*
+         * Fill in the elements.  It's legal for vsrc1 to be zero.
+         */
+        contents = (u4*) newArray->contents;
+        if (methodCallRange) {
+            for (i = 0; i < vsrc1; i++)
+                contents[i] = GET_REGISTER(vdst+i);
+        } else {
+            assert(vsrc1 <= 5);
+            if (vsrc1 == 5) {
+                contents[4] = GET_REGISTER(arg5);
+                vsrc1--;
+            }
+            for (i = 0; i < vsrc1; i++) {
+                contents[i] = GET_REGISTER(vdst & 0x0f);
+                vdst >>= 4;
+            }
+        }
+        if (typeCh == 'L' || typeCh == '[') {
+            dvmWriteBarrierArray(newArray, 0, newArray->length);
+        }
+
+        retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
+    }
+    FINISH(3);
+GOTO_TARGET_END
+
+
+GOTO_TARGET(invokeVirtual, bool methodCallRange)
+    {
+        Method* baseMethod;
+        Object* thisPtr;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-virtual-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-virtual args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+        /*
+         * Resolve the method.  This is the correct method for the static
+         * type of the object.  We also verify access permissions here.
+         */
+        baseMethod = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (baseMethod == NULL) {
+            baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
+            if (baseMethod == NULL) {
+                ILOGV("+ unknown method or access denied\n");
+                GOTO_exceptionThrown();
+            }
+        }
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method.
+         */
+        assert(baseMethod->methodIndex < thisPtr->clazz->vtableCount);
+        methodToCall = thisPtr->clazz->vtable[baseMethod->methodIndex];
+
+#if defined(WITH_JIT) && (INTERP_TYPE == INTERP_DBG)
+        callsiteClass = thisPtr->clazz;
+#endif
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            /*
+             * This can happen if you create two classes, Base and Sub, where
+             * Sub is a sub-class of Base.  Declare a protected abstract
+             * method foo() in Base, and invoke foo() from a method in Base.
+             * Base is an "abstract base class" and is never instantiated
+             * directly.  Now, Override foo() in Sub, and use Sub.  This
+             * Works fine unless Sub stops providing an implementation of
+             * the method.
+             */
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+
+        LOGVV("+++ base=%s.%s virtual[%d]=%s.%s\n",
+            baseMethod->clazz->descriptor, baseMethod->name,
+            (u4) baseMethod->methodIndex,
+            methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+#if 0
+        if (vsrc1 != methodToCall->insSize) {
+            LOGW("WRONG METHOD: base=%s.%s virtual[%d]=%s.%s\n",
+                baseMethod->clazz->descriptor, baseMethod->name,
+                (u4) baseMethod->methodIndex,
+                methodToCall->clazz->descriptor, methodToCall->name);
+            //dvmDumpClass(baseMethod->clazz);
+            //dvmDumpClass(methodToCall->clazz);
+            dvmDumpAllClasses(0);
+        }
+#endif
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeSuper, bool methodCallRange)
+    {
+        Method* baseMethod;
+        u2 thisReg;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        if (methodCallRange) {
+            ILOGV("|invoke-super-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-super args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        /* impossible in well-formed code, but we must check nevertheless */
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+        /*
+         * Resolve the method.  This is the correct method for the static
+         * type of the object.  We also verify access permissions here.
+         * The first arg to dvmResolveMethod() is just the referring class
+         * (used for class loaders and such), so we don't want to pass
+         * the superclass into the resolution call.
+         */
+        baseMethod = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (baseMethod == NULL) {
+            baseMethod = dvmResolveMethod(curMethod->clazz, ref,METHOD_VIRTUAL);
+            if (baseMethod == NULL) {
+                ILOGV("+ unknown method or access denied\n");
+                GOTO_exceptionThrown();
+            }
+        }
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method's class.
+         *
+         * We're using the current method's class' superclass, not the
+         * superclass of "this".  This is because we might be executing
+         * in a method inherited from a superclass, and we want to run
+         * in that class' superclass.
+         */
+        if (baseMethod->methodIndex >= curMethod->clazz->super->vtableCount) {
+            /*
+             * Method does not exist in the superclass.  Could happen if
+             * superclass gets updated.
+             */
+            dvmThrowException("Ljava/lang/NoSuchMethodError;",
+                baseMethod->name);
+            GOTO_exceptionThrown();
+        }
+        methodToCall = curMethod->clazz->super->vtable[baseMethod->methodIndex];
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+        LOGVV("+++ base=%s.%s super-virtual=%s.%s\n",
+            baseMethod->clazz->descriptor, baseMethod->name,
+            methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeInterface, bool methodCallRange)
+    {
+        Object* thisPtr;
+        ClassObject* thisClass;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-interface-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-interface args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+        thisClass = thisPtr->clazz;
+
+#if defined(WITH_JIT) && (INTERP_TYPE == INTERP_DBG)
+        callsiteClass = thisClass;
+#endif
+
+        /*
+         * Given a class and a method index, find the Method* with the
+         * actual code we want to execute.
+         */
+        methodToCall = dvmFindInterfaceMethodInCache(thisClass, ref, curMethod,
+                        methodClassDex);
+        if (methodToCall == NULL) {
+            assert(dvmCheckException(self));
+            GOTO_exceptionThrown();
+        }
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeDirect, bool methodCallRange)
+    {
+        u2 thisReg;
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* method ref */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        EXPORT_PC();
+
+        if (methodCallRange) {
+            ILOGV("|invoke-direct-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-direct args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+        methodToCall = dvmDexGetResolvedMethod(methodClassDex, ref);
+        if (methodToCall == NULL) {
+            methodToCall = dvmResolveMethod(curMethod->clazz, ref,
+                            METHOD_DIRECT);
+            if (methodToCall == NULL) {
+                ILOGV("+ unknown direct method\n");     // should be impossible
+                GOTO_exceptionThrown();
+            }
+        }
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeStatic, bool methodCallRange)
+    vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+    ref = FETCH(1);             /* method ref */
+    vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+    EXPORT_PC();
+
+    if (methodCallRange)
+        ILOGV("|invoke-static-range args=%d @0x%04x {regs=v%d-v%d}",
+            vsrc1, ref, vdst, vdst+vsrc1-1);
+    else
+        ILOGV("|invoke-static args=%d @0x%04x {regs=0x%04x %x}",
+            vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+
+    methodToCall = dvmDexGetResolvedMethod(methodClassDex, ref);
+    if (methodToCall == NULL) {
+        methodToCall = dvmResolveMethod(curMethod->clazz, ref, METHOD_STATIC);
+        if (methodToCall == NULL) {
+            ILOGV("+ unknown method\n");
+            GOTO_exceptionThrown();
+        }
+
+        /*
+         * The JIT needs dvmDexGetResolvedMethod() to return non-null.
+         * Since we use the portable interpreter to build the trace, this extra
+         * check is not needed for mterp.
+         */
+        if (dvmDexGetResolvedMethod(methodClassDex, ref) == NULL) {
+            /* Class initialization is still ongoing */
+            ABORT_JIT_TSELECT();
+        }
+    }
+    GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeVirtualQuick, bool methodCallRange)
+    {
+        Object* thisPtr;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* vtable index */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        /*
+         * The object against which we are executing a method is always
+         * in the first argument.
+         */
+        if (methodCallRange) {
+            assert(vsrc1 > 0);
+            ILOGV("|invoke-virtual-quick-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisPtr = (Object*) GET_REGISTER(vdst);
+        } else {
+            assert((vsrc1>>4) > 0);
+            ILOGV("|invoke-virtual-quick args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisPtr = (Object*) GET_REGISTER(vdst & 0x0f);
+        }
+
+        if (!checkForNull(thisPtr))
+            GOTO_exceptionThrown();
+
+#if defined(WITH_JIT) && (INTERP_TYPE == INTERP_DBG)
+        callsiteClass = thisPtr->clazz;
+#endif
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method.
+         */
+        assert(ref < thisPtr->clazz->vtableCount);
+        methodToCall = thisPtr->clazz->vtable[ref];
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+
+        LOGVV("+++ virtual[%d]=%s.%s\n",
+            ref, methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+GOTO_TARGET(invokeSuperQuick, bool methodCallRange)
+    {
+        u2 thisReg;
+
+        EXPORT_PC();
+
+        vsrc1 = INST_AA(inst);      /* AA (count) or BA (count + arg 5) */
+        ref = FETCH(1);             /* vtable index */
+        vdst = FETCH(2);            /* 4 regs -or- first reg */
+
+        if (methodCallRange) {
+            ILOGV("|invoke-super-quick-range args=%d @0x%04x {regs=v%d-v%d}",
+                vsrc1, ref, vdst, vdst+vsrc1-1);
+            thisReg = vdst;
+        } else {
+            ILOGV("|invoke-super-quick args=%d @0x%04x {regs=0x%04x %x}",
+                vsrc1 >> 4, ref, vdst, vsrc1 & 0x0f);
+            thisReg = vdst & 0x0f;
+        }
+        /* impossible in well-formed code, but we must check nevertheless */
+        if (!checkForNull((Object*) GET_REGISTER(thisReg)))
+            GOTO_exceptionThrown();
+
+#if 0   /* impossible in optimized + verified code */
+        if (ref >= curMethod->clazz->super->vtableCount) {
+            dvmThrowException("Ljava/lang/NoSuchMethodError;", NULL);
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(ref < curMethod->clazz->super->vtableCount);
+#endif
+
+        /*
+         * Combine the object we found with the vtable offset in the
+         * method's class.
+         *
+         * We're using the current method's class' superclass, not the
+         * superclass of "this".  This is because we might be executing
+         * in a method inherited from a superclass, and we want to run
+         * in the method's class' superclass.
+         */
+        methodToCall = curMethod->clazz->super->vtable[ref];
+
+#if 0
+        if (dvmIsAbstractMethod(methodToCall)) {
+            dvmThrowException("Ljava/lang/AbstractMethodError;",
+                "abstract method not implemented");
+            GOTO_exceptionThrown();
+        }
+#else
+        assert(!dvmIsAbstractMethod(methodToCall) ||
+            methodToCall->nativeFunc != NULL);
+#endif
+        LOGVV("+++ super-virtual[%d]=%s.%s\n",
+            ref, methodToCall->clazz->descriptor, methodToCall->name);
+        assert(methodToCall != NULL);
+
+        GOTO_invokeMethod(methodCallRange, methodToCall, vsrc1, vdst);
+    }
+GOTO_TARGET_END
+
+
+    /*
+     * General handling for return-void, return, and return-wide.  Put the
+     * return value in "retval" before jumping here.
+     */
+GOTO_TARGET(returnFromMethod)
+    {
+        StackSaveArea* saveArea;
+
+        /*
+         * We must do this BEFORE we pop the previous stack frame off, so
+         * that the GC can see the return value (if any) in the local vars.
+         *
+         * Since this is now an interpreter switch point, we must do it before
+         * we do anything at all.
+         */
+        PERIODIC_CHECKS(kInterpEntryReturn, 0);
+
+        ILOGV("> retval=0x%llx (leaving %s.%s %s)",
+            retval.j, curMethod->clazz->descriptor, curMethod->name,
+            curMethod->shorty);
+        //DUMP_REGS(curMethod, fp);
+
+        saveArea = SAVEAREA_FROM_FP(fp);
+
+#ifdef EASY_GDB
+        debugSaveArea = saveArea;
+#endif
+#if (INTERP_TYPE == INTERP_DBG)
+        TRACE_METHOD_EXIT(self, curMethod);
+#endif
+
+        /* back up to previous frame and see if we hit a break */
+        fp = saveArea->prevFrame;
+        assert(fp != NULL);
+        if (dvmIsBreakFrame(fp)) {
+            /* bail without popping the method frame from stack */
+            LOGVV("+++ returned into break frame\n");
+#if defined(WITH_JIT)
+            /* Let the Jit know the return is terminating normally */
+            CHECK_JIT_VOID();
+#endif
+            GOTO_bail();
+        }
+
+        /* update thread FP, and reset local variables */
+        self->curFrame = fp;
+        curMethod = SAVEAREA_FROM_FP(fp)->method;
+        //methodClass = curMethod->clazz;
+        methodClassDex = curMethod->clazz->pDvmDex;
+        pc = saveArea->savedPc;
+        ILOGD("> (return to %s.%s %s)", curMethod->clazz->descriptor,
+            curMethod->name, curMethod->shorty);
+
+        /* use FINISH on the caller's invoke instruction */
+        //u2 invokeInstr = INST_INST(FETCH(0));
+        if (true /*invokeInstr >= OP_INVOKE_VIRTUAL &&
+            invokeInstr <= OP_INVOKE_INTERFACE*/)
+        {
+            FINISH(3);
+        } else {
+            //LOGE("Unknown invoke instr %02x at %d\n",
+            //    invokeInstr, (int) (pc - curMethod->insns));
+            assert(false);
+        }
+    }
+GOTO_TARGET_END
+
+
+    /*
+     * Jump here when the code throws an exception.
+     *
+     * By the time we get here, the Throwable has been created and the stack
+     * trace has been saved off.
+     */
+GOTO_TARGET(exceptionThrown)
+    {
+        Object* exception;
+        int catchRelPc;
+
+        /*
+         * Since this is now an interpreter switch point, we must do it before
+         * we do anything at all.
+         */
+        PERIODIC_CHECKS(kInterpEntryThrow, 0);
+
+#if defined(WITH_JIT)
+        // Something threw during trace selection - abort the current trace
+        ABORT_JIT_TSELECT();
+#endif
+        /*
+         * We save off the exception and clear the exception status.  While
+         * processing the exception we might need to load some Throwable
+         * classes, and we don't want class loader exceptions to get
+         * confused with this one.
+         */
+        assert(dvmCheckException(self));
+        exception = dvmGetException(self);
+        dvmAddTrackedAlloc(exception, self);
+        dvmClearException(self);
+
+        LOGV("Handling exception %s at %s:%d\n",
+            exception->clazz->descriptor, curMethod->name,
+            dvmLineNumFromPC(curMethod, pc - curMethod->insns));
+
+#if (INTERP_TYPE == INTERP_DBG)
+        /*
+         * Tell the debugger about it.
+         *
+         * TODO: if the exception was thrown by interpreted code, control
+         * fell through native, and then back to us, we will report the
+         * exception at the point of the throw and again here.  We can avoid
+         * this by not reporting exceptions when we jump here directly from
+         * the native call code above, but then we won't report exceptions
+         * that were thrown *from* the JNI code (as opposed to *through* it).
+         *
+         * The correct solution is probably to ignore from-native exceptions
+         * here, and have the JNI exception code do the reporting to the
+         * debugger.
+         */
+        if (gDvm.debuggerActive) {
+            void* catchFrame;
+            catchRelPc = dvmFindCatchBlock(self, pc - curMethod->insns,
+                        exception, true, &catchFrame);
+            dvmDbgPostException(fp, pc - curMethod->insns, catchFrame,
+                catchRelPc, exception);
+        }
+#endif
+
+        /*
+         * We need to unroll to the catch block or the nearest "break"
+         * frame.
+         *
+         * A break frame could indicate that we have reached an intermediate
+         * native call, or have gone off the top of the stack and the thread
+         * needs to exit.  Either way, we return from here, leaving the
+         * exception raised.
+         *
+         * If we do find a catch block, we want to transfer execution to
+         * that point.
+         *
+         * Note this can cause an exception while resolving classes in
+         * the "catch" blocks.
+         */
+        catchRelPc = dvmFindCatchBlock(self, pc - curMethod->insns,
+                    exception, false, (void*)&fp);
+
+        /*
+         * Restore the stack bounds after an overflow.  This isn't going to
+         * be correct in all circumstances, e.g. if JNI code devours the
+         * exception this won't happen until some other exception gets
+         * thrown.  If the code keeps pushing the stack bounds we'll end
+         * up aborting the VM.
+         *
+         * Note we want to do this *after* the call to dvmFindCatchBlock,
+         * because that may need extra stack space to resolve exception
+         * classes (e.g. through a class loader).
+         *
+         * It's possible for the stack overflow handling to cause an
+         * exception (specifically, class resolution in a "catch" block
+         * during the call above), so we could see the thread's overflow
+         * flag raised but actually be running in a "nested" interpreter
+         * frame.  We don't allow doubled-up StackOverflowErrors, so
+         * we can check for this by just looking at the exception type
+         * in the cleanup function.  Also, we won't unroll past the SOE
+         * point because the more-recent exception will hit a break frame
+         * as it unrolls to here.
+         */
+        if (self->stackOverflowed)
+            dvmCleanupStackOverflow(self, exception);
+
+        if (catchRelPc < 0) {
+            /* falling through to JNI code or off the bottom of the stack */
+#if DVM_SHOW_EXCEPTION >= 2
+            LOGD("Exception %s from %s:%d not caught locally\n",
+                exception->clazz->descriptor, dvmGetMethodSourceFile(curMethod),
+                dvmLineNumFromPC(curMethod, pc - curMethod->insns));
+#endif
+            dvmSetException(self, exception);
+            dvmReleaseTrackedAlloc(exception, self);
+            GOTO_bail();
+        }
+
+#if DVM_SHOW_EXCEPTION >= 3
+        {
+            const Method* catchMethod = SAVEAREA_FROM_FP(fp)->method;
+            LOGD("Exception %s thrown from %s:%d to %s:%d\n",
+                exception->clazz->descriptor, dvmGetMethodSourceFile(curMethod),
+                dvmLineNumFromPC(curMethod, pc - curMethod->insns),
+                dvmGetMethodSourceFile(catchMethod),
+                dvmLineNumFromPC(catchMethod, catchRelPc));
+        }
+#endif
+
+        /*
+         * Adjust local variables to match self->curFrame and the
+         * updated PC.
+         */
+        //fp = (u4*) self->curFrame;
+        curMethod = SAVEAREA_FROM_FP(fp)->method;
+        //methodClass = curMethod->clazz;
+        methodClassDex = curMethod->clazz->pDvmDex;
+        pc = curMethod->insns + catchRelPc;
+        ILOGV("> pc <-- %s.%s %s", curMethod->clazz->descriptor,
+            curMethod->name, curMethod->shorty);
+        DUMP_REGS(curMethod, fp, false);            // show all regs
+
+        /*
+         * Restore the exception if the handler wants it.
+         *
+         * The Dalvik spec mandates that, if an exception handler wants to
+         * do something with the exception, the first instruction executed
+         * must be "move-exception".  We can pass the exception along
+         * through the thread struct, and let the move-exception instruction
+         * clear it for us.
+         *
+         * If the handler doesn't call move-exception, we don't want to
+         * finish here with an exception still pending.
+         */
+        if (INST_INST(FETCH(0)) == OP_MOVE_EXCEPTION)
+            dvmSetException(self, exception);
+
+        dvmReleaseTrackedAlloc(exception, self);
+        FINISH(0);
+    }
+GOTO_TARGET_END
+
+
+
+    /*
+     * General handling for invoke-{virtual,super,direct,static,interface},
+     * including "quick" variants.
+     *
+     * Set "methodToCall" to the Method we're calling, and "methodCallRange"
+     * depending on whether this is a "/range" instruction.
+     *
+     * For a range call:
+     *  "vsrc1" holds the argument count (8 bits)
+     *  "vdst" holds the first argument in the range
+     * For a non-range call:
+     *  "vsrc1" holds the argument count (4 bits) and the 5th argument index
+     *  "vdst" holds four 4-bit register indices
+     *
+     * The caller must EXPORT_PC before jumping here, because any method
+     * call can throw a stack overflow exception.
+     */
+GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
+    u2 count, u2 regs)
+    {
+        STUB_HACK(vsrc1 = count; vdst = regs; methodToCall = _methodToCall;);
+
+        //printf("range=%d call=%p count=%d regs=0x%04x\n",
+        //    methodCallRange, methodToCall, count, regs);
+        //printf(" --> %s.%s %s\n", methodToCall->clazz->descriptor,
+        //    methodToCall->name, methodToCall->shorty);
+
+        u4* outs;
+        int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
+
+        /*
+         * Copy args.  This may corrupt vsrc1/vdst.
+         */
+        if (methodCallRange) {
+            // could use memcpy or a "Duff's device"; most functions have
+            // so few args it won't matter much
+            assert(vsrc1 <= curMethod->outsSize);
+            assert(vsrc1 == methodToCall->insSize);
+            outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
+            for (i = 0; i < vsrc1; i++)
+                outs[i] = GET_REGISTER(vdst+i);
+#endif
+        } else {
+            u4 count = vsrc1 >> 4;
+
+            assert(count <= curMethod->outsSize);
+            assert(count == methodToCall->insSize);
+            assert(count <= 5);
+
+            outs = OUTS_FROM_FP(fp, count);
+#if 0
+            if (count == 5) {
+                outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+                count--;
+            }
+            for (i = 0; i < (int) count; i++) {
+                outs[i] = GET_REGISTER(vdst & 0x0f);
+                vdst >>= 4;
+            }
+#else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
+            // This version executes fewer instructions but is larger
+            // overall.  Seems to be a teensy bit faster.
+            switch (count) {
+            case 5:
+                outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+            case 4:
+                outs[3] = GET_REGISTER(vdst >> 12);
+            case 3:
+                outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+            case 2:
+                outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+            case 1:
+                outs[0] = GET_REGISTER(vdst & 0x0f);
+            default:
+                ;
+            }
+#endif /* WITH_TAINT_TRACKING */
+#endif
+        }
+    }
+
+    /*
+     * (This was originally a "goto" target; I've kept it separate from the
+     * stuff above in case we want to refactor things again.)
+     *
+     * At this point, we have the arguments stored in the "outs" area of
+     * the current method's stack frame, and the method to call in
+     * "methodToCall".  Push a new stack frame.
+     */
+    {
+        StackSaveArea* newSaveArea;
+        u4* newFp;
+
+        ILOGV("> %s%s.%s %s",
+            dvmIsNativeMethod(methodToCall) ? "(NATIVE) " : "",
+            methodToCall->clazz->descriptor, methodToCall->name,
+            methodToCall->shorty);
+
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
+        newSaveArea = SAVEAREA_FROM_FP(newFp);
+
+        /* verify that we have enough space */
+        if (true) {
+            u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
+            bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
+            if (bottom < self->interpStackEnd) {
+                /* stack overflow */
+                LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
+                    self->interpStackStart, self->interpStackEnd, bottom,
+                    (u1*) fp - bottom, self->interpStackSize,
+                    methodToCall->name);
+                dvmHandleStackOverflow(self, methodToCall);
+                assert(dvmCheckException(self));
+                GOTO_exceptionThrown();
+            }
+            //LOGD("+++ fp=%p newFp=%p newSave=%p bottom=%p\n",
+            //    fp, newFp, newSaveArea, bottom);
+        }
+
+#ifdef LOG_INSTR
+        if (methodToCall->registersSize > methodToCall->insSize) {
+            /*
+             * This makes valgrind quiet when we print registers that
+             * haven't been initialized.  Turn it off when the debug
+             * messages are disabled -- we want valgrind to report any
+             * used-before-initialized issues.
+             */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
+        }
+#endif
+
+#ifdef EASY_GDB
+        newSaveArea->prevSave = SAVEAREA_FROM_FP(fp);
+#endif
+        newSaveArea->prevFrame = fp;
+        newSaveArea->savedPc = pc;
+#if defined(WITH_JIT)
+        newSaveArea->returnAddr = 0;
+#endif
+        newSaveArea->method = methodToCall;
+
+        if (!dvmIsNativeMethod(methodToCall)) {
+            /*
+             * "Call" interpreted code.  Reposition the PC, update the
+             * frame pointer and other local state, and continue.
+             */
+            curMethod = methodToCall;
+            methodClassDex = curMethod->clazz->pDvmDex;
+            pc = methodToCall->insns;
+            fp = self->curFrame = newFp;
+#ifdef EASY_GDB
+            debugSaveArea = SAVEAREA_FROM_FP(newFp);
+#endif
+#if INTERP_TYPE == INTERP_DBG
+            debugIsMethodEntry = true;              // profiling, debugging
+#endif
+            ILOGD("> pc <-- %s.%s %s", curMethod->clazz->descriptor,
+                curMethod->name, curMethod->shorty);
+            DUMP_REGS(curMethod, fp, true);         // show input args
+            FINISH(0);                              // jump to method start
+        } else {
+            /* set this up for JNI locals, even if not a JNI native */
+#ifdef USE_INDIRECT_REF
+            newSaveArea->xtra.localRefCookie = self->jniLocalRefTable.segmentState.all;
+#else
+            newSaveArea->xtra.localRefCookie = self->jniLocalRefTable.nextEntry;
+#endif
+
+            self->curFrame = newFp;
+
+            DUMP_REGS(methodToCall, newFp, true);   // show input args
+
+#if (INTERP_TYPE == INTERP_DBG)
+            if (gDvm.debuggerActive) {
+                dvmDbgPostLocationEvent(methodToCall, -1,
+                    dvmGetThisPtr(curMethod, fp), DBG_METHOD_ENTRY);
+            }
+#endif
+#if (INTERP_TYPE == INTERP_DBG)
+            TRACE_METHOD_ENTER(self, methodToCall);
+#endif
+
+            {
+                ILOGD("> native <-- %s.%s %s", methodToCall->clazz->descriptor,
+                        methodToCall->name, methodToCall->shorty);
+            }
+
+#if defined(WITH_JIT)
+            /* Allow the Jit to end any pending trace building */
+            CHECK_JIT_VOID();
+#endif
+
+            /*
+             * Jump through native call bridge.  Because we leave no
+             * space for locals on native calls, "newFp" points directly
+             * to the method arguments.
+             */
+            (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
+#if (INTERP_TYPE == INTERP_DBG)
+            if (gDvm.debuggerActive) {
+                dvmDbgPostLocationEvent(methodToCall, -1,
+                    dvmGetThisPtr(curMethod, fp), DBG_METHOD_EXIT);
+            }
+#endif
+#if (INTERP_TYPE == INTERP_DBG)
+            TRACE_METHOD_EXIT(self, methodToCall);
+#endif
+
+            /* pop frame off */
+            dvmPopJniLocals(self, newSaveArea);
+            self->curFrame = fp;
+
+            /*
+             * If the native code threw an exception, or interpreted code
+             * invoked by the native call threw one and nobody has cleared
+             * it, jump to our local exception handling.
+             */
+            if (dvmCheckException(self)) {
+                LOGV("Exception thrown by/below native code\n");
+                GOTO_exceptionThrown();
+            }
+
+            ILOGD("> retval=0x%llx (leaving native)", retval.j);
+            ILOGD("> (return from native %s.%s to %s.%s %s)",
+                methodToCall->clazz->descriptor, methodToCall->name,
+                curMethod->clazz->descriptor, curMethod->name,
+                curMethod->shorty);
+
+            //u2 invokeInstr = INST_INST(FETCH(0));
+            if (true /*invokeInstr >= OP_INVOKE_VIRTUAL &&
+                invokeInstr <= OP_INVOKE_INTERFACE*/)
+            {
+                FINISH(3);
+            } else {
+                //LOGE("Unknown invoke instr %02x at %d\n",
+                //    invokeInstr, (int) (pc - curMethod->insns));
+                assert(false);
+            }
+        }
+    }
+    assert(false);      // should not get here
+GOTO_TARGET_END
+
 /* File: cstubs/enddefs.c */
 
 /* undefine "magic" name remapping */
@@ -1206,6 +2661,10 @@ GOTO_TARGET_DECL(exceptionThrown);
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
+
 /* File: armv5te/debug.c */
 #include <inttypes.h>
 
diff --git a/vm/mterp/out/InterpC-portdbg.c b/vm/mterp/out/InterpC-portdbg.c
index e909db4..f922d9c 100644
--- a/vm/mterp/out/InterpC-portdbg.c
+++ b/vm/mterp/out/InterpC-portdbg.c
@@ -161,6 +161,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -180,6 +205,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -197,6 +236,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -216,6 +269,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -233,6 +300,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -241,6 +322,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -284,6 +414,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -562,6 +734,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -587,6 +763,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -596,6 +776,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -622,6 +805,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -663,6 +849,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -698,6 +887,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -712,6 +905,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -745,6 +942,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -779,6 +979,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -794,6 +997,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -825,6 +1031,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -870,6 +1084,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -884,6 +1102,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -917,6 +1139,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -939,6 +1169,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -953,6 +1187,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -963,6 +1201,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -997,6 +1243,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1023,6 +1273,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1067,6 +1322,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1085,6 +1345,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1112,6 +1379,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1130,6 +1401,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1159,6 +1436,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1183,6 +1463,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1447,6 +1731,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
 #endif
     DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex
     JValue retval;
+#ifdef WITH_TAINT_TRACKING
+    Taint rtaint;
+#endif
 
     /* core state */
     const Method* curMethod;    // method we're interpreting
@@ -1507,6 +1794,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
     pc = interpState->pc;
     fp = interpState->fp;
     retval = interpState->retval;   /* only need for kInterpEntryReturn? */
+#ifdef WITH_TAINT_TRACKING
+    rtaint = interpState->rtaint;
+#endif
 
     methodClassDex = curMethod->clazz->pDvmDex;
 
@@ -1569,6 +1859,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1580,6 +1873,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1591,6 +1887,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1603,6 +1902,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1613,6 +1915,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1623,6 +1928,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1635,6 +1943,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1648,6 +1959,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1661,6 +1975,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1672,6 +1989,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1680,6 +2000,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1691,6 +2014,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1701,6 +2027,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1711,6 +2040,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1720,6 +2052,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1728,6 +2063,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1738,6 +2076,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1751,6 +2092,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1761,6 +2105,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1774,6 +2121,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1784,6 +2134,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1793,6 +2146,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1806,6 +2162,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1822,6 +2181,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1832,6 +2194,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1851,6 +2216,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1873,6 +2241,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1893,6 +2264,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2012,6 +2386,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -2030,6 +2407,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -2077,6 +2457,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2114,6 +2497,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2458,6 +2844,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         dvmSetObjectArrayElement(arrayObj,
                                  GET_REGISTER(vsrc2),
                                  (Object *)GET_REGISTER(vdst));
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2866,6 +3257,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2897,6 +3292,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3012,6 +3411,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -3038,6 +3441,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -3053,6 +3460,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3095,6 +3505,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3506,6 +3919,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -4183,6 +4599,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -4193,8 +4612,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -4213,9 +4655,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -4230,6 +4719,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -4251,13 +4741,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
@@ -4280,8 +4780,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -4352,6 +4859,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG)
             if (gDvm.debuggerActive) {
@@ -4410,6 +4926,9 @@ bail:
     ILOGD("|-- Leaving interpreter loop");      // note "curMethod" may be NULL
 
     interpState->retval = retval;
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     return false;
 
 bail_switch:
@@ -4432,6 +4951,9 @@ bail_switch:
     interpState->fp = fp;
     /* debugTrackedRefStart doesn't change */
     interpState->retval = retval;   /* need for _entryPoint=ret */
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     interpState->nextMode =
         (INTERP_TYPE == INTERP_STD) ? INTERP_DBG : INTERP_STD;
     LOGVV(" meth='%s.%s' pc=0x%x fp=%p\n",
diff --git a/vm/mterp/out/InterpC-portstd.c b/vm/mterp/out/InterpC-portstd.c
index f82c97d..bb7b621 100644
--- a/vm/mterp/out/InterpC-portstd.c
+++ b/vm/mterp/out/InterpC-portstd.c
@@ -161,6 +161,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -180,6 +205,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -197,6 +236,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -216,6 +269,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -233,6 +300,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -241,6 +322,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -284,6 +414,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -553,6 +725,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -578,6 +754,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -587,6 +767,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -613,6 +796,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -654,6 +840,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -689,6 +878,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -703,6 +896,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -736,6 +933,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -770,6 +970,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -785,6 +988,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -816,6 +1022,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -825,6 +1035,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -861,6 +1075,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -875,6 +1093,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -908,6 +1130,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -917,6 +1143,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -930,6 +1160,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -944,6 +1178,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -954,6 +1192,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -963,6 +1205,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -988,6 +1234,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1014,6 +1264,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1058,6 +1313,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1336,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1103,6 +1370,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1150,6 +1427,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1174,6 +1454,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1197,6 +1481,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
 #endif
     DvmDex* methodClassDex;     // curMethod->clazz->pDvmDex
     JValue retval;
+#ifdef WITH_TAINT_TRACKING
+    Taint rtaint;
+#endif
 
     /* core state */
     const Method* curMethod;    // method we're interpreting
@@ -1257,6 +1544,9 @@ bool INTERP_FUNC_NAME(Thread* self, InterpState* interpState)
     pc = interpState->pc;
     fp = interpState->fp;
     retval = interpState->retval;   /* only need for kInterpEntryReturn? */
+#ifdef WITH_TAINT_TRACKING
+    rtaint = interpState->rtaint;
+#endif
 
     methodClassDex = curMethod->clazz->pDvmDex;
 
@@ -1319,6 +1609,9 @@ HANDLE_OPCODE(OP_MOVE /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1330,6 +1623,9 @@ HANDLE_OPCODE(OP_MOVE_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1341,6 +1637,9 @@ HANDLE_OPCODE(OP_MOVE_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1353,6 +1652,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE /*vA, vB*/)
     ILOGV("|move-wide v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+5, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1363,6 +1665,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_FROM16 /*vAA, vBBBB*/)
     ILOGV("|move-wide/from16 v%d,v%d  (v%d=0x%08llx)", vdst, vsrc1,
         vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1373,6 +1678,9 @@ HANDLE_OPCODE(OP_MOVE_WIDE_16 /*vAAAA, vBBBB*/)
     ILOGV("|move-wide/16 v%d,v%d %s(v%d=0x%08llx)", vdst, vsrc1,
         kSpacing+8, vdst, GET_REGISTER_WIDE(vsrc1));
     SET_REGISTER_WIDE(vdst, GET_REGISTER_WIDE(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1385,6 +1693,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT /*vA, vB*/)
         (INST_INST(inst) == OP_MOVE) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1398,6 +1709,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_FROM16 /*vAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_FROM16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1411,6 +1725,9 @@ HANDLE_OPCODE(OP_MOVE_OBJECT_16 /*vAAAA, vBBBB*/)
         (INST_INST(inst) == OP_MOVE_16) ? "" : "-object", vdst, vsrc1,
         kSpacing, vdst, GET_REGISTER(vsrc1));
     SET_REGISTER(vdst, GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     FINISH(3);
 OP_END
 
@@ -1422,6 +1739,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1430,6 +1750,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_WIDE /*vAA*/)
     vdst = INST_AA(inst);
     ILOGV("|move-result-wide v%d %s(0x%08llx)", vdst, kSpacing, retval.j);
     SET_REGISTER_WIDE(vdst, retval.j);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1441,6 +1764,9 @@ HANDLE_OPCODE(OP_MOVE_RESULT_OBJECT /*vAA*/)
          (INST_INST(inst) == OP_MOVE_RESULT) ? "" : "-object",
          vdst, kSpacing+4, vdst,retval.i);
     SET_REGISTER(vdst, retval.i);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, GET_RETURN_TAINT());
+/* endif */
     FINISH(1);
 OP_END
 
@@ -1451,6 +1777,9 @@ HANDLE_OPCODE(OP_MOVE_EXCEPTION /*vAA*/)
     ILOGV("|move-exception v%d", vdst);
     assert(self->exception != NULL);
     SET_REGISTER(vdst, (u4)self->exception);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     dvmClearException(self);
     FINISH(1);
 OP_END
@@ -1461,6 +1790,9 @@ HANDLE_OPCODE(OP_RETURN_VOID /**/)
 #ifndef NDEBUG
     retval.j = 0xababababULL;    // placate valgrind
 #endif
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1470,6 +1802,9 @@ HANDLE_OPCODE(OP_RETURN /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1478,6 +1813,9 @@ HANDLE_OPCODE(OP_RETURN_WIDE /*vAA*/)
     vsrc1 = INST_AA(inst);
     ILOGV("|return-wide v%d", vsrc1);
     retval.j = GET_REGISTER_WIDE(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT_WIDE(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1488,6 +1826,9 @@ HANDLE_OPCODE(OP_RETURN_OBJECT /*vAA*/)
     ILOGV("|return%s v%d",
         (INST_INST(inst) == OP_RETURN) ? "" : "-object", vsrc1);
     retval.i = GET_REGISTER(vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_RETURN_TAINT(GET_REGISTER_TAINT(vsrc1));
+/* endif */
     GOTO_returnFromMethod();
 OP_END
 
@@ -1501,6 +1842,9 @@ HANDLE_OPCODE(OP_CONST_4 /*vA, #+B*/)
         tmp = (s4) (INST_B(inst) << 28) >> 28;  // sign extend 4-bit value
         ILOGV("|const/4 v%d,#0x%02x", vdst, (s4)tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1511,6 +1855,9 @@ HANDLE_OPCODE(OP_CONST_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER(vdst, (s2) vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1524,6 +1871,9 @@ HANDLE_OPCODE(OP_CONST /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const v%d,#0x%08x", vdst, tmp);
         SET_REGISTER(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1534,6 +1884,9 @@ HANDLE_OPCODE(OP_CONST_HIGH16 /*vAA, #+BBBB0000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const/high16 v%d,#0x%04x0000", vdst, vsrc1);
     SET_REGISTER(vdst, vsrc1 << 16);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1543,6 +1896,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_16 /*vAA, #+BBBB*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/16 v%d,#0x%04x", vdst, (s2)vsrc1);
     SET_REGISTER_WIDE(vdst, (s2)vsrc1);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1556,6 +1912,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_32 /*vAA, #+BBBBBBBB*/)
         tmp |= (u4)FETCH(2) << 16;
         ILOGV("|const-wide/32 v%d,#0x%08x", vdst, tmp);
         SET_REGISTER_WIDE(vdst, (s4) tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1572,6 +1931,9 @@ HANDLE_OPCODE(OP_CONST_WIDE /*vAA, #+BBBBBBBBBBBBBBBB*/)
         tmp |= (u8)FETCH(4) << 48;
         ILOGV("|const-wide v%d,#0x%08llx", vdst, tmp);
         SET_REGISTER_WIDE(vdst, tmp);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(5);
 OP_END
@@ -1582,6 +1944,9 @@ HANDLE_OPCODE(OP_CONST_WIDE_HIGH16 /*vAA, #+BBBB000000000000*/)
     vsrc1 = FETCH(1);
     ILOGV("|const-wide/high16 v%d,#0x%04x000000000000", vdst, vsrc1);
     SET_REGISTER_WIDE(vdst, ((u8) vsrc1) << 48);
+/* ifdef WITH_TAINT_TRACKING */
+    SET_REGISTER_TAINT_WIDE(vdst, TAINT_CLEAR);
+/* endif */
     FINISH(2);
 OP_END
 
@@ -1601,6 +1966,9 @@ HANDLE_OPCODE(OP_CONST_STRING /*vAA, string@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1623,6 +1991,9 @@ HANDLE_OPCODE(OP_CONST_STRING_JUMBO /*vAA, string@BBBBBBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) strObj);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 OP_END
@@ -1643,6 +2014,9 @@ HANDLE_OPCODE(OP_CONST_CLASS /*vAA, class@BBBB*/)
                 GOTO_exceptionThrown();
         }
         SET_REGISTER(vdst, (u4) clazz);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1762,6 +2136,9 @@ HANDLE_OPCODE(OP_INSTANCE_OF /*vA, vB, class@CCCC*/)
                     GOTO_exceptionThrown();
             }
             SET_REGISTER(vdst, dvmInstanceof(obj->clazz, clazz));
+/* ifdef WITH_TAINT_TRACKING */
+	    SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
         }
     }
     FINISH(2);
@@ -1780,6 +2157,9 @@ HANDLE_OPCODE(OP_ARRAY_LENGTH /*vA, vB*/)
             GOTO_exceptionThrown();
         /* verifier guarantees this is an array reference */
         SET_REGISTER(vdst, arrayObj->length);
+/* ifdef WITH_TAINT_TRACKING */
+	SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(1);
 OP_END
@@ -1827,6 +2207,9 @@ HANDLE_OPCODE(OP_NEW_INSTANCE /*vAA, class@BBBB*/)
         if (newObj == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newObj);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -1864,6 +2247,9 @@ HANDLE_OPCODE(OP_NEW_ARRAY /*vA, vB, class@CCCC*/)
         if (newArray == NULL)
             GOTO_exceptionThrown();
         SET_REGISTER(vdst, (u4) newArray);
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2208,6 +2594,11 @@ HANDLE_OPCODE(OP_APUT_OBJECT /*vAA, vBB, vCC*/)
         dvmSetObjectArrayElement(arrayObj,
                                  GET_REGISTER(vsrc2),
                                  (Object *)GET_REGISTER(vdst));
+/* ifdef WITH_TAINT_TRACKING */
+	SET_ARRAY_TAINT(arrayObj,
+		(GET_ARRAY_TAINT(arrayObj) |
+		 GET_REGISTER_TAINT(vdst)) );
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2616,6 +3007,10 @@ HANDLE_OPCODE(OP_REM_FLOAT /*vAA, vBB, vCC*/)
         ILOGV("|%s-float v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_FLOAT(vdst,
             fmodf(GET_REGISTER_FLOAT(vsrc1), GET_REGISTER_FLOAT(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2647,6 +3042,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE /*vAA, vBB, vCC*/)
         ILOGV("|%s-double v%d,v%d,v%d", "mod", vdst, vsrc1, vsrc2);
         SET_REGISTER_DOUBLE(vdst,
             fmod(GET_REGISTER_DOUBLE(vsrc1), GET_REGISTER_DOUBLE(vsrc2)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2762,6 +3161,10 @@ HANDLE_OPCODE(OP_REM_FLOAT_2ADDR /*vA, vB*/)
     ILOGV("|%s-float-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_FLOAT(vdst,
         fmodf(GET_REGISTER_FLOAT(vdst), GET_REGISTER_FLOAT(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_FLOAT(vdst,
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2788,6 +3191,10 @@ HANDLE_OPCODE(OP_REM_DOUBLE_2ADDR /*vA, vB*/)
     ILOGV("|%s-double-2addr v%d,v%d", "mod", vdst, vsrc1);
     SET_REGISTER_DOUBLE(vdst,
         fmod(GET_REGISTER_DOUBLE(vdst), GET_REGISTER_DOUBLE(vsrc1)));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT_DOUBLE(vdst,
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));
+/* endif */
     FINISH(1);
 OP_END
 
@@ -2803,6 +3210,9 @@ HANDLE_OPCODE(OP_RSUB_INT /*vA, vB, #+CCCC*/)
         vsrc2 = FETCH(1);
         ILOGV("|rsub-int v%d,v%d,#+0x%04x", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s2) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -2845,6 +3255,9 @@ HANDLE_OPCODE(OP_RSUB_INT_LIT8 /*vAA, vBB, #+CC*/)
         vsrc2 = litInfo >> 8;
         ILOGV("|%s-int/lit8 v%d,v%d,#+0x%02x", "rsub", vdst, vsrc1, vsrc2);
         SET_REGISTER(vdst, (s1) vsrc2 - (s4) GET_REGISTER(vsrc1));
+/* ifdef WITH_TAINT_TRACKING */
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));
+/* endif */
     }
     FINISH(2);
 OP_END
@@ -3256,6 +3669,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -3933,6 +4349,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -3943,8 +4362,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -3963,9 +4405,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -3980,6 +4469,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -4001,13 +4491,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
@@ -4030,8 +4530,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -4102,6 +4609,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG)
             if (gDvm.debuggerActive) {
@@ -4160,6 +4676,9 @@ bail:
     ILOGD("|-- Leaving interpreter loop");      // note "curMethod" may be NULL
 
     interpState->retval = retval;
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     return false;
 
 bail_switch:
@@ -4182,6 +4701,9 @@ bail_switch:
     interpState->fp = fp;
     /* debugTrackedRefStart doesn't change */
     interpState->retval = retval;   /* need for _entryPoint=ret */
+#ifdef WITH_TAINT_TRACKING
+    interpState->rtaint = rtaint;
+#endif
     interpState->nextMode =
         (INTERP_TYPE == INTERP_STD) ? INTERP_DBG : INTERP_STD;
     LOGVV(" meth='%s.%s' pc=0x%x fp=%p\n",
diff --git a/vm/mterp/out/InterpC-x86.c b/vm/mterp/out/InterpC-x86.c
index 4882184..a025cdf 100644
--- a/vm/mterp/out/InterpC-x86.c
+++ b/vm/mterp/out/InterpC-x86.c
@@ -161,6 +161,31 @@ static const char kSpacing[] = "            ";
 # define DUMP_REGS(_meth, _frame, _inOnly) ((void)0)
 #endif
 
+/*
+ * If enabled, log taint propagation
+ */
+#ifdef WITH_TAINT_TRACKING
+# define TLOGD(...) TLOG(LOG_DEBUG, __VA_ARGS__)
+# define TLOGV(...) TLOG(LOG_VERBOSE, __VA_ARGS__)
+# define TLOGW(...) TLOG(LOG_WARN, __VA_ARGS__)
+# define TLOGE(...) TLOG(LOG_ERROR, __VA_ARGS__)
+# define TLOG(_level, ...) do {                                             \
+        char debugStrBuf[128];                                              \
+        snprintf(debugStrBuf, sizeof(debugStrBuf), __VA_ARGS__);            \
+        if (curMethod != NULL)                                              \
+            LOG(_level, LOG_TAG"t", "%-2d|%04x|%s.%s:%s\n",                    \
+                self->threadId, (int)(pc - curMethod->insns), curMethod->clazz->descriptor, curMethod->name, debugStrBuf); \
+        else                                                                \
+            LOG(_level, LOG_TAG"t", "%-2d|####%s\n",                        \
+                self->threadId, debugStrBuf);                               \
+    } while(false)
+#else
+# define TLOGD(...) ((void)0)
+# define TLOGV(...) ((void)0)
+# define TLOGW(...) ((void)0)
+# define TLOGE(...) ((void)0)
+#endif
+
 /* get a long from an array of u4 */
 static inline s8 getLongFromArray(const u4* ptr, int idx)
 {
@@ -180,6 +205,20 @@ static inline s8 getLongFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a long from an array of u4 */
+static inline s8 getLongFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.ll;
+}
+#endif
+
 /* store a long into an array of u4 */
 static inline void putLongToArray(u4* ptr, int idx, s8 val)
 {
@@ -197,6 +236,20 @@ static inline void putLongToArray(u4* ptr, int idx, s8 val)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a long into an array of u4 */
+static inline void putLongToArrayTaint(u4* ptr, int idx, s8 val)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { s8 ll; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.ll = val;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /* get a double from an array of u4 */
 static inline double getDoubleFromArray(const u4* ptr, int idx)
 {
@@ -216,6 +269,20 @@ static inline double getDoubleFromArray(const u4* ptr, int idx)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* get a double from an array of u4 */
+static inline double getDoubleFromArrayTaint(const u4* ptr, int idx)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.parts[0] = ptr[0];
+    conv.parts[1] = ptr[2];
+    return conv.d;
+}
+#endif
+
 /* store a double into an array of u4 */
 static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 {
@@ -233,6 +300,20 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 #endif
 }
 
+#ifdef WITH_TAINT_TRACKING
+/* store a double into an array of u4 */
+static inline void putDoubleToArrayTaint(u4* ptr, int idx, double dval)
+{
+    /* Need to use the "union" version for taint tracking */
+    union { double d; u4 parts[2]; } conv;
+
+    ptr += idx;
+    conv.d = dval;
+    ptr[0] = conv.parts[0];
+    ptr[2] = conv.parts[1];
+}
+#endif
+
 /*
  * If enabled, validate the register number on every access.  Otherwise,
  * just do an array access.
@@ -241,6 +322,55 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
  *
  * "_idx" may be referenced more than once.
  */
+#ifdef WITH_TAINT_TRACKING
+/* -- Begin Taint Tracking version ------------------------------- */
+/* Taint tags are interleaved between registers. All indexes must
+ * be multiplied by 2 (i.e., left bit shift by 1) */
+#ifdef CHECK_REGISTER_INDICES
+# define GET_REGISTER(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1]) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (fp[(_idx)<<1] = (u4)(_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object *)GET_REGISTER(_idx))
+# define SET_REGISTER_AS_OBJECT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_INT(_idx) ((s4) GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val) SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getLongFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969) )
+# define SET_REGISTER_WIDE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putLongToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969) )
+# define GET_REGISTER_FLOAT(_idx) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1])) : (assert(!"bad reg"),1969.0f) )
+# define SET_REGISTER_FLOAT(_idx, _val) \
+    ( (_idx) < curMethod->registersSize ? \
+        (*((float*) &fp[(_idx)<<1]) = (_val)) : (assert(!"bad reg"),1969.0f) )
+# define GET_REGISTER_DOUBLE(_idx) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        getDoubleFromArrayTaint(fp, ((_idx)<<1)) : (assert(!"bad reg"),1969.0) )
+# define SET_REGISTER_DOUBLE(_idx, _val) \
+    ( (_idx) < curMethod->registersSize-1 ? \
+        putDoubleToArrayTaint(fp, ((_idx)<<1), (_val)) : (assert(!"bad reg"),1969.0) )
+#else
+# define GET_REGISTER(_idx)                 (fp[(_idx)<<1])
+# define SET_REGISTER(_idx, _val)           (fp[(_idx)<<1] = (_val))
+# define GET_REGISTER_AS_OBJECT(_idx)       ((Object*) fp[(_idx)<<1])
+# define SET_REGISTER_AS_OBJECT(_idx, _val) (fp[(_idx)<<1] = (u4)(_val))
+# define GET_REGISTER_INT(_idx)             ((s4)GET_REGISTER(_idx))
+# define SET_REGISTER_INT(_idx, _val)       SET_REGISTER(_idx, (s4)_val)
+# define GET_REGISTER_WIDE(_idx)            getLongFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_WIDE(_idx, _val)      putLongToArrayTaint(fp, ((_idx)<<1), (_val))
+# define GET_REGISTER_FLOAT(_idx)           (*((float*) &fp[(_idx)<<1]))
+# define SET_REGISTER_FLOAT(_idx, _val)     (*((float*) &fp[(_idx)<<1]) = (_val))
+# define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArrayTaint(fp, ((_idx)<<1))
+# define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArrayTaint(fp, ((_idx)<<1), (_val))
+#endif
+/* -- End Taint Tracking version ---------------------------------- */
+#else /* no taint tracking */
 #ifdef CHECK_REGISTER_INDICES
 # define GET_REGISTER(_idx) \
     ( (_idx) < curMethod->registersSize ? \
@@ -284,6 +414,48 @@ static inline void putDoubleToArray(u4* ptr, int idx, double dval)
 # define GET_REGISTER_DOUBLE(_idx)          getDoubleFromArray(fp, (_idx))
 # define SET_REGISTER_DOUBLE(_idx, _val)    putDoubleToArray(fp, (_idx), (_val))
 #endif
+#endif /* end no taint tracking */
+
+#ifdef WITH_TAINT_TRACKING
+/* Core get and set macros */
+# define GET_REGISTER_TAINT(_idx)	     (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT(_idx, _val)	     (fp[((_idx)<<1)+1] = (u4)(_val))
+# define GET_REGISTER_TAINT_WIDE(_idx)       (fp[((_idx)<<1)+1])
+# define SET_REGISTER_TAINT_WIDE(_idx, _val) (fp[((_idx)<<1)+1] = \
+	                                      fp[((_idx)<<1)+3] = (u4)(_val))
+/* Alternate interfaces to help dereference register width */
+# define GET_REGISTER_TAINT_INT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_INT(_idx, _val)       SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_FLOAT(_idx)	          GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_FLOAT(_idx, _val)     SET_REGISTER_TAINT(_idx, _val)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)          GET_REGISTER_TAINT_WIDE(_idx)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)    SET_REGISTER_TAINT_WIDE(_idx, _val)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)       GET_REGISTER_TAINT(_idx)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val) SET_REGISTER_TAINT(_idx, _val)
+
+/* Object Taint interface */
+# define GET_ARRAY_TAINT(_arr)		      ((_arr)->taint.tag)
+# define SET_ARRAY_TAINT(_arr, _val)	      ((_arr)->taint.tag = (u4)(_val))
+
+/* Return value taint (assumes rtaint variable is in scope */
+# define GET_RETURN_TAINT()		      (rtaint.tag)
+# define SET_RETURN_TAINT(_val)		      (rtaint.tag = (u4)(_val))
+#else
+# define GET_REGISTER_TAINT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT(_idx, _val)		    ((void)0)
+# define GET_REGISTER_TAINT_WIDE(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_WIDE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_INT(_idx)		    ((void)0)
+# define SET_REGISTER_TAINT_INT(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_DOUBLE(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_DOUBLE(_idx, _val)	    ((void)0)
+# define GET_REGISTER_TAINT_AS_OBJECT(_idx)	    ((void)0)
+# define SET_REGISTER_TAINT_AS_OBJECT(_idx, _val)   ((void)0)
+# define GET_ARRAY_TAINT(_field)                    ((void)0)
+# define SET_ARRAY_TAINT(_field, _val)              ((void)0)
+# define GET_RETURN_TAINT()			    ((void)0)
+# define SET_RETURN_TAINT(_val)			    ((void)0)
+#endif
 
 /*
  * Get 16 bits from the specified offset of the program counter.  We always
@@ -449,6 +621,10 @@ static inline bool checkForNullExportPC(Object* obj, u4* fp, const u2* pc)
 #define self                    glue->self
 #define debugTrackedRefStart    glue->debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#define rtaint			glue->rtaint
+#endif
+
 /* ugh */
 #define STUB_HACK(x) x
 
@@ -571,6 +747,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_totype(vdst,                                         \
             GET_REGISTER##_fromtype(vsrc1));                                \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_totype(vdst,                                   \
+	    GET_REGISTER_TAINT##_fromtype(vsrc1));                          \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_FLOAT_TO_INT(_opcode, _opname, _fromvtype, _fromrtype,       \
@@ -596,6 +776,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         else                                                                \
             result = (_tovtype) val;                                        \
         SET_REGISTER##_tortype(vdst, result);                               \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_tortype(vdst,                                  \
+	    GET_REGISTER_TAINT##_fromrtype(vsrc1));                         \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(1);
 
@@ -605,6 +789,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|int-to-%s v%d,v%d", (_opname), vdst, vsrc1);                \
         SET_REGISTER(vdst, (_type) GET_REGISTER(vsrc1));                    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(1);
 
 /* NOTE: the comparison result is always a signed 4-byte integer */
@@ -631,6 +818,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             result = (_nanVal);                                             \
         ILOGV("+ result=%d\n", result);                                     \
         SET_REGISTER(vdst, result);                                         \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, TAINT_CLEAR);				    \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -672,6 +862,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         vsrc1 = INST_B(inst);                                               \
         ILOGV("|%s v%d,v%d", (_opname), vdst, vsrc1);                       \
         SET_REGISTER##_type(vdst, _pfx GET_REGISTER##_type(vsrc1) _sfx);    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT##_type(vdst, GET_REGISTER_TAINT##_type(vsrc1));  \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_INT(_opcode, _opname, _op, _chkdiv)                     \
@@ -707,6 +900,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s4) GET_REGISTER(vsrc2));     \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -721,6 +918,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int v%d,v%d", (_opname), vdst, vsrc1);                   \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (GET_REGISTER(vsrc2) & 0x1f));    \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vsrc1)|GET_REGISTER_TAINT(vsrc2)) );        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -754,6 +955,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             /* non-div/rem case */                                          \
             SET_REGISTER(vdst, GET_REGISTER(vsrc1) _op (s2) vsrc2);         \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
         FINISH(2);
 
 #define HANDLE_OP_X_INT_LIT8(_opcode, _opname, _op, _chkdiv)                \
@@ -788,6 +992,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vsrc1) _op (s1) vsrc2);                   \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -803,6 +1010,9 @@ GOTO_TARGET_DECL(exceptionThrown);
             (_opname), vdst, vsrc1, vsrc2);                                 \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vsrc1) _op (vsrc2 & 0x1f));                  \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst, GET_REGISTER_TAINT(vsrc1));                \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -834,6 +1044,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER(vdst,                                              \
                 (s4) GET_REGISTER(vdst) _op (s4) GET_REGISTER(vsrc1));      \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_INT_2ADDR(_opcode, _opname, _cast, _op)               \
@@ -843,6 +1057,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-int-2addr v%d,v%d", (_opname), vdst, vsrc1);             \
         SET_REGISTER(vdst,                                                  \
             _cast GET_REGISTER(vdst) _op (GET_REGISTER(vsrc1) & 0x1f));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT(vdst,                                            \
+	    (GET_REGISTER_TAINT(vdst)|GET_REGISTER_TAINT(vsrc1)) );         \
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_LONG(_opcode, _opname, _op, _chkdiv)                    \
@@ -879,6 +1097,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vsrc1) _op (s8) GET_REGISTER_WIDE(vsrc2)); \
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -893,6 +1115,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);       \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vsrc1) _op (GET_REGISTER(vsrc2) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	   (GET_REGISTER_TAINT_WIDE(vsrc1)|GET_REGISTER_TAINT_WIDE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -926,6 +1152,10 @@ GOTO_TARGET_DECL(exceptionThrown);
             SET_REGISTER_WIDE(vdst,                                         \
                 (s8) GET_REGISTER_WIDE(vdst) _op (s8)GET_REGISTER_WIDE(vsrc1));\
         }                                                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_SHX_LONG_2ADDR(_opcode, _opname, _cast, _op)              \
@@ -935,6 +1165,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-long-2addr v%d,v%d", (_opname), vdst, vsrc1);            \
         SET_REGISTER_WIDE(vdst,                                             \
             _cast GET_REGISTER_WIDE(vdst) _op (GET_REGISTER(vsrc1) & 0x3f)); \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_WIDE(vdst,                                       \
+	    (GET_REGISTER_TAINT_WIDE(vdst)|GET_REGISTER_TAINT_WIDE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_FLOAT(_opcode, _opname, _op)                            \
@@ -948,6 +1182,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);      \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vsrc1) _op GET_REGISTER_FLOAT(vsrc2));       \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vsrc1)|GET_REGISTER_TAINT_FLOAT(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -962,6 +1200,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double v%d,v%d,v%d", (_opname), vdst, vsrc1, vsrc2);     \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vsrc1) _op GET_REGISTER_DOUBLE(vsrc2));     \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vsrc1)|GET_REGISTER_TAINT_DOUBLE(vsrc2)));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -972,6 +1214,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-float-2addr v%d,v%d", (_opname), vdst, vsrc1);           \
         SET_REGISTER_FLOAT(vdst,                                            \
             GET_REGISTER_FLOAT(vdst) _op GET_REGISTER_FLOAT(vsrc1));        \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_FLOAT(vdst,                                      \
+	    (GET_REGISTER_TAINT_FLOAT(vdst)|GET_REGISTER_TAINT_FLOAT(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_X_DOUBLE_2ADDR(_opcode, _opname, _op)                     \
@@ -981,6 +1227,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("|%s-double-2addr v%d,v%d", (_opname), vdst, vsrc1);          \
         SET_REGISTER_DOUBLE(vdst,                                           \
             GET_REGISTER_DOUBLE(vdst) _op GET_REGISTER_DOUBLE(vsrc1));      \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+        SET_REGISTER_TAINT_DOUBLE(vdst,                                     \
+	    (GET_REGISTER_TAINT_DOUBLE(vdst)|GET_REGISTER_TAINT_DOUBLE(vsrc1)));\
+/* endif */                                                                 \
         FINISH(1);
 
 #define HANDLE_OP_AGET(_opcode, _opname, _type, _regsize)                   \
@@ -1006,6 +1256,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         }                                                                   \
         SET_REGISTER##_regsize(vdst,                                        \
             ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)]);            \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_ARRAY_TAINT(arrayObj)|GET_REGISTER_TAINT(vsrc2)));         \
+/* endif */								    \
         ILOGV("+ AGET[%d]=0x%x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));  \
     }                                                                       \
     FINISH(2);
@@ -1032,6 +1286,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ APUT[%d]=0x%08x", GET_REGISTER(vsrc2), GET_REGISTER(vdst));\
         ((_type*) arrayObj->contents)[GET_REGISTER(vsrc2)] =                \
             GET_REGISTER##_regsize(vdst);                                   \
+/* ifdef WITH_TAINT_TRACKING */						    \
+	SET_ARRAY_TAINT(arrayObj,                                           \
+		(GET_ARRAY_TAINT(arrayObj) |                                \
+		 GET_REGISTER_TAINT##_regsize(vdst)) );                     \
+/* endif */								    \
     }                                                                       \
     FINISH(2);
 
@@ -1076,6 +1335,11 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IGET '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_GET(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ifield->byteOffset)) );           \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1094,6 +1358,13 @@ GOTO_TARGET_DECL(exceptionThrown);
         SET_REGISTER##_regsize(vdst, dvmGetField##_ftype(obj, ref));        \
         ILOGV("+ IGETQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IGETQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	SET_REGISTER_TAINT##_regsize(vdst,                                  \
+	    (GET_REGISTER_TAINT(vsrc1)|                                     \
+	     dvmGetFieldTaint##_ftype(obj,ref)) );                          \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1121,6 +1392,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ IPUT '%s'=0x%08llx", ifield->field.name,                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
         UPDATE_FIELD_PUT(&ifield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetFieldTaint##_ftype(obj, ifield->byteOffset,                   \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1139,6 +1414,12 @@ GOTO_TARGET_DECL(exceptionThrown);
         dvmSetField##_ftype(obj, ref, GET_REGISTER##_regsize(vdst));        \
         ILOGV("+ IPUTQ %d=0x%08llx", ref,                                   \
             (u8) GET_REGISTER##_regsize(vdst));                             \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	/*TLOGW("|IPUTQ not supported by taint tracking!!!");*/             \
+	/* compile flag WITH_TAINT_ODEX controls this now */                \
+	dvmSetFieldTaint##_ftype(obj, ref,                                  \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1168,6 +1449,9 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SGET '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_GET(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	SET_REGISTER_TAINT##_regsize(vdst, dvmGetStaticFieldTaint##_ftype(sfield));\
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1192,6 +1476,10 @@ GOTO_TARGET_DECL(exceptionThrown);
         ILOGV("+ SPUT '%s'=0x%08llx",                                       \
             sfield->field.name, (u8)GET_REGISTER##_regsize(vdst));          \
         UPDATE_FIELD_PUT(&sfield->field);                                   \
+/* ifdef WITH_TAINT_TRACKING */                                             \
+	dvmSetStaticFieldTaint##_ftype(sfield,                              \
+		GET_REGISTER_TAINT##_regsize(vdst));                        \
+/* endif */                                                                 \
     }                                                                       \
     FINISH(2);
 
@@ -1358,6 +1646,9 @@ GOTO_TARGET(filledNewArray, bool methodCallRange)
         }
 
         retval.l = newArray;
+/* ifdef WITH_TAINT_TRACKING */
+        SET_RETURN_TAINT(TAINT_CLEAR);
+/* endif */
     }
     FINISH(3);
 GOTO_TARGET_END
@@ -2035,6 +2326,9 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
 
         u4* outs;
         int i;
+#ifdef WITH_TAINT_TRACKING
+	bool nativeTarget = dvmIsNativeMethod(methodToCall);
+#endif
 
         /*
          * Copy args.  This may corrupt vsrc1/vdst.
@@ -2045,8 +2339,31 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             assert(vsrc1 <= curMethod->outsSize);
             assert(vsrc1 == methodToCall->insSize);
             outs = OUTS_FROM_FP(fp, vsrc1);
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		for (i = 0; i < vsrc1; i++) {
+		    outs[i] = GET_REGISTER(vdst+i);
+		}
+		/* clear return taint (vsrc1 is the count) */
+		outs[vsrc1] = TAINT_CLEAR;
+		/* copy the taint tags (vsrc1 is the count) */
+		for (i = 0; i < vsrc1; i++) {
+		    outs[vsrc1+1+i] = GET_REGISTER_TAINT(vdst+i);
+		}
+	    } else {
+		int slot = 0;
+		for (i = 0; i < vsrc1; i++) {
+		    slot = i << 1;
+		    outs[slot] = GET_REGISTER(vdst+i);
+		    outs[slot+1] = GET_REGISTER_TAINT(vdst+i);
+		}
+		/* clear native hack (vsrc1 is the count)*/
+		outs[vsrc1<<1] = TAINT_CLEAR;
+	    }
+#else
             for (i = 0; i < vsrc1; i++)
                 outs[i] = GET_REGISTER(vdst+i);
+#endif
         } else {
             u4 count = vsrc1 >> 4;
 
@@ -2065,9 +2382,56 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
                 vdst >>= 4;
             }
 #else
+            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
+#ifdef WITH_TAINT_TRACKING
+	    if (nativeTarget) {
+		switch (count) {
+		case 5:
+		    outs[4] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[count+5] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[3] = GET_REGISTER(vdst >> 12);
+		    outs[count+4] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[2] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[count+3] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[1] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[count+2] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[count+1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count] = TAINT_CLEAR;
+	    } else { /* interpreted target */
+		switch (count) {
+		case 5:
+		    outs[8] = GET_REGISTER(vsrc1 & 0x0f);
+		    outs[9] = GET_REGISTER_TAINT(vsrc1 & 0x0f);
+		case 4:
+		    outs[6] = GET_REGISTER(vdst >> 12);
+		    outs[7] = GET_REGISTER_TAINT(vdst >> 12);
+		case 3:
+		    outs[4] = GET_REGISTER((vdst & 0x0f00) >> 8);
+		    outs[5] = GET_REGISTER_TAINT((vdst & 0x0f00) >> 8);
+		case 2:
+		    outs[2] = GET_REGISTER((vdst & 0x00f0) >> 4);
+		    outs[3] = GET_REGISTER_TAINT((vdst & 0x00f0) >> 4);
+		case 1:
+		    outs[0] = GET_REGISTER(vdst & 0x0f);
+		    outs[1] = GET_REGISTER_TAINT(vdst & 0x0f);
+		default:
+		    ;
+		}
+		/* clear the native hack */
+		outs[count<<1] = TAINT_CLEAR;
+	    }
+#else /* ndef WITH_TAINT_TRACKING */
             // This version executes fewer instructions but is larger
             // overall.  Seems to be a teensy bit faster.
-            assert((vdst >> 16) == 0);  // 16 bits -or- high 16 bits clear
             switch (count) {
             case 5:
                 outs[4] = GET_REGISTER(vsrc1 & 0x0f);
@@ -2082,6 +2446,7 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             default:
                 ;
             }
+#endif /* WITH_TAINT_TRACKING */
 #endif
         }
     }
@@ -2103,13 +2468,23 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
             methodToCall->clazz->descriptor, methodToCall->name,
             methodToCall->shorty);
 
+#ifdef WITH_TAINT_TRACKING
+        newFp = (u4*) SAVEAREA_FROM_FP(fp) - 
+	    ((methodToCall->registersSize << 1) + 1);
+#else
         newFp = (u4*) SAVEAREA_FROM_FP(fp) - methodToCall->registersSize;
+#endif
         newSaveArea = SAVEAREA_FROM_FP(newFp);
 
         /* verify that we have enough space */
         if (true) {
             u1* bottom;
+#ifdef WITH_TAINT_TRACKING
+            bottom = (u1*) newSaveArea - 
+		(methodToCall->outsSize * sizeof(u4) + 4);
+#else
             bottom = (u1*) newSaveArea - methodToCall->outsSize * sizeof(u4);
+#endif
             if (bottom < self->interpStackEnd) {
                 /* stack overflow */
                 LOGV("Stack overflow on method call (start=%p end=%p newBot=%p(%d) size=%d '%s')\n",
@@ -2132,8 +2507,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * messages are disabled -- we want valgrind to report any
              * used-before-initialized issues.
              */
+#ifdef WITH_TAINT_TRACKING
+	    /* Don't need to worry about native target, because if
+	     * native target, registerSize = insSize */
+            memset(newFp, 0xcc,
+                (methodToCall->registersSize - methodToCall->insSize) * 8);
+#else
             memset(newFp, 0xcc,
                 (methodToCall->registersSize - methodToCall->insSize) * 4);
+#endif
         }
 #endif
 
@@ -2204,6 +2586,15 @@ GOTO_TARGET(invokeMethod, bool methodCallRange, const Method* _methodToCall,
              * to the method arguments.
              */
             (*methodToCall->nativeFunc)(newFp, &retval, methodToCall, self);
+#ifdef WITH_TAINT_TRACKING
+	    /* Get the return taint if available */
+	    {
+		/* use same logic as above to calculate count */
+		u4 count = (methodCallRange) ? vsrc1 : vsrc1 >> 4;
+		u4* outs = OUTS_FROM_FP(fp, count);
+		SET_RETURN_TAINT(outs[count]);
+	    }
+#endif
 
 #if (INTERP_TYPE == INTERP_DBG)
             if (gDvm.debuggerActive) {
@@ -2261,3 +2652,6 @@ GOTO_TARGET_END
 #undef self
 #undef debugTrackedRefStart
 
+#ifdef WITH_TAINT_TRACKING
+#undef rtaint
+#endif
diff --git a/vm/native/java_lang_System.c b/vm/native/java_lang_System.c
index 96cc144..a2da698 100644
--- a/vm/native/java_lang_System.c
+++ b/vm/native/java_lang_System.c
@@ -129,6 +129,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
         (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                 (const u1*)srcArray->contents + srcPos * width,
                 length * width);
+#ifdef WITH_TAINT_TRACKING
+	if (dstPos == 0 && (int)dstArray->length == length) {
+	    /* entire array replaced */
+	    dstArray->taint.tag = srcArray->taint.tag;
+	} else {
+	    dstArray->taint.tag |= srcArray->taint.tag;
+	}
+#endif
     } else {
         /*
          * Neither class is primitive.  See if elements in "src" are instances
@@ -150,6 +158,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
             (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                     (const u1*)srcArray->contents + srcPos * width,
                     length * width);
+#ifdef WITH_TAINT_TRACKING
+	    if (dstPos == 0 && (int)dstArray->length == length) {
+		/* entire array replaced */
+		dstArray->taint.tag = srcArray->taint.tag;
+	    } else {
+		dstArray->taint.tag |= srcArray->taint.tag;
+	    }
+#endif
             dvmWriteBarrierArray(dstArray, dstPos, dstPos+length);
         } else {
             /*
@@ -197,6 +213,14 @@ static void Dalvik_java_lang_System_arraycopy(const u4* args, JValue* pResult)
             (*copyFunc)((u1*)dstArray->contents + dstPos * width,
                     (const u1*)srcArray->contents + srcPos * width,
                     copyCount * width);
+#ifdef WITH_TAINT_TRACKING
+	    if (dstPos == 0 && (int)dstArray->length == length) {
+		/* entire array replaced */
+		dstArray->taint.tag = srcArray->taint.tag;
+	    } else {
+		dstArray->taint.tag |= srcArray->taint.tag;
+	    }
+#endif
             dvmWriteBarrierArray(dstArray, 0, copyCount);
             if (copyCount != length) {
                 dvmThrowExceptionFmt("Ljava/lang/ArrayStoreException;",
diff --git a/vm/oo/Object.h b/vm/oo/Object.h
index 903450f..ee88d64 100644
--- a/vm/oo/Object.h
+++ b/vm/oo/Object.h
@@ -25,6 +25,10 @@
 
 #include <stddef.h>
 
+#ifdef WITH_TAINT_TRACKING
+#include "interp/Taint.h"
+#endif
+
 /* fwd decl */
 struct DataObject;
 struct InitiatingLoaderList;
@@ -304,6 +308,10 @@ struct ArrayObject {
     /* number of elements; immutable after init */
     u4              length;
 
+#ifdef WITH_TAINT_TRACKING
+    Taint           taint;
+#endif
+
     /*
      * Array contents; actual size is (length * sizeof(type)).  This is
      * declared as u8 so that the compiler inserts any necessary padding
@@ -346,6 +354,9 @@ struct Field {
 struct StaticField {
     Field           field;          /* MUST be first item */
     JValue          value;          /* initially set from DEX for primitives */
+#ifdef WITH_TAINT_TRACKING
+    Taint           taint;
+#endif
 };
 
 /*
-- 
1.7.1

